<html lang="en">
<head>
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
	<meta content="utf-8" http-equiv="encoding" />
	<title>Social Stream - Hype Meter</title>
	<meta name="title" content="Social Stream - Hype Meter" />
	<link rel="icon" href="./favicon.ico" />
	<style>
:root {
  /* Base values */
  --font-color: #FFF;
  --font-color-title: #FFF;
  --font-family: 'Sora', Roboto, Arial, sans-serif;
  --background-color: #0000;
  --electron-drag-fix: drag;
  --outline: -0.5px -0.5px 0 #000, 0.5px -0.5px 0 #000, -0.5px 0.5px 0 #000, 0.5px 0.5px 0 #000;
  --scale: 1;
  /* Base measurements */
  --base-width: 40px;
  --base-font-size: 300%;
  --base-padding: 5px;
  /* Scaled values */
  --width: calc(var(--base-width) * var(--scale));
  --font-size: calc(var(--base-font-size) * var(--scale));
  --padding: calc(var(--base-padding) * var(--scale));
}
/* example of how to remotely load a font */
@font-face {
  font-family: 'opendyslexic';
  src: url('https://vdo.ninja/examples/OpenDyslexic-Regular.otf');
  font-style: normal;
  font-weight: normal;
} 
/* latin-ext */
@font-face {
  font-family: 'Sora';
  font-style: normal;
  font-weight: 200;
  font-display: swap;
  src: url(./thirdparty//xMQbuFFYT72XzQspDre2.woff2) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Sora';
  font-style: normal;
  font-weight: 200;
  font-display: swap;
  src: url(./thirdparty//xMQbuFFYT72XzQUpDg.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin-ext */
@font-face {
  font-family: 'Sora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(./thirdparty/xMQbuFFYT72XzQspDre2.woff2) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Sora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(./thirdparty//xMQbuFFYT72XzQUpDg.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* latin-ext */
@font-face {
  font-family: 'Sora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(./thirdparty//xMQbuFFYT72XzQspDre2.woff2) format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Sora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(./thirdparty//xMQbuFFYT72XzQUpDg.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
body {
	font-family: var(--font-family);
	-moz-transform-origin: 0 0;
	width:100%;
	height:100%;
	max-width:100vw;
	max-height:100vh;
	margin:0;
	padding:0;
	overflow:hidden;
	user-select: none;
	animation: fadeInAnimation ease 1s;
	animation-iteration-count: 1;
	animation-fill-mode: forwards;
	color: var(--font-color);
	font-weight: 700;
	background-color: var(--background-color);
	text-shadow: var(--outline);
	scrollbar-color:#666 #201c29;
	position: absolute;
	left: 0;
	top: 0;
}
.sourceicons {
  border-radius:100px;
}
.el { 
  width: var(--width);
  height: var(--width);
}

.x {
  animation: x var(--x-speed) linear infinite alternate;
}
.y {
  animation: y var(--y-speed) linear infinite alternate;
}
@keyframes x {
  100% {
    transform: translateX(calc(100vw - var(--width)));
  }
}
@keyframes y {
  100% {
    transform: translateY(calc(100vh - var(--width)));
  }
}
::-webkit-scrollbar {
  width: 15px;
}
::-webkit-scrollbar-track {
  -webkit-box-shadow: inset 0 0 13px rgb(0 0 0 / 90%);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb {
  border-radius: 4px;
  -webkit-box-shadow: inset 0 0 16px rgb(150 150 150 / 100%);
  border: solid 3px transparent;
}
body > div {
  -webkit-app-region: no-drag;
}
@keyframes fadeInAnimation {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
@keyframes fadeIn {
0% { opacity: 0; }
100% { opacity: 1; }
}
div > span {
  position:relative;
  margin: auto;
  padding: 0;
  object-fit: contain;
  vertical-align: top;
  display: block;
}
[data-viewers] {
  font-size: calc(30% * var(--scale));
  margin: 0;
  line-height: 1.2;
  min-width: calc(40px * var(--scale));
  order: -1;
}
[data-viewers]:empty{
  display:none!important;
}
[data-viewers]::before {
  content: "views: "; /* YouTube's API requires "views" instead of "üëÅÔ∏è" */
}

[data-chatters] {
  font-size: calc(30% * var(--scale));
  margin: 0;
  line-height: 1.2;
  min-width: calc(40px * var(--scale));
  order: -1;
}
[data-chatters]:empty{
  display:none!important;
   margin-right: calc(2px * var(--scale));
}
[data-chatters]::before {
  content: "active: "; 
   margin-right: calc(2px * var(--scale));
}

img {
  max-width: calc(var(--width) * 1.5);
  max-height: var(--width);
  margin: auto;
  padding: 3px;
  object-fit: contain;
  vertical-align: top;
}
.hidden {
  display:none!important;
}
.emoji{
  font-size: var(--font-size);
  vertical-align: sub;
  text-shadow: 0 0 #0000;
  width: var(--width);
  height: var(--width);
  position:absolute;
  object-fit:contain;
}
.electronDraggable {
  -webkit-app-region: var(--electron-drag-fix);
}
@keyframes fadeOut {
0% { opacity: 1; }
100% { opacity: 0; }
}
span.zero-width-parent {
  display: inline-block;
  width: 0;
  position:absolute;
}
span.zero-width-parent img.zero-width-emote {
  right: 0;
  position:absolute;
}
.sourceStatHolder {
  align-items: center;
  background-color: #47B5;
  border-radius: calc(var(--width) / 2 + var(--padding) );
  padding: var(--padding);
  margin: auto 1px;
  height: 88px;
  text-align: center;
  min-width: 100px;
  gap:2px;
}
.short .sourceStatHolder {
	height: 74px;
}
.align-left {
  display: block;
  margin-left: 0;
  margin-right: auto;
  text-align: left;
}
.align-right {
  display: block;
  margin-left: auto;
  margin-right: 0;
  text-align: right;
}
.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}
.align-center .sourceStatHolder {
  justify-content: center;
}
.align-center [data-viewers],
.align-center [data-chatters] {
  text-align: center !important;
  justify-content: center;
}
.sourceStatHolder img {
  width: calc(var(--width) );
  height: calc(var(--width) );
  object-fit: contain;
  margin: 0;
  padding: calc(3px * var(--scale));
}
#hype {
  display: inline-flex;
  font-size: var(--font-size);
}
#hype .style-topbar {
  padding: 0 0 2px 5px;
}

#hypetitle{
  color: var(--font-color-title);
  padding: 10px;
  font-size: calc(var(--font-size) / 2);
  display: flex;
  margin: auto;
  flex-wrap: nowrap;
  align-content: flex-end;
  justify-content: space-around;
  align-items: center;
  flex-direction: column;
}
#parentHolder {
  display:inline-block;
  animation: fadeInAnimation ease 2s;
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}
/* Compact Style */
.style-compact .sourceStatHolder {
  background-color: #0005;
  margin: calc(0.5px * var(--scale));
  padding: calc(2px * var(--scale)) calc(4px * var(--scale));
  border-radius: calc(2px * var(--scale));
  height: calc(20px * var(--scale));
  display: flex;
  align-items: center;
  gap: calc(4px * var(--scale));
  min-width:unset;
}
.style-compact [data-viewers],
.style-compact [data-chatters] {
  font-size: calc(12px * var(--scale));
  margin: 0;
  line-height: 1;
  min-width: calc(25px * var(--scale));
  text-align: left;
  display: flex;
  align-items: center;
}
.style-compact [data-viewers]::before {
  content: "üëÅÔ∏è ";
}
.style-compact [data-chatters]::before {
  content: "üó£Ô∏è ";
}
.style-compact img {
  height: calc(16px * var(--scale));
  width: calc(16px * var(--scale));
  padding: 0;
  margin: 0;
}

/* Modern Style */
.style-modern .sourceStatHolder {
  background-color: #2225;
  backdrop-filter: blur(4px);
  border: 1px solid #fff3;
  box-shadow: 0 2px 8px #0004;
  margin: calc(2px * var(--scale));
  padding: calc(4px * var(--scale)) calc(12px * var(--scale)) calc(4px * var(--scale)) calc(10px * var(--scale));
  border-radius: calc(12px * var(--scale));
  height: calc(32px * var(--scale));
  display: flex;
  align-items: center;
  gap: calc(6px * var(--scale));
  min-width: unset;
}
.style-modern .sourceStatHolder > span {
	display: inline-block;
}
.style-modern [data-viewers]::before {
	content: "üëÅÔ∏è ";
	font-size: 97%;
	top:0px;
	top: -1px;
	position: relative;
}
.style-modern [data-chatters]::before {
	content: "üó£Ô∏è ";
	font-size: 97%;
	top:0px;
	top: -1px;
	position: relative;
}
.style-modern [data-viewers], 
.style-modern [data-chatters] {
  font-size: calc(19px * var(--scale));
  margin: 0;
  line-height: 1;
  min-width: calc(45px * var(--scale));
  text-align: left;
  display: flex;
  align-items: center;
  position:relative;
  top:1px;
}
.style-modern img {
  padding: 0;
  margin: 0;
  height: calc(24px * var(--scale));
  width: calc(24px * var(--scale));
  filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
}

/* Minimal Style */
.style-minimal .sourceStatHolder {
  background: none;
  margin: 0;
  padding: calc(5px * var(--scale)) calc(3px * var(--scale));
  height: calc(18px * var(--scale));
  display: flex;
  align-items: center;
  gap: calc(1px * var(--scale));
  min-width: unset;
}
.style-minimal [data-viewers],
.style-minimal [data-chatters] {
  font-size: calc(11px * var(--scale));
  margin-right: 2px;
  line-height: 1;
  min-width: calc(2px * var(--scale));
  text-align: left;
  opacity: 0.9;
  display: flex;
  align-items: center;
  order: 1;
}

.style-minimal [data-viewers]::before {
  content: "";
}
.style-minimal [data-chatters]::before {
  content: "";
}
.style-minimal img {
  height: calc(14px * var(--scale));
  width: calc(14px * var(--scale));
  padding: 0;
  margin: 0;
  opacity: 0.8;
}

/* Title styles for all */
.style-compact #hypetitle,
.style-modern #hypetitle,
.style-minimal #hypetitle {
  font-size: 50%;
  padding: 3px;
}
.style-modern #hype {
  gap: 2px;
  display: inline-flex;
  align-items: center;
}
.style-compact #hype, .style-minimal #hype{
  gap: 0px;
  display: inline-flex;
  align-items: center;
}
.style-compact #hype{
  padding: 1px;
}
#hype:empty {
    display: none;
}
.style-topbar {
  position: fixed !important;
  right: 0;
  top: 0;
  background-color: #0009;
  border-radius: 0 0 0 calc(13px * var(--scale));
}
.style-topbar .sourceStatHolder {
  background: none;
  margin: 0;
  padding:0;
  min-height: calc(34px * var(--scale));
  display: inline-flex;
  align-items: center;
  height: unset;
  min-width: unset;
  gap:0px;

}
.style-topbar img {
  height: calc(26px * var(--scale));
  width: calc(26px * var(--scale));
  padding: 0;
  margin-left: calc(4px * var(--scale));
}
.style-topbar [data-viewers], .style-topbar [data-chatters] {
  font-size: calc(22px * var(--scale));
  margin: 0;
  padding-left: calc(5px * var(--scale));
  padding-right: 0;
  min-width: calc(30px * var(--scale));
  order: 1;
  text-align: left;
  top: 1px;
  position:relative;
}
.style-topbar [data-chatters]::before, .style-topbar [data-viewers]::before  {
  content: "";
}
.style-topbar #hype { 
	margin-left: 11px;
	margin-bottom: 5px;
	margin-left: 11px;
	margin-bottom: 5px;
}
	</style>
</head>
<body class="electronDraggable" id="output">
	<div id="parentHolder" class="hidden">
		<div id="hype"></div>
		<div id="hypetitle">Active chatters in the last 5-minutes</div>
	</div>
<script>window.onerror = function backupErr(errorMsg, url = false, lineNumber = false) {
    console.error(errorMsg);
    console.error(lineNumber);
    console.error("Unhandled Error occured");
    return false;
};

function getById(id) {
    var el = document.getElementById(id);
    if (!el) {
        el = document.createElement("span");
    }
    return el;
}
(function(w) {
    w.URLSearchParams = w.URLSearchParams || function(searchString) {
        var self = this;
        self.searchString = searchString;
        self.get = function(name) {
            var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(self.searchString);
            if (results == null) {
                return null;
            } else {
                return decodeURI(results[1]) || 0;
            }
        };
    };
})(window);
var urlParams = new URLSearchParams(window.location.search);
var iframe = null;
var roomID = "test";
var darkmode = null;
var isOBSBrowserSource = false;
var customNodeLimit = false;
var body = document.body;
var html = document.documentElement;
var mainOutputWindow = document.getElementById("output");
var parentHolder = document.getElementById("parentHolder");
var hypeContainer = document.getElementById("hype");
var hypeTitle = document.getElementById("hypetitle");
var showdupes = true;
var hidereplies = false;
var uniqueId = "";
var sourceTypes = {};
var computedStyle = getComputedStyle(document.documentElement);
try {
    if ((window.ninjafy || window.electronApi)) {
        document.body.style.width = "95%";
        setTimeout(function() {
            document.body.style.width = "100%";
        }, 1000);
        setTimeout(function() {
            document.body.style.width = "98%";
        }, 2000);
        setTimeout(function() {
            document.body.style.width = "100%";
        }, 5000);
    }
} catch (e) {}
var timeoutDelay = 5000;
if (urlParams.has("showtime")) {
    timeoutDelay = parseInt(urlParams.get("showtime")) || 0;
}
if (urlParams.has("session")) {
    roomID = urlParams.get("session");
} else if (urlParams.has("s")) {
    roomID = urlParams.get("s");
} else if (urlParams.has("id")) {
    roomID = urlParams.get("id");
} else if (window.location.protocol == "file:") {
    roomID = prompt("Enter your session ID here, or add it to the URL.");
    if (roomID) {
        var href = window.location.href;
        var arr = href.split('?');
        var newurl;
        if (arr.length > 1 && arr[1] !== '') {
            newurl = href + '&session=' + roomID;
        } else {
            newurl = href + '?session=' + roomID;
        }
        window.history.pushState({
            path: newurl.toString()
        }, '', newurl.toString());
    } else {
        alert("You need to provide your extension's session ID for this page to work");
    }
} else {
    window.location.href = "https://github.com/steveseguin/live-chat-overlay#readme";
}
var password = "false";
if (urlParams.has("password")) {
    password = urlParams.get("password") || "false";
}
if (urlParams.has("uniqueid")) {
    uniqueId = urlParams.get("uniqueid");
}

function loadGoogleFont(fontName) {
    const formattedFontName = fontName.replace(/\s/g, '+');
    const link = document.createElement('link');
    link.href = `https://fonts.googleapis.com/css2?family=${formattedFontName}&display=swap`;
    link.rel = 'stylesheet';
    document.head.appendChild(link);
    var currentFont = getComputedStyle(document.documentElement).getPropertyValue('--font-family').trim();
    document.documentElement.style.setProperty("--font-family", "'" + fontName.replaceAll("+", " ") + "', " + currentFont);
}
			
if (urlParams.get('font')) {
	const raw = urlParams.get('font').trim();
	const clean = raw.replace(/^['"]|['"]$/g, '');
	const escaped = clean.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
	document.documentElement.style.setProperty('--font-family', `"${escaped}", Sora, Roboto, Helvetica, Geneva, Verdana, Arial, sans-serif`);
}

if (urlParams.get("googlefont")) {
    loadGoogleFont(urlParams.get("googlefont"));
}
if (urlParams.has('css')) {
    var cssURL = urlParams.get('css');
    cssURL = decodeURI(cssURL);
    var cssStylesheet = document.createElement('link');
    cssStylesheet.rel = 'stylesheet';
    cssStylesheet.type = 'text/css';
    cssStylesheet.media = 'screen';
    cssStylesheet.href = cssURL;
    document.getElementsByTagName('head')[0].appendChild(cssStylesheet);
}
if (urlParams.has("base64css") || urlParams.has("b64css") || urlParams.has("cssbase64") || urlParams.has("cssb64")) {
    try {
        var base64Css = urlParams.get("base64css") || urlParams.get("b64css") || urlParams.get("cssbase64") || urlParams.get("cssb64");
        var css = decodeURIComponent(atob(base64Css));
        var cssStyleSheet = document.createElement("style");
        cssStyleSheet.innerText = css;
        document.querySelector("head").appendChild(cssStyleSheet);
    } catch (e) {
        console.error(e);
    }
}
if (urlParams.has("fontsize")) {
    const scaleValue = parseFloat(urlParams.get("fontsize")) || 1.0;
    document.documentElement.style.setProperty("--scale", scaleValue);
}
var alignment = null;
var alignRightLegacy = urlParams.has("alignright");
if (urlParams.has("align")) {
    var requestedAlignment = (urlParams.get("align") || "").toLowerCase();
    if (requestedAlignment === "left" || requestedAlignment === "center" || requestedAlignment === "right") {
        alignment = requestedAlignment;
    }
}
if (alignment === null && alignRightLegacy) {
    alignment = "right";
}
if (urlParams.has("hidetitle")) {
    if (hypeTitle) {
        hypeTitle.classList.add("hidden");
    }
}
if (urlParams.has("opacity")) {
    getById("output").style.opacity = urlParams.get("opacity") || 0.3
}
var conCon = 1;
var socketserver = false;
var serverURL = urlParams.has("localserver") ? "ws://127.0.0.1:3000" : "wss://io.socialstream.ninja";

// Allow custom channel pair via URL params
// Defaults for Hype overlay are out:3, in:4
var outChannel = 3;
var inChannel = 4;
try {
    if (urlParams.has("out")) {
        outChannel = parseInt(urlParams.get("out")) || outChannel;
    } else if (urlParams.has("outchan")) {
        outChannel = parseInt(urlParams.get("outchan")) || outChannel;
    }
    if (urlParams.has("in")) {
        inChannel = parseInt(urlParams.get("in")) || inChannel;
    } else if (urlParams.has("inchan")) {
        inChannel = parseInt(urlParams.get("inchan")) || inChannel;
    }
} catch(e) {}

function setupSocket() {
    socketserver.onclose = function() {
        setTimeout(function() {
            conCon += 1;
            socketserver = new WebSocket(serverURL);
            setupSocket();
        }, 100 * conCon);
    };
    socketserver.onopen = function() {
        conCon = 1;
        // Join with the configured channel pair
        socketserver.send(JSON.stringify({
            "join": roomID,
            "out": outChannel,
            "in": inChannel
        }));
    };
    socketserver.addEventListener('message', function(event) {
        var resp = false
        if (event.data) {
            var data = JSON.parse(event.data);
            processInput(data);
            if (data.get) {
                var ret = {};
                ret.callback = {};
                ret.callback.get = data.get
                ret.callback.result = true;
                socketserver.send(JSON.stringify(ret));
            }
        }
    });
}
if (urlParams.has("server") || urlParams.has("server2")) {
    serverURL = urlParams.get("server") || urlParams.get("server2") || serverURL;
    socketserver = new WebSocket(serverURL);
    setupSocket();
}
if (urlParams.has("chroma")) {
    var chroma = urlParams.get("chroma") || "0F0";
    document.body.style.backgroundColor = "#" + chroma;
}
var speed = 1.0;
if (urlParams.has("speed")) {
    speed = parseFloat(urlParams.get("speed")) || 1;
    speed = 1 / speed;
    document.documentElement.style.setProperty("--x-speed", (13 * speed) + "%");
    document.documentElement.style.setProperty("--y-speed", (7 * speed) + "%");
}
try {
    if (window.obsstudio) {
        window.obsstudio.getStatus(function(obsStatus) {
            isOBSBrowserSource = true;
        });
    }
} catch (e) {}
if (urlParams.has("darkmode")) {
    darkmode = true;
} else if (urlParams.has("lightmode")) {
    darkmode = false;
} else if (darkmode === null) {
    darkmode = true;
} else {
    document.body.classList.add("lightmode");
    document.documentElement.style.setProperty("--font-color-title", "#000");
    document.documentElement.style.setProperty("--font-color", "#000");
    if (!urlParams.has("nooutline")) {
        document.documentElement.style.setProperty("--outline", "-0.5px -0.5px 0 #FFF, 0.5px -0.5px 0 #FFF, -0.5px 0.5px 0 #FFF, 0.5px 0.5px 0 #FFF");
    }
}
if (urlParams.has("transparent")) {
    document.documentElement.style.setProperty("--background-color", "#0000", "important");
}
if (urlParams.has("nooutline")) {
    document.documentElement.style.setProperty("--outline", "0px");
}
var showViewers = true;
var showChatters = true;
if (urlParams.has("viewersonly")) {
    showViewers = true;
    showChatters = false;
    if (hypeContainer) {
        hypeContainer.classList.add("short");
    }
}
if (urlParams.has("chattersonly")) {
    showViewers = false;
    showChatters = true;
    if (hypeContainer) {
        hypeContainer.classList.add("short");
    }
}
var titleText = "";
if (showViewers && showChatters) {
    titleText = "Active chatters and viewers in the last 5-minutes";
} else if (showViewers) {
    titleText = "Current viewer count";
} else {
    titleText = "Active chatters in the last 5-minutes";
}
if (hypeTitle) {
    hypeTitle.textContent = titleText;
}
let style = "default";
if (urlParams.has("style")) {
    style = urlParams.get("style");
}

// Combination settings from URL parameters
var combineYouTube = false;
var combineAll = false;

if (urlParams.has("combineyoutube")) {
    combineYouTube = true;
}

if (urlParams.has("combineall")) {
    combineAll = true;
}

// Apply the style to the parent holder
if (parentHolder) {
    parentHolder.classList.add("style-" + style);
}

let scale = 1;
if (urlParams.has("scale")) {
    scale = parseFloat(urlParams.get("scale")) || 3.0;
}
if (urlParams.has("style")) {
    switch (urlParams.get("style")) {
        case "compact":
            document.documentElement.style.setProperty("--padding", "8px");
            document.documentElement.style.setProperty("--width", "24px");
            scale = scale * 2;
            break;
        case "modern":
            document.documentElement.style.setProperty("--padding", "10px");
            document.documentElement.style.setProperty("--width", "32px");
            break;
        case "minimal":
            document.documentElement.style.setProperty("--padding", "6px");
            document.documentElement.style.setProperty("--width", "20px");
            if (hypeTitle) {
                hypeTitle.classList.add("hidden");
            }
            scale = scale * 3;
            break;
        case "topbar":
            if (parentHolder) {
                parentHolder.style.position = "fixed";
                parentHolder.style.top = "0";
                parentHolder.style.left = "";
                parentHolder.style.right = "";
                parentHolder.style.transform = "";
                var topbarAlignment = alignment || "right";
                if (topbarAlignment === "center") {
                    parentHolder.style.left = "50%";
                    parentHolder.style.transform = "translateX(-50%)";
                    if (hypeContainer) {
                        hypeContainer.style.justifyContent = "center";
                    }
                } else if (topbarAlignment === "left") {
                    parentHolder.style.left = "0";
                } else {
                    parentHolder.style.right = "0";
                }
            }
            if (hypeTitle) {
                hypeTitle.classList.add("hidden");
            }
            break;
    }
}

if (alignment && parentHolder) {
    if (style !== "topbar") {
        parentHolder.classList.add("align-" + alignment);
        if (alignment === "left") {
            parentHolder.style.marginLeft = "0";
            parentHolder.style.marginRight = "auto";
            parentHolder.style.textAlign = "left";
        } else if (alignment === "right") {
            parentHolder.style.marginLeft = "auto";
            parentHolder.style.marginRight = "0";
            parentHolder.style.textAlign = "right";
        } else {
            parentHolder.style.marginLeft = "auto";
            parentHolder.style.marginRight = "auto";
            parentHolder.style.textAlign = "center";
        }
        if (alignRightLegacy) {
            parentHolder.style.position = "absolute";
            parentHolder.style.right = "0";
            parentHolder.style.left = "";
        }
        if (alignment === "center" && hypeContainer) {
            hypeContainer.style.justifyContent = "center";
        }
    } else if (alignment === "left" || alignment === "right") {
        parentHolder.classList.add("align-" + alignment);
    }
}
document.body.style.transform = `scale(${scale})`;
document.body.style.transformOrigin = '0 0';
document.body.style.width = `${100/scale}%`;
document.body.style.height = `${100/scale}%`;

function getSourceImage(type) {
    if (type === "global") return "global";
    if (type.includes('-')) {
        return type.split('-')[0];
    }
    return type;
}
var lastUpdated = {};
var hasViewerCount = {};
var activeChatters = {};
var aggregatedViewers = {};

function handleClearAction(clearAction) {
    if (!clearAction || !clearAction.action) return;
    if (clearAction.action === "refreshSources") {
        activeChatters = {};
        hasViewerCount = {};
        lastUpdated = {};
        const hypeEl = document.getElementById("hype");
        if (hypeEl) hypeEl.innerHTML = "";
        if (parentHolder) {
            parentHolder.classList.add("hidden");
        }
        console.log("Hype.html: Cleared local state due to refreshSources action.");
    }
}

function processInput(data) {

    if (!data || !("hype" in data)) {
        return;
    }
    if (uniqueId && data.hype.uniqueId && data.hype.uniqueId !== uniqueId) {
        return;
    }
    if (data.hype.clear) {
        handleClearAction(data.hype.clear);
        return;
    }
    const hypeContainer = document.getElementById("hype");
    if (!hypeContainer) {
        console.error("hype.html: 'hype' container element not found!");
        return;
    }
    // Do not clear and rebuild on each update ‚Äî avoid flicker
    const parentHolder = document.getElementById("parentHolder");
    if (!parentHolder) {
        console.error("hype.html: 'parentHolder' element not found!");
        return;
    }
    let combinedData = data.hype.combined || {};
    
    // Apply combination logic based on URL parameters
    if (combineAll) {
        // Combine all sources into one global count
        let globalChatters = 0;
        let globalViewers = 0;
        
        for (const sourceType in combinedData) {
            if (typeof combinedData[sourceType] === 'object') {
                globalChatters += parseInt(combinedData[sourceType].chatters) || 0;
                globalViewers += parseInt(combinedData[sourceType].viewers) || 0;
            }
        }
        
        combinedData = {
            global: {
                chatters: globalChatters,
                viewers: globalViewers
            }
        };
    } else if (combineYouTube) {
        // Combine YouTube and YouTube Shorts
        let youtubeChatters = 0;
        let youtubeViewers = 0;
        let hasYouTube = false;
        
        const newCombinedData = {};
        
        for (const sourceType in combinedData) {
            if (sourceType === "youtube" || sourceType === "youtubeshorts") {
                if (typeof combinedData[sourceType] === 'object') {
                    youtubeChatters += parseInt(combinedData[sourceType].chatters) || 0;
                    youtubeViewers += parseInt(combinedData[sourceType].viewers) || 0;
                    hasYouTube = true;
                }
            } else if (typeof combinedData[sourceType] === 'object') {
                newCombinedData[sourceType] = combinedData[sourceType];
            }
        }
        
        if (hasYouTube) {
            newCombinedData["youtube"] = {
                chatters: youtubeChatters,
                viewers: youtubeViewers
            };
            
            // Clean up tracking for youtubeshorts since it's now combined
            delete lastUpdated["youtubeshorts"];
            delete hasViewerCount["youtubeshorts"];
            delete activeChatters["youtubeshorts"];
        }
        
        combinedData = newCombinedData;
    }
    
    // Normalize keys by collapsing variants like "kick-123" ‚Üí "kick"
    // Sum viewer counts for the same base type and keep the max of chatters to avoid double counting
    if (combinedData && typeof combinedData === 'object') {
        const normalizedCombined = {};
        for (const key of Object.keys(combinedData)) {
            const entry = combinedData[key];
            if (!entry || typeof entry !== 'object') continue;
            const base = getSourceImage(key);
            if (!normalizedCombined[base]) {
                normalizedCombined[base] = { chatters: 0, viewers: 0 };
            }
            const v = parseInt(entry.viewers);
            const c = parseInt(entry.chatters);
            if (!isNaN(v)) normalizedCombined[base].viewers += v;
            if (!isNaN(c)) normalizedCombined[base].chatters = Math.max(normalizedCombined[base].chatters, c);
        }
        combinedData = normalizedCombined;
    }
    
    const sourceKeys = Object.keys(combinedData);
	sourceKeys.sort();
    let hasContentToDisplay = false;
    const now = Date.now();
    // Track which sources are present this tick for cleanup/reordering (normalized)
    const presentTypes = new Set(sourceKeys.map(getSourceImage));

    for (let i = 0; i < sourceKeys.length; i++) {
        const sourceType = sourceKeys[i];
        if (sourceType === "uniqueId" || typeof combinedData[sourceType] !== 'object') {
            continue;
        }
        const sourceData = combinedData[sourceType];
        const chatterCount = (sourceData && sourceData.chatters !== undefined) ? parseInt(sourceData.chatters) : 0;
        const viewerCount = (sourceData && sourceData.viewers !== undefined) ? parseInt(sourceData.viewers) : 0;
        // Update tracking for this source
        if (viewerCount > 0 || chatterCount > 0) {
            lastUpdated[sourceType] = now;
        }
        if (viewerCount > 0) {
            hasViewerCount[sourceType] = true;
        }
        if (chatterCount > 0) {
            activeChatters[sourceType] = true;
        }
        
        // Always display sources that are sent from background.js
        // (background.js handles cleanup of stale sources)
        if (showChatters || showViewers) {
            hasContentToDisplay = true;
            const sourceImgName = getSourceImage(sourceType);
            const sourceImgSrc = "./sources/images/" + sourceImgName + ".png";

            // Work with normalized data-type to avoid duplicates like kick-123 vs kick-456
            const normalizedType = sourceImgName;
            // Upsert holder for this source without replacing the image element
            let holder = hypeContainer.querySelector(".sourceStatHolder[data-type='" + normalizedType + "']");
            if (!holder) {
                holder = document.createElement("div");
                holder.className = "sourceStatHolder";
                holder.dataset.type = normalizedType;

                const img = document.createElement("img");
                img.className = "sourceicons";
                img.src = sourceImgSrc;
                img.decoding = "async";
                img.loading = "eager";
                holder.appendChild(img);

                if (showViewers) {
                    const v = document.createElement("span");
                    v.dataset.viewers = "true";
                    v.dataset.type = normalizedType;
                    holder.appendChild(v);
                }
                if (showChatters) {
                    const c = document.createElement("span");
                    c.dataset.chatters = "true";
                    c.dataset.type = normalizedType;
                    holder.appendChild(c);
                }
            } else {
                // Ensure the expected spans exist if toggles changed since creation
                if (showViewers && !holder.querySelector("span[data-viewers][data-type='" + normalizedType + "']")) {
                    const v = document.createElement("span");
                    v.dataset.viewers = "true";
                    v.dataset.type = normalizedType;
                    holder.appendChild(v);
                }
                if (showChatters && !holder.querySelector("span[data-chatters][data-type='" + normalizedType + "']")) {
                    const c = document.createElement("span");
                    c.dataset.chatters = "true";
                    c.dataset.type = normalizedType;
                    holder.appendChild(c);
                }
            }

            // Update text values (including zero)
            if (showViewers) {
                const v = holder.querySelector("span[data-viewers][data-type='" + normalizedType + "']");
                if (v) v.textContent = isNaN(viewerCount) ? "0" : String(viewerCount);
            }
            if (showChatters) {
                const c = holder.querySelector("span[data-chatters][data-type='" + normalizedType + "']");
                if (c) c.textContent = isNaN(chatterCount) ? "0" : String(chatterCount);
            }

            // Maintain stable ordering without re-creating nodes
            hypeContainer.appendChild(holder);
        }
    }
    // Also reflect any aggregated viewer updates (ensures 0s still display like dock.html)
    if (showViewers && aggregatedViewers && typeof aggregatedViewers === 'object') {
        const aggKeys = Object.keys(aggregatedViewers);
        aggKeys.sort();
        for (let i = 0; i < aggKeys.length; i++) {
            const type = aggKeys[i];
            // Skip if normalized base already represented by any existing holder (eg: kick-123 present)
            if (presentTypes.has(type)) continue; // already handled via combinedData
            if (hypeContainer.querySelector(".sourceStatHolder[data-type='" + type + "'], .sourceStatHolder[data-type^='" + type + "-']")) {
                continue;
            }

            hasContentToDisplay = true;
            const sourceImgName = getSourceImage(type);
            const sourceImgSrc = "./sources/images/" + sourceImgName + ".png";

            let holder = hypeContainer.querySelector(".sourceStatHolder[data-type='" + type + "']");
            if (!holder) {
                holder = document.createElement("div");
                holder.className = "sourceStatHolder";
                holder.dataset.type = type;

                const img = document.createElement("img");
                img.className = "sourceicons";
                img.src = sourceImgSrc;
                img.decoding = "async";
                img.loading = "eager";
                holder.appendChild(img);

                if (showViewers) {
                    const v = document.createElement("span");
                    v.dataset.viewers = "true";
                    v.dataset.type = type;
                    holder.appendChild(v);
                }
                if (showChatters) {
                    const c = document.createElement("span");
                    c.dataset.chatters = "true";
                    c.dataset.type = type;
                    holder.appendChild(c);
                }
            }

            // Update values (chatters unknown here; default 0 if present)
            const v = holder.querySelector("span[data-viewers][data-type='" + type + "']");
            if (v) v.textContent = String(aggregatedViewers[type] || 0);
            const c = holder.querySelector("span[data-chatters][data-type='" + type + "']");
            if (c && !c.textContent) c.textContent = "0";

            hypeContainer.appendChild(holder);
            presentTypes.add(type);
        }
    }
    // Optional cleanup: remove holders for sources not in the current payload
    hypeContainer.querySelectorAll('.sourceStatHolder').forEach(function(node){
        const t = node.dataset.type;
        if (!presentTypes.has(t)) {
            node.remove();
        }
    });
    if (hasContentToDisplay) {
        parentHolder.classList.remove("hidden");
    } else {
        parentHolder.classList.add("hidden");
    }
}

function fadeOutNode(node) {
    if (node.timer) {
        return;
    }
    node.style.animation += ", fadeOut 1s normal forwards ease";
    node.timer = setTimeout(function(node) {
        node.remove();
    }, 1000, node);
}
iframe = document.createElement("iframe");
iframe.src = "https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password=" + password + "&solo&view=" + roomID + "&novideo&noaudio&label=hype&cleanoutput&room=" + roomID;
iframe.style.width = "0px";
iframe.style.height = "0px";
iframe.style.position = "fixed";
iframe.style.left = "-100px";
iframe.style.top = "-100px";
iframe.id = "frame1"
document.body.appendChild(iframe);
var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
var eventer = window[eventMethod];
var messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";
eventer(messageEvent, function(e) {
    if (e.source != iframe.contentWindow) {
        return;
    }
    if ("dataReceived" in e.data) {
        if ("overlayNinja" in e.data.dataReceived) {
            var data = e.data.dataReceived.overlayNinja;
            
            // Handle new viewer_updates format by caching aggregated counts (incl. zeros)
            if (data.event === "viewer_updates" && data.meta && typeof data.meta === "object") {
                const meta = data.meta || {};
                const now = Date.now();

                // Build aggregated viewers map honoring combine flags
                let nextAgg = {};
                if (combineAll) {
                    let total = 0;
                    Object.keys(meta).forEach(k => { total += parseInt(meta[k]) || 0; });
                    nextAgg = { global: total };
                } else if (combineYouTube) {
                    let yt = 0;
                    Object.keys(meta).forEach(k => {
                        const val = parseInt(meta[k]) || 0;
                        if (k === 'youtube' || k === 'youtubeshorts') {
                            yt += val;
                        } else {
                            nextAgg[k] = val;
                        }
                    });
                    nextAgg.youtube = yt;
                } else {
                    Object.keys(meta).forEach(k => { nextAgg[k] = parseInt(meta[k]) || 0; });
                }
                aggregatedViewers = nextAgg;

                // Update tracking info (kept for potential staleness logic)
                Object.keys(aggregatedViewers).forEach(function(platform) {
                    if (aggregatedViewers[platform] >= 0) {
                        lastUpdated[platform] = now;
                        hasViewerCount[platform] = aggregatedViewers[platform] > 0;
                    }
                });

                // Do not short-circuit; allow subsequent hype updates to render.
                return;
            }
            
            // Process regular hype data
            processInput(data);
        }
    }
});
if (urlParams.has('js')) {
    console.warn("Third-party Javascript has been injected into the code. Security cannot be ensured.");
    var jsURL = urlParams.get('js');
    jsURL = decodeURI(jsURL);
    console.log(jsURL);
    var externalJavaascript = document.createElement('script');
    externalJavaascript.type = 'text/javascript';
    externalJavaascript.crossorigin = 'anonymous';
    externalJavaascript.src = jsURL;
    externalJavaascript.onerror = function() {
        console.warn("Third-party Javascript failed to load");
    };
    externalJavaascript.onload = function() {
        console.log("Third-party Javascript loaded");
    };
    document.head.appendChild(externalJavaascript);
}
	</script>
	</body>
</html>
