<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moderator Dashboard</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap">
<style>
@import url('https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap');

:root {
    --bg-color: #1a2a3d;
    --text-color: #e4e6eb;
    --card-bg: linear-gradient(145deg, #1a2a48, #162238);
    --card-shadow: rgba(0, 0, 0, 0.3);
}

body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100vh;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
}

#chat-container {
    padding: 15px;
    height: calc(100vh - 70px);
    overflow-y: auto;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}

#chat-container::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}

.message {
    background: var(--card-bg);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 8px;
    border-left: 5px solid;
    box-shadow: 0 4px 8px var(--card-shadow);
    color: var(--text-color);
    opacity: 0;
    transform: translateY(-20px);
    animation: slideFadeIn 0.5s ease forwards;
    position: relative;
}

.youtube-event {
    border-left-color: #ff0000;
}

.twitch-event {
    border-left-color: #9146ff;
}

.high-value {
    border: 2px solid gold;
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
}

.medium-value {
    border: 1px solid silver;
}

@keyframes slideFadeIn {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.name {
    color: white;
    font-size: 1.1em;
    font-weight: 700;
    display: inline-block;
}

.text {
    font-size: 0.95em;
    line-height: 1.4;
    margin: 8px 0;
}

.text img {
    max-width: 80px;
    max-height: 20px;
    vertical-align: bottom;
}

.event-type {
    font-weight: 700;
    display: inline-block;
    padding: 3px 8px;
    border-radius: 4px;
    margin-right: 10px;
    font-size: 0.8em;
    text-transform: uppercase;
}

.event-donation {
    background-color: #4cd137;
    color: #fff;
}

.event-other {
    background-color: #3498db;
    color: #fff;
}

.donation {
    color: #4cd137;
    font-weight: 600;
    font-size: 1.2em;
    margin: 5px 0;
}

.usd-value {
    position: absolute;
    right: 15px;
    top: 15px;
    background-color: rgba(0, 0, 0, 0.6);
    color: gold;
    padding: 3px 8px;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.9em;
}

.timestamp {
    font-size: 0.75em;
    color: #aaa;
    margin-top: 5px;
}

.source-icon {
    width: 20px;
    height: 20px;
    vertical-align: middle;
    margin-left: 5px;
}

.badge {
    display: inline-block;
    height: 1em;
    margin-left: 5px;
    vertical-align: middle;
}

.no-events {
    text-align: center;
    color: #aaa;
    margin-top: 40px;
    font-style: italic;
}

#header {
    background-color: #0f1824;
    color: white;
    padding: 10px 15px;
    text-align: center;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

#header h1 {
    margin: 0;
    font-size: 1.4em;
}

.message-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.message-meta {
    display: flex;
    align-items: center;
}

.event-specific {
    display: inline-block;
    padding: 2px 6px;
    margin-left: 5px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    font-size: 0.75em;
    color: #ddd;
}

/* Custom classes for different platforms */
/* Custom classes for different platforms */
.youtube-event { border-left-color: #ff0000; }
.twitch-event { border-left-color: #9146ff; }
.kick-event { border-left-color: #53fc18; }
.tiktok-event { border-left-color: #ff0050; }
.facebook-event { border-left-color: #1877f2; }
.x-event { border-left-color: #1DA1F2; }
.rumble-event { border-left-color: #85c742; }
.slack-event { border-left-color: #4A154B; }
.discord-event { border-left-color: #5865F2; }
.instagram-event { border-left-color: #E1306C; }
.linkedin-event { border-left-color: #0077B5; }
.telegram-event { border-left-color: #0088cc; }
.telegramk-event { border-left-color: #0088cc; }
.whatsapp-event { border-left-color: #25D366; }
.zoom-event { border-left-color: #2D8CFF; }
.teams-event { border-left-color: #6264A7; }
.webex-event { border-left-color: #00bceb; }
.amazon-event { border-left-color: #FF9900; }
.bilibili-event { border-left-color: #00A1D6; }
.bilibilicom-event { border-left-color: #00A1D6; }
.odysee-event { border-left-color: #FF5500; }
.trovo-event { border-left-color: #1EFF00; }
.dlive-event { border-left-color: #FEA621; }
.vimeo-event { border-left-color: #1AB7EA; }
.meetme-event { border-left-color: #FF5D63; }
.chime-event { border-left-color: #232F3E; }
.bigo-event { border-left-color: #18BFFF; }
.chaturbate-event { border-left-color: #F47321; }
.fansly-event { border-left-color: #0091EA; }
.cherrytv-event { border-left-color: #FF0062; }
.cozy-event { border-left-color: #1DA1F2; }
.reddit-event { border-left-color: #FF4500; }
.openai-event { border-left-color: #10A37F; }
.claude-event { border-left-color: #4B144B; }
.threads-event { border-left-color: #000000; }
.vklive-event { border-left-color: #4C75A3; }
.vkvideo-event { border-left-color: #4C75A3; }


/* Light mode styling */
body.light-mode {
    background-color: #f5f5f5;
    color: #333;
}

body.light-mode #header {
    background-color: #e0e0e0;
    color: #333;
}

body.light-mode .message {
    background: linear-gradient(145deg, #f5f5f5, #e0e0e0);
    color: #333;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

body.light-mode .name {
    color: #333; /* Fix for white text on white background */
}

body.light-mode .timestamp {
    color: #777;
}

body.light-mode .event-type {
    color: #fff;
}

body.light-mode .no-events {
    color: #777;
}
.clickable-message {
    cursor: pointer;
    transition: background-color 0.2s ease-in-out;
}

.clickable-message:hover {
    background-color: rgba(255, 255, 255, 0.07); /* Adjust for light/dark mode if needed */
	position: relative;
    top: 2px;
}
.clickable-message:active {
    top: 3px;
}


body.light-mode .clickable-message:hover {
    background-color: rgba(0, 0, 0, 0.07);
}

/* Selected and active states */
.message.selected {
    border: 2px solid #4CAF50;
    box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
}

.message.active {
    background: linear-gradient(145deg, #2a3a58, #223248) !important;
    box-shadow: 0 6px 12px rgba(76, 175, 80, 0.5), inset 0 0 15px rgba(76, 175, 80, 0.2);
}

body.light-mode .message.active {
    background: linear-gradient(145deg, #e8f5e9, #d0e8d1) !important;
    box-shadow: 0 6px 12px rgba(76, 175, 80, 0.3), inset 0 0 15px rgba(76, 175, 80, 0.1);
}

.message.active::before {
    content: "FEATURED";
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: #4CAF50;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.7em;
    font-weight: bold;
    text-transform: uppercase;
}
</style>
</head>
<body>
<div id="header">
    <h1>Stream Events & Donations Dashboard</h1>
</div>
<div id="chat-container">
    <div class="no-events">Waiting for stream events and donations...</div>
</div>
<script type="text/javascript" src="currency.js"></script>
<script>
    var urlParams = new URLSearchParams(window.location.search);
    var roomID = false;
    
    if (urlParams.has("session")){
        roomID = urlParams.get("session");
    }
	
    var password = "false";
    var featuredMode = false;
    
    const chatContainer = document.getElementById('chat-container');
    let noEventsMessage = document.querySelector('.no-events');
	
	var sources = false; // Default sources
	if (urlParams.get("sources")) {
		sources = urlParams.get("sources").split(',').map(s => s.trim().toLowerCase());
	}

	// Add parameters for display options
	var donationsOnly = urlParams.has("donationsonly");
	var minValue = urlParams.has("minvalue") ? (parseInt(urlParams.get("minvalue"))||5) : 0;
	var giftSubsOnly = urlParams.has("giftedsubsonly");
	var showUSD = urlParams.has("currency") ? true : false;
	var highlightValue = urlParams.has("highlightvalue") ? true : false;
	var lightMode = urlParams.has("lightmode");
	var maxEvents = urlParams.has("maxevents") ? parseInt(urlParams.get("maxevents")) : 200;
	var fontFamily = urlParams.has("font") ? urlParams.get("font") : "Roboto";
	var googleFont = urlParams.has("googlefont") ? urlParams.get("googlefont") : "";

	// Apply theme immediately
	if (lightMode) {
		document.body.classList.add("light-mode");
		document.documentElement.style.setProperty('--bg-color', '#f5f5f5');
		document.documentElement.style.setProperty('--text-color', '#333');
		document.documentElement.style.setProperty('--card-bg', '#fff');
		document.documentElement.style.setProperty('--card-shadow', 'rgba(0, 0, 0, 0.1)');
	}

	// Apply custom font if specified
	if (googleFont) {
		const fontLink = document.createElement("link");
		fontLink.rel = "stylesheet";
		fontLink.href = `https://fonts.googleapis.com/css?family=${encodeURIComponent(googleFont)}&display=swap`;
		document.head.appendChild(fontLink);
		document.body.style.fontFamily = `'${googleFont}', sans-serif`;
	} else if (fontFamily && fontFamily !== "Roboto") {
		document.body.style.fontFamily = fontFamily;
	}
    
    const FRIENDLY_EVENT_LABELS = {
		new_follower: 'New Follower',
		new_subscriber: 'New Subscriber',
		resub: 'Resub',
		subscription_gift: 'Gifted Subs',
		gift: 'Gift',
		giftpurchase: 'Gift Purchase',
		giftredemption: 'Gift Redemption',
		sponsorship: 'Membership',
		membermilestone: 'Member Milestone',
		member_milestone: 'Member Milestone',
		channel_points: 'Channel Points',
		cheer: 'Cheer',
		donation: 'Donation',
		supersticker: 'Super Sticker',
		thankyou: 'Thank You'
	};

	const STATUS_EVENT_TYPES = new Set(['viewer_update', 'follower_update', 'subscriber_update', 'view_update', 'likes_update']);
	const STREAM_EVENT_TYPES = new Set(['stream_online', 'stream_offline']);
	const AD_EVENT_TYPES = new Set(['ad_break', 'ad_request', 'ad_schedule']);
	const GIFT_EVENT_TYPES = new Set([
		'gift',
		'giftpurchase',
		'giftredemption',
		'subscription_gift',
		'sponsorship',
		'gift_membership',
		'giftmemberships',
		'gifted_membership',
		'gifted_memberships',
		'membership_gift'
	]);

	function normalizeEventKey(event) {
		if (typeof event !== 'string') return '';
		const normalized = event
			.toLowerCase()
			.replace(/[^a-z0-9]+/g, '_')
			.replace(/__+/g, '_')
			.replace(/^_+|_+$/g, '');
		const aliasMap = {
			channel_subscription_gifts: 'subscription_gift',
			channel_subscription_gift: 'subscription_gift',
			channel_subscription_new: 'new_subscriber',
			channel_subscription_start: 'new_subscriber',
			channel_subscription_renewal: 'resub',
			channel_subscription_extend: 'resub',
			channel_subscription: 'new_subscriber',
			channel_followed: 'new_follower',
			follower_added: 'new_follower',
			subscription_renewal: 'resub',
			subscription_gifts: 'subscription_gift'
		};
		return aliasMap[normalized] || normalized;
	}

	function humanizeEventKey(event) {
		return event.replace(/[_-]+/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
	}

	function capitalizeSource(value) {
		if (!value || typeof value !== 'string') return 'System';
		return value.charAt(0).toUpperCase() + value.slice(1);
	}

	function extractNumeric(value) {
		if (value === undefined || value === null) return null;
		if (typeof value === 'number') {
			return Number.isFinite(value) ? value : null;
		}
		if (typeof value === 'string') {
			const cleaned = value.replace(/[^0-9.-]/g, '');
			if (!cleaned) return null;
			const parsed = parseFloat(cleaned);
			return Number.isFinite(parsed) ? parsed : null;
		}
		return null;
	}

	function formatMetricValue(data, fallback = 0) {
		const candidates = [];

		if (data.meta !== undefined) {
			const meta = data.meta;
			if (typeof meta === 'object' && meta !== null) {
				candidates.push(meta.current, meta.count, meta.total, meta.viewers, meta.viewer_count, meta.value, meta.amount);
			} else {
				candidates.push(meta);
			}
		}

		candidates.push(data.count, data.total, data.value);
		candidates.push(fallback);

		for (const candidate of candidates) {
			const numeric = extractNumeric(candidate);
			if (numeric !== null) {
				return numeric.toLocaleString();
			}
		}

		return Number(fallback || 0).toLocaleString();
	}

	function buildEventDisplay(data) {
		const normalizedEvent = normalizeEventKey(data.event);
		let name = data.chatname || data.sourceName || `${capitalizeSource(data.type)} Alerts`;
		let message = data.chatmessage || '';
		let eventTypeText = '';
		let eventTypeClass = data.hasDonation ? 'event-donation' : 'event-other';
		let eventSpecificText = '';
		let forceShow = false;

		if (data.hasDonation) {
			eventTypeText = 'DONATION';
		} else if (normalizedEvent) {
			eventTypeText = 'EVENT';
		}

		if (normalizedEvent) {
			eventSpecificText = FRIENDLY_EVENT_LABELS[normalizedEvent] || humanizeEventKey(normalizedEvent);
		}

		if (STATUS_EVENT_TYPES.has(normalizedEvent)) {
			eventTypeText = 'STATUS';
			eventSpecificText = {
				viewer_update: 'Viewers',
				follower_update: 'Followers',
				subscriber_update: 'Subscribers',
				view_update: 'Views',
				likes_update: 'Likes'
			}[normalizedEvent] || eventSpecificText;
			message = `Current ${eventSpecificText.toLowerCase()}: ${formatMetricValue(data, 0)}`;
			name = data.sourceName || `${capitalizeSource(data.type)} Stats`;
			forceShow = true;
		} else if (STREAM_EVENT_TYPES.has(normalizedEvent)) {
			eventTypeText = 'STREAM';
			if (normalizedEvent === 'stream_online') {
				eventSpecificText = 'Online';
				const startedAt = data.meta && (data.meta.startedAt || data.meta.started_at);
				if (startedAt) {
					const startDate = new Date(startedAt);
					message = isNaN(startDate.getTime()) ? 'Stream is now live!' : `Stream is live (since ${startDate.toLocaleTimeString()})`;
				} else {
					message = 'Stream is now live!';
				}
			} else {
				eventSpecificText = 'Offline';
				message = 'Stream has ended.';
			}
			name = data.sourceName || `${capitalizeSource(data.type)} Status`;
			forceShow = true;
		} else if (AD_EVENT_TYPES.has(normalizedEvent)) {
			eventTypeText = 'ADVERTISEMENT';
			if (normalizedEvent === 'ad_break') {
				eventSpecificText = 'Ad Break';
				if (!message) {
					const duration = data.meta && (data.meta.duration || data.meta.length || data.meta.duration_seconds);
					message = `Ad break started${duration ? ` (${duration}s)` : ''}`;
				}
			} else if (normalizedEvent === 'ad_request') {
				eventSpecificText = 'Ad Request';
				if (!message) {
					const length = data.meta && (data.meta.length || data.meta.duration);
					message = `Ad request queued${length ? ` (${length}s)` : ''}`;
				}
			} else {
				eventSpecificText = 'Ad Schedule';
				if (!message) {
					message = 'Ad schedule updated.';
				}
			}
			name = data.meta && data.meta.requester ? data.meta.requester : (data.sourceName || `${capitalizeSource(data.type)} Ads`);
			forceShow = true;
		}

		if (!eventSpecificText && normalizedEvent) {
			eventSpecificText = humanizeEventKey(normalizedEvent);
		}

		return {
			name,
			message,
			eventTypeText,
			eventTypeClass,
			eventSpecificText,
			normalizedEvent,
			forceShow
		};
	}

    function addMessageToOverlay(data) {
		// Only display events from enabled sources
		
		if (data.meta){
			console.log(data);
		}
		
		if (sources && !sources.includes(data.type)) {
			return;
		}
		
		// If donations-only mode is enabled, only show donations
		if (donationsOnly && !data.hasDonation) {
			return;
		}
		
		const display = buildEventDisplay(data);

		if (!(data.event || data.hasDonation) && !display.forceShow) {
			return;
		}

		const hasDisplayContent = (display.message && display.message.trim().length > 0) || data.hasDonation || display.forceShow;
		if (!hasDisplayContent) {
			return;
		}

		if (giftSubsOnly) {
			const isGiftEvent = display.normalizedEvent && GIFT_EVENT_TYPES.has(display.normalizedEvent);
			const messageText = (display.message || data.chatmessage || '').toLowerCase();
			if (!isGiftEvent && !messageText.includes('gift')) {
				return;
			}
		}
		
		// Remove the "no events" message if it exists
		if (noEventsMessage) {
			noEventsMessage.remove();
			noEventsMessage = null;
		}
		
		const messageDiv = document.createElement('div');
		messageDiv.classList.add('message');
		const eventClass = data.type ? `${data.type}-event` : 'system-event';
		messageDiv.classList.add(eventClass);
		
        messageDiv.rawContents = data; // Store the original data object
        messageDiv.classList.add('clickable-message');
		
		if (data.mid) {
			messageDiv.id = data.mid;
		}
		
		if (data.type) {
			data.sourceicon = "https://socialstream.ninja/sources/images/"+data.type+".png";
		} else {
			data.sourceicon = "";
		}
		
		// Get current time for timestamp
		const now = new Date();
		const timeString = now.toLocaleTimeString();
		
		const eventTypeText = display.eventTypeText;
		const eventTypeClass = display.eventTypeClass || (data.hasDonation ? 'event-donation' : 'event-other');
		const eventSpecificText = display.eventSpecificText;
		const displayName = display.name || data.chatname || 'Anonymous';
		
		// Calculate USD value if donation
		let usdValue = 0;
		if (data.hasDonation) {
			try {
				usdValue = convertToUSD(data.hasDonation, data.type);
				
				// Add value-based class if highlighting is enabled
				if (highlightValue) {
					if (usdValue >= 50) {
						messageDiv.classList.add('high-value');
					} else if (usdValue >= 10) {
						messageDiv.classList.add('medium-value');
					}
				}
				
				if (minValue && (usdValue < minValue)){
					return;
				}
				if (!showUSD){
					usdValue = 0;
				}
			} catch(e){console.error(e);}
		}
		
		messageDiv.innerHTML = `
			<div class="message-header">
				<div class="message-meta">
					${eventTypeText ? `<div class="event-type ${eventTypeClass}">${eventTypeText}</div>` : ''}
					${eventSpecificText ? `<div class="event-specific">${eventSpecificText}</div>` : ''}
					<div class="name" ${data.nameColor ? `style="text-shadow: 0 0 3px ${data.nameColor}"` : ''}>${displayName}</div>
					${data.sourceicon ? `<img src="${data.sourceicon}" alt="${data.type}" class="source-icon">` : ''}
				</div>
			</div>
			
			<div class="text">${display.message || ''}</div>
			${data.hasDonation ? `<div class="donation">💰 ${data.hasDonation}</div>` : ''}
			${usdValue > 0 ? `<div class="usd-value">$${usdValue.toFixed(2)} USD</div>` : ''}
			<div class="timestamp">${timeString}</div>
		`;
		
		chatContainer.prepend(messageDiv);
		
		// Auto-scroll to the latest message
		chatContainer.scrollTop = 0;
		
		// Keep max N events in the dashboard (from URL param or default 200)
		while (chatContainer.children.length > maxEvents) {
			chatContainer.removeChild(chatContainer.lastChild);
		}
	}
	
	let currentActiveMessage = null; // Track the currently active message
	
	chatContainer.addEventListener('click', function(event) {
        const messageDiv = event.target.closest('.message.clickable-message');
        if (!messageDiv || !messageDiv.rawContents) return;
		
		// If clicking the currently active message, toggle it off
		if (messageDiv === currentActiveMessage) {
			messageDiv.classList.remove('active');
			currentActiveMessage = null;
			// Send false to clear the featured message
			featureEventMessage(false);
		} else {
			// Remove active from previous message (if any)
			if (currentActiveMessage) {
				currentActiveMessage.classList.remove('active');
			}
			
			// Mark this message as selected and active
			messageDiv.classList.add('selected');
			messageDiv.classList.add('active');
			currentActiveMessage = messageDiv;
			
			// Send the message data
			featureEventMessage(messageDiv.rawContents);
		}
    });

    function featureEventMessage(dataToFeature) {
        // Handle clearing the featured message
        if (dataToFeature === false) {
            const payload = { overlayNinja: false };
            
            if (iframe && iframe.contentWindow && iframe.connectedPeers) {
                let sentViaIframe = false;
                const keys = Object.keys(iframe.connectedPeers);
                for (let i = 0; i < keys.length; i++) {
                    const uuid = keys[i];
                    const label = iframe.connectedPeers[uuid];
                    if (label === "overlay" || label === false || typeof label === 'undefined') {
                        try {
                            iframe.contentWindow.postMessage({ sendData: payload, type: "pcs", UUID: uuid }, "*");
                            sentViaIframe = true;
                        } catch (e) {
                            console.error("Error sending clear message via iframe to peer:", uuid, e);
                        }
                    }
                }
                if (!sentViaIframe) {
                    sendViaWebSocketFallback(false);
                }
            } else {
                sendViaWebSocketFallback(false);
            }
            return;
        }
        
        const messageToSend = { ...dataToFeature, clicked: true, timestamp: Date.now() };
        if (messageToSend.id) {
             delete messageToSend.id;
        }

        const payload = { overlayNinja: messageToSend };

        if (iframe && iframe.contentWindow && iframe.connectedPeers) {
            let sentViaIframe = false;
            const keys = Object.keys(iframe.connectedPeers);
            for (let i = 0; i < keys.length; i++) {
                const uuid = keys[i];
                const label = iframe.connectedPeers[uuid];
                // Send to "overlay" (like featured.html) or generic peers (label: false or undefined)
                // These are typical labels for non-dock, viewing peers.
                if (label === "overlay" || label === false || typeof label === 'undefined') {
                    try {
                        iframe.contentWindow.postMessage({ sendData: payload, type: "pcs", UUID: uuid }, "*");
                        sentViaIframe = true;
                    } catch (e) {
                        console.error("Error sending message via iframe to peer:", uuid, e);
                    }
                }
            }
            if (sentViaIframe) {
                 console.log("Featured message sent via iframe.");
            } else {
                console.warn('No suitable "overlay" peer found to send featured message to via iframe. Attempting WebSocket.');
                // Fallback to WebSocket if no iframe peer was found or if sending failed
                sendViaWebSocketFallback(messageToSend);
            }
        } else {
            console.warn('iframe or connectedPeers not ready. Attempting WebSocket to feature message.');
            sendViaWebSocketFallback(messageToSend);
        }
    }

    function sendViaWebSocketFallback(messageToSend) {
        if (socketserver && socketserver.readyState === WebSocket.OPEN) {
            if (messageToSend === false) {
                socketserver.send(JSON.stringify({ overlayNinja: false }));
                console.log("Clear message sent via WebSocket as fallback.");
            } else {
                socketserver.send(JSON.stringify({ content: messageToSend }));
                console.log("Featured message sent via WebSocket as fallback.");
            }
        } else {
            console.error('Neither iframe nor WebSocket available to send message.');
        }
    }

    var iframe = document.createElement("iframe"); // Keep iframe global
	if (roomID){
		if (featuredMode){ // featuredMode is false by default in events.html
			iframe.src = `https://vdo.socialstream.ninja/?ln&password=${password}&salt=vdo.ninja&label=overlay&exclude=${roomID}&scene&novideo&noaudio&cleanoutput&room=${roomID}`;
		} else { // This is the path typically taken by events.html
			iframe.src = "https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password="+password+"&push&label=dock&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput&room="+roomID; 
		}
		iframe.style.cssText = "width: 0px; height: 0px; position: fixed; left: -100px; top: -100px;";
	
        iframe.connectedPeers = {}; // Initialize connectedPeers for this iframe instance

		document.body.appendChild(iframe);

		window.addEventListener("message", function (e) {
			if (e.source != iframe.contentWindow) return;
			
            // Logic to populate iframe.connectedPeers, similar to dock.html
            if ("action" in e.data && e.data.UUID && "value" in e.data) {
                const peerUUID = e.data.UUID;
                const peerValue = e.data.value;

                if (e.data.action === "push-connection-info" || e.data.action === "view-connection-info") {
                    if (peerValue && "label" in peerValue) {
                        iframe.connectedPeers[peerUUID] = peerValue.label;
                         console.log("Peer connected/info: ", peerUUID, peerValue.label);
                    } else if (peerValue === false) { 
                         delete iframe.connectedPeers[peerUUID];
                         console.log("Peer disconnected (info explicit false): ", peerUUID);
                    }
                } else if (e.data.action === "push-connection" || e.data.action === "view-connection") {
                    if (peerValue === false) { // Peer disconnected
                        delete iframe.connectedPeers[peerUUID];
                        console.log("Peer disconnected: ", peerUUID);
                    } else if (typeof peerValue === 'object' && peerValue && "label" in peerValue) {
                        // This handles cases where a new connection directly sends its info
                        iframe.connectedPeers[peerUUID] = peerValue.label;
                        console.log("Peer connected (direct info): ", peerUUID, peerValue.label);
                    }
                }
            }

			if (e.data.dataReceived && e.data.dataReceived.overlayNinja) {
				addMessageToOverlay(e.data.dataReceived.overlayNinja);
			}
		});
	}
    
    var conCon = 1;
    var socketserver = false;
    var serverURL = urlParams.has("localserver") ? "ws://127.0.0.1:3000" : "wss://io.socialstream.ninja";
    var reconnectionTimeout = null;


    function setupSocket(){
        if (reconnectionTimeout) {
            clearTimeout(reconnectionTimeout);
            reconnectionTimeout = null;
        }
        if (socketserver) {
            socketserver.onclose = null;
            socketserver.close();
            socketserver = null;
        }
        socketserver = new WebSocket(serverURL);

        socketserver.onclose = function (){
            reconnectionTimeout = setTimeout(function(){
                conCon+=1;
                setupSocket();
            },100*conCon);
        };
        socketserver.onerror = function(error) {
            console.error("WebSocket error:", error);
            if (socketserver) socketserver.close(); // Ensure it's closed on error
        };
        socketserver.onopen = function (){
            conCon = 1;
            socketserver.send(JSON.stringify({"join":roomID, "out":3, "in":4})); // Standard channel for events/dashboard
        };
        socketserver.addEventListener('message', function (event) {
            var resp = false
            if (event.data){
                try {
                    var data = JSON.parse(event.data);
                    if (data && data.overlayNinja) { // Check if data is wrapped
                        addMessageToOverlay(data.overlayNinja);
                    } else {
                        addMessageToOverlay(data); // Assume data is the direct payload
                    }

                    if (data.get){ // Handle callbacks if any
                        var ret = {};
                        ret.callback = {};
                        ret.callback.get = data.get
                        ret.callback.result = true;
                        socketserver.send(JSON.stringify(ret));
                    }
                } catch (parseError) {
                    console.error("Error parsing WebSocket message:", parseError, event.data);
                }
            }
        });
    }
    
    if (urlParams.has("server") || urlParams.has("server2")){
        serverURL = urlParams.get("server") ||  urlParams.get("server2") || serverURL;
		if (roomID){
			setupSocket();
		}
    }
</script>
</body>
</html>
