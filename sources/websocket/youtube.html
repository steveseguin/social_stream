<!DOCTYPE html>
<html lang="en" style="font-size: 10px; font-family: Roboto, Arial, sans-serif">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <title>Social Stream - YouTube</title>
    <link rel="icon" href="https://www.youtube.com/favicon.ico" type="image/x-icon">
    <style>
        .hidden { display: none!important; }
		html {
			height: 100%;
		}
		body {
			background-color: #ddd;
			font-size: 14px;
			margin: 0;
			padding: 0;
			height: 100vh;
			overflow: hidden;
		}
        .auth-button, .sign-out-button, .connect-button {
            background-color: #FF0000;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .auth-button:hover, .connect-button:hover {
            background-color: #D30000;
        }
        .sign-out-button {
            background-color: #f44336;
        }
        .sign-out-button:hover {
            background-color: #d32f2f;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
        }
        
        /* When logged in, switch to two-column layout */
        body:has(.socket:not(.hidden)) .container {
            grid-template-columns: 1fr 300px;
        }
		.socket > div {
			margin: 5px;
		}
		.main-content {
			display: flex;
			flex-direction: column;
			gap: 15px;
			height: 100%;
			overflow-y: auto;
		}
        .chat-badge {
            margin-right: 2px;
            vertical-align: middle;
            height: 18px;
            width: auto;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .text-center { text-align: center; }
        
        /* Header styles */
        .channel-header {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .header-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
        }
        .header-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .header-item span:first-child {
            font-weight: bold;
            color: #FF0000;
        }
        
        /* Channel input */
        .channel-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .channel-input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 150px;
        }
        
        /* Stats grid */
        .stats-container {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .stats-container h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #FF0000;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
		.container {
			max-width: 1200px;
			margin: 0 auto;
			display: grid;
			grid-template-columns: 1fr;
			height: calc(100vh);
		}
		.chat-container h3 {
			margin: 0 0 10px 0;
			font-size: 16px;
		}
		#textarea {
			flex-grow: 1;
			min-height: 100px;
			height: calc(100% - 80px);
			overflow-y: auto;
			margin-bottom: 10px;
		}
        .chat-input {
            display: flex;
            gap: 8px;
        }
        .chat-input input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* Sidebar components */
        .permissions-container,
        .recent-events {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #permissions-info:empty {
            display: none!important;
        }
        .permissions-header {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 8px;
            color: #FF0000;
        }
        .permission-item {
            padding: 4px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        .recent-events h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }
        .event-item {
            padding: 6px 0;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }
        #textarea div {
            padding-bottom: 4px;
        }
		.chat-container {
			background: white;
			border-radius: 4px;
			padding: 12px;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			flex-grow: 1;
			display: flex;
			flex-direction: column;
		}
		.chat-container h3 {
			margin: 0 0 10px 0;
			font-size: 16px;
		}
		#textarea {
			flex-grow: 1;
			height: 400px;
			max-height: 400px;
			overflow-y: auto;
			margin-bottom: 10px;
		}
		.header-avatar {
			width: 32px;
			height: 32px;
			border-radius: 50%;
			margin-right: 8px;
		}
		.user-info {
			display: flex;
			align-items: center;
		}
		.user-info-text {
			margin-right: 12px;
		}
		
		
		/* Header styles - updated */
		.channel-header {
			background: white;
			padding: 12px;
			border-radius: 4px;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		/* Separate top row with user info and sign-out button */
		.header-top {
			display: flex;
			justify-content: space-between;
			align-items: center;
			width: 100%;
		}
		
		.chat-emoji {
		  height: 1.2em;
		  width: auto;
		  vertical-align: middle;
		  margin: 0 0.05em;
		}
		
		.regular-emote {
		  height: 1.5em;
		  width: auto;
		  vertical-align: middle;
		  margin: 0 0.1em;
		}
		
		.zero-width-emote-centered {
		  position: absolute;
		  height: 1.5em;
		  width: auto;
		  transform: translate(-50%, -50%);
		  pointer-events: none;
		}

		/* User info styling */
		.user-info {
			display: flex;
			align-items: center;
		}

		.header-info {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			gap: 15px;
			width: 100%;
		}

		/* Style for the header items to handle overflow */
		.header-item {
			display: flex;
			align-items: center;
			gap: 6px;
			min-width: 0;
		}

		/* Target section with overflow handling */
		.header-target {
			display: flex;
			align-items: center;
			gap: 6px;
			overflow: hidden;
			max-width: 100%;
		}

		.header-target span:first-child {
			font-weight: bold;
			color: #FF0000;
			white-space: nowrap;
		}

		.target-text {
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.header-item span:first-child {
			font-weight: bold;
			color: #FF0000;
			white-space: nowrap;
		}

		/* Bottom row with channel input */
		.header-bottom {
			display: flex;
			align-items: center;
			justify-content: space-between;
			width: 100%;
		}

		/* Channel input container */
		.channel-input-container {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			gap: 8px;
			flex: 1;
		}

		.channel-input {
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ddd;
			border-radius: 4px;
			flex: 1;
			min-width: 120px;
		}

		/* Responsive adjustments */
		@media (max-width: 768px) {
			.header-info {
				flex-direction: column;
				align-items: flex-start;
			}
			
			.channel-input-container {
				margin-top: 10px;
				width: 100%;
			}
		}
		
		@media (max-height: 800px) {
			#textarea {
				max-height: calc(100vh - 370px);
			}
		
		}
		@media (max-height: 600px) {
			#textarea {
				max-height: calc(100vh - 200px);
			}
		
		}
		@media (max-height: 600px) {
			.chat-header, .stats-container {
				display:none!important;
			}

		}
		stats-container
		
		.poll-spinner-container {
			display: inline-flex;
			align-items: center;
			margin-left: 10px;
			font-size: 12px;
			color: #666;
		}

		.poll-spinner {
			width: 16px;
			height: 16px;
			border-radius: 50%;
			border: 2px solid rgba(255, 0, 0, 0.1);
			border-top-color: #FF0000;
			margin-right: 5px;
			transform-origin: center;
			animation-name: spinner-rotation;
			animation-timing-function: ease-in-out;
			animation-iteration-count: infinite;
		}

		@keyframes spinner-rotation {
			0% {
				transform: rotate(0deg);
			}
			100% {
				transform: rotate(360deg);
			}
		}

		.chat-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin: 0 0 10px 0;
		}
		
		/* Landing page styles */
		.landing-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			min-height: 400px;
			padding: 40px 20px;
			background: white;
			border-radius: 8px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			margin: 20px auto;
			max-width: 600px;
		}
		
		.youtube-logo {
			width: 80px;
			height: 56px;
			margin-bottom: 20px;
			background: url('../images/youtube.png') center/contain no-repeat;
		}
		
		.landing-title {
			font-size: 24px;
			font-weight: bold;
			margin-bottom: 10px;
			color: #333;
		}
		
		.landing-subtitle {
			font-size: 16px;
			color: #666;
			margin-bottom: 30px;
		}
		
		.auth-section {
			text-align: center;
			margin-bottom: 30px;
		}
		
		.landing-description {
			font-size: 14px;
			color: #666;
			text-align: center;
			line-height: 1.6;
			margin: 20px 0;
			max-width: 500px;
		}
		
		.policy-footer {
			position: fixed;
			bottom: 0;
			left: 0;
			right: 0;
			background: white;
			border-top: 1px solid #e0e0e0;
			padding: 15px;
			text-align: center;
			font-size: 13px;
			z-index: 100;
		}
		
		.policy-footer a {
			color: #1a73e8;
			text-decoration: none;
			margin: 0 10px;
		}
		
		.policy-footer a:hover {
			text-decoration: underline;
		}
		
		body:has(.auth:not(.hidden)) {
			padding-bottom: 60px; /* Make room for fixed footer only during sign-in */
		}
		
		@media (max-width: 768px) {
			.landing-container {
				margin: 10px;
			}
			.policy-footer {
				font-size: 12px;
				padding: 12px 10px;
			}
			.policy-footer a {
				margin: 0 5px;
				display: inline-block;
				line-height: 1.5;
			}
			/* Stack layout on mobile when socket is visible */
			body:has(.socket:not(.hidden)) .container {
				grid-template-columns: 1fr;
			}
			.sidebar {
				order: 2;
				margin-top: 20px;
			}
		}
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="auth">
                <div class="landing-container">
                    <div class="youtube-logo"></div>
                    <h1 class="landing-title">Social Stream for YouTube</h1>
                    <p class="landing-subtitle">Connect to YouTube Live Chat</p>
                    
                    <div class="auth-section">
                        <a id="auth-link" class="auth-button">Sign in with YouTube</a>
                    </div>
                    
                    <div class="landing-description">
                        <p>This tool requires OAuth sign-in to access YouTube's data APIs.</p>
                        <p><strong>Note:</strong> Events related to subscriptions, memberships, and followers are only available for your own channel. Chat functionality will work across most public channels.</p>
                    </div>
                </div>
            </div>
            
            <div class="hidden socket">
               <div class="channel-header">
					<div class="header-top">
						<div class="user-info">
							<div id="user-avatar"></div>
							<div class="user-info-text">
								<div class="header-item">
									<span>User:</span>
									<span id="current-user">Not signed in</span>
									<div class="header-target">
										<span>Target:</span>
										<span id="current-channel" class="target-text">No target</span>
									</div>
								</div>
							</div>
						</div>
						
					</div>
					
					<div class="header-bottom">
						<div class="header-info">
							<div class="channel-input-container">
								<input type="text" id="channel-input" class="channel-input" placeholder="Enter channel name">
								<input type="text" id="video-input" class="channel-input" placeholder="Enter video ID">
								<button id="connect-button" class="connect-button" style="background-color: #2255dd;">Connect</button>
								<button id="change-button" class="connect-button" style="background-color: #882244;">Reset</button>
								<button id="sign-out-button" class="sign-out-button">Sign Out</button>
							</div>
						</div>
					</div>
				</div>

                <div class="stats-container">
                    <h3>Channel Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="subscriber-count">-</div>
                            <div class="stat-label">Subscribers</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="viewer-count">-</div>
                            <div class="stat-label">Live Viewers</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="likes-count">-</div>
                            <div class="stat-label">Likes</div>
                        </div>
                    </div>
                </div>

                <div class="chat-container">
                    <h3>Chat Messages</h3>
                    <div id="textarea" class="ws-output"></div>
                    <div class="chat-input">
                        <input type="text" id="input-text" placeholder="Send Message">
                        <button id="sendmessage" class="auth-button">Send</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar hidden socket">
            <div class="permissions-container" id="permissions-info"></div>
            <div class="recent-events">
                <h4>Recent Events</h4>
                <div id="events-list"></div>
            </div>
        </div>
    </div>
    
    <div class="policy-footer hidden">
        <a href="https://socialstream.ninja/TOS" target="_blank">Terms of Service</a>
        |
        <a href="https://socialstream.ninja/privacy" target="_blank">Privacy Policy</a>
        |
        <a href="https://www.youtube.com/t/terms" target="_blank">YouTube's Terms of Service</a>
    </div>
    
<script>


try {
    var clientId = '689627108309-isbjas8fmbc7sucmbm7gkqjapk7btbsi.apps.googleusercontent.com';
    var redirectURI = window.location.href.split("/youtube")[0]+"/youtube.html";
    var scope = 'https://www.googleapis.com/auth/youtube.readonly https://www.googleapis.com/auth/youtube https://www.googleapis.com/auth/youtube.force-ssl';
    var username = "";
    var channel = '';
    var videoId = '';
    let pollInterval;
    let channelStatsInterval; // Separate interval for channel stats
    let fetchTimeout; // Track fetch timeout to clear on disconnect
    var lastMessageTime = null;
    var liveChatId = null;
    var nextPageToken = null;
    var isPolling = false;
    var userDetails = {};
    var currentStream = null;
	var messageQueue = [];
	var displayInterval;
	var isDisplaying = false;
	var quickPollCount = 0
    var urlParams = new URLSearchParams(window.location.search);
    var hashParams = new URLSearchParams(window.location.hash.slice(1));
	var initialBacklogProcessing = true;
	var initialBacklogTimestamp = null;
	var lastPollingTime = Date.now();
	var lastDisconnectTime = 0;
	var lastConnectedVideoId = null;
	var activeTimeouts = new Set(); // Track all active timeouts
	var lastSuccessfulPollTime = 0;
	var youtubeRecommendedInterval = 5000; // Default, will be updated by API
	var isPageVisible = true;
	var lastVisibilityChange = Date.now();
	var keepAliveInterval;
	var backgroundPollingInterval = 10000; // 10 seconds when in background
	var foregroundPollingInterval;

	var emojiData = [];
	var customEmoteData = [];
	var shortcutMap = new Map(); // For :word: patterns
	var unicodeMap = new Map();  // For Unicode emoji characters
	
	
	// BTTV/7TV/FFZ emote support
	var settings = {};
	var BTTV = false;
	var SEVENTV = false;
	var FFZ = false;
	var EMOTELIST = false;

	// Request emotes from extension
	function requestEmotesFromExtension() {
		if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {
			// Get video ID from current connection
			if (videoId) {
				console.log("Requesting emotes for video:", videoId);
				
				// Request BTTV emotes
				chrome.runtime.sendMessage(chrome.runtime.id, { 
					getBTTV: true,
					url: "https://youtube.com/?v=" + videoId,
					videoId: videoId,
					type: "youtube"
				}, function (response) {
					if (chrome.runtime.lastError) {
						console.log('BTTV request error:', chrome.runtime.lastError.message);
					}
				});
				
				// Request 7TV emotes if enabled
				if (settings.seventv) {
					chrome.runtime.sendMessage(chrome.runtime.id, { 
						getSEVENTV: true,
						url: "https://youtube.com/?v=" + videoId,
						videoId: videoId,
						type: "youtube"
					}, function (response) {
						if (chrome.runtime.lastError) {
							console.log('7TV request error:', chrome.runtime.lastError.message);
						}
					});
				}
				
				// Request FFZ emotes if enabled
				if (settings.ffz) {
					chrome.runtime.sendMessage(chrome.runtime.id, { 
						getFFZ: true,
						url: "https://youtube.com/?v=" + videoId,
						videoId: videoId,
						type: "youtube"
					}, function (response) {
						if (chrome.runtime.lastError) {
							console.log('FFZ request error:', chrome.runtime.lastError.message);
						}
					});
				}
			}
		}
	}
	function processEmojiData(data) {
	  emojiData = data;
	  // Clear existing data if any
	  shortcutMap.clear();
	  unicodeMap.clear();
	  
	  data.forEach(emoji => {
		// Map the Unicode emoji with its data
		unicodeMap.set(emoji.emojiId, {
		  url: emoji.image.thumbnails[0].url,
		  id: emoji.emojiId
		});
		
		// Map all shortcuts to a separate map
		if (emoji.shortcuts && emoji.shortcuts.length) {
		  emoji.shortcuts.forEach(shortcut => {
			shortcutMap.set(shortcut, {
			  url: emoji.image.thumbnails[0].url,
			  id: emoji.emojiId
			});
		  });
		}
	  });
	}
	function setTrackedTimeout(callback, delay, isBackground = false) {
		let timeoutHandle;
		if (isBackground && !isPageVisible && delay > 100) {
			timeoutHandle = modifiedSetTimeout(callback, delay);
		} else {
			timeoutHandle = setTimeout(callback, delay);
		}
		
		// Track the timeout
		activeTimeouts.add(timeoutHandle);
		
		// Wrap the clear function to remove from tracking
		const originalClear = timeoutHandle.clear || (() => clearTimeout(timeoutHandle));
		const trackedHandle = {
			clear: () => {
				originalClear();
				activeTimeouts.delete(timeoutHandle);
				activeTimeouts.delete(trackedHandle);
			},
			timeoutId: timeoutHandle.timeoutId || timeoutHandle
		};
		
		return trackedHandle;
	}
	function processCustomEmoteData(data) {
	  customEmoteData = data;
	  // Map custom emotes by their name (only in shortcut map)
	  data.forEach(emote => {
		const emoteName = `:${emote[0]}:`;
		shortcutMap.set(emoteName, {
		  url: emote[1],
		  id: "", // Empty alt for custom emotes
		  isCustom: true
		});
	  });
	}
	
	
	function escapeHtml(unsafe) {
		try {
			if (settings.textonlymode || false) {
				return unsafe;
			}
			return unsafe.replace(/[&<>"']/g, function(m) {
				return {
					'&': '&amp;',
					'<': '&lt;',
					'>': '&gt;',
					'"': '&quot;',
					"'": '&#039;'
				}[m];
			}) || "";
		} catch (e) {
			return "";
		}
	}
	
	function replaceEmotesWithImages(text) {
		if (!text || typeof text !== 'string') {
			return text || '';
		}
		if (!EMOTELIST) {
			return text;
		}
		
		let replacedCount = 0;
		const result = text.replace(/(?<=^|\s)(\S+?)(?=$|\s)/g, (match, emoteMatch) => {
			const emote = EMOTELIST[emoteMatch];
			if (emote) {
				replacedCount++;
				const escapedMatch = escapeHtml(emoteMatch); // should I be escaping this? It might be wastful CPU?
				const isZeroWidth = typeof emote !== "string" && emote.zw;
				return `<img src="${typeof emote === 'string' ? emote : emote.url}" alt="${escapedMatch}" title="${escapedMatch}" class="${isZeroWidth ? 'zero-width-emote-centered' : 'regular-emote'}"/>`;
			}
			return match;
		});
		
		if (replacedCount > 0) {
			console.log(`Replaced ${replacedCount} emotes in message: "${text}"`);
		}
		
		return result;
	}


	function loadEmojiData() {
	  // Try to get cached data first
	  const cachedData = localStorage.getItem('emojiData');
	  const cachedCustomData = localStorage.getItem('customEmoteData');
	  
	  const promises = [];
	  
	  // Handle standard emojis
	  const standardEmojiPromise = 
		fetch('emotes.json', {
		  mode: 'cors',
		  headers: { 'Accept': 'application/json' }
		})
		.then(response => {
		  if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
		  return response.json();
		})
		.then(data => {
		  try {
			localStorage.setItem('emojiData', JSON.stringify(data));
		  } catch (error) {
			console.warn('Failed to cache emoji data:', error);
		  }
		  return data;
		})
		.catch(error => {
		  console.error('Error loading standard emoji data:', error);
		  if (cachedData) {
			try {
			  return JSON.parse(cachedData);
			} catch (parseError) {
			  console.error('Failed to parse cached emoji data:', parseError);
			  return [];
			}
		  }
		  return [];
		});
	  
	  promises.push(standardEmojiPromise.then(data => {
		processEmojiData(data);
		return data;
	  }));

	  // Handle custom emotes
	  const customEmotePromise = fetch('custom_emotes.json', {
		mode: 'cors',
		headers: { 'Accept': 'application/json' }
	  })
	  .then(response => {
		if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
		return response.json();
	  })
	  .then(data => {
		try {
		  localStorage.setItem('customEmoteData', JSON.stringify(data));
		} catch (error) {
		  console.warn('Failed to cache custom emote data:', error);
		}
		return data;
	  })
	  .catch(error => {
		console.error('Error loading custom emote data:', error);
		if (cachedCustomData) {
		  try {
			return JSON.parse(cachedCustomData);
		  } catch (parseError) {
			console.error('Failed to parse cached custom emote data:', parseError);
			return [];
		  }
		}
		return [];
	  });
	  
	  promises.push(customEmotePromise.then(data => {
		processCustomEmoteData(data);
		return data;
	  }));

	  return Promise.all(promises);
	}

	function replaceEmojis(message) {
		if (!message || typeof message !== 'string') {
			return message || '';
		}
		let result = message;
		
		// Process BTTV/7TV/FFZ emotes first
		if (EMOTELIST) {
			result = replaceEmotesWithImages(result);
		}
		
		if (!shortcutMap.size && !unicodeMap.size) return result;
		
		// Process shortcut emotes
		const shortcutRegex = /:([\w_-]+):/g;
		result = result.replace(shortcutRegex, (match) => {
			const emojiInfo = shortcutMap.get(match);
			if (!emojiInfo) return match;
			
			if (settings.textonlymode || false) {
				if (emojiInfo.isCustom) return '';
				return emojiInfo.id;
			} else {
				const altText = emojiInfo.isCustom ? "" : emojiInfo.id;
				return `<img src="${emojiInfo.url}" alt="${altText}" class="chat-emoji" title="${altText}" />`;
			}
		});
	  
		if (!settings.textonlymode || false) {
		// Helper function to convert emoji sequences to their combined URLs
			function processEmojiSequence(text) {
			  // Match emoji followed by skin tone modifier
			  const emojiWithSkinToneRegex = /([\u{1F000}-\u{1FFFF}])([\u{1F3FB}-\u{1F3FF}])/gu;
			  
			  return text.replace(emojiWithSkinToneRegex, (match, baseEmoji, skinTone) => {
				// Check if base emoji exists in our map
				if (unicodeMap.has(baseEmoji)) {
				  // Generate the combined emoji URL
				  const baseUrl = unicodeMap.get(baseEmoji).url;
				  
				  // Format: baseUrl is in format like "https://fonts.gstatic.com/s/e/notoemoji/15.1/1f64f/72.png"
				  // Combined URL would be "https://fonts.gstatic.com/s/e/notoemoji/15.1/1f64f_1f3ff/72.png"
				  
				  // Extract the emoji code from the URL
				  const emojiCodeMatch = baseUrl.match(/\/([^\/]+)\/\d+\.png$/);
				  if (emojiCodeMatch) {
					const baseCode = emojiCodeMatch[1];
					const skinToneCode = skinTone.codePointAt(0).toString(16);
					const combinedUrl = baseUrl.replace(
					  `/${baseCode}/`,
					  `/${baseCode}_${skinToneCode}/`
					);
					
					return `<img class="regular-emote" src="${combinedUrl}" alt="${match}" title="${match}" />`;
				  }
				}
				
				return match; // Return original if not found
			  });
			}

			// Process emoji sequences first
			result = processEmojiSequence(result);

			// Then handle remaining standalone Unicode emoji characters
			for (const [unicodeChar, emojiInfo] of unicodeMap.entries()) {
			  if (result.includes(unicodeChar)) {
				const imgTag = `<img src="${emojiInfo.url}" alt="${unicodeChar}" class="chat-emoji" title="${unicodeChar}" />`;
				result = result.replace(new RegExp(unicodeChar, 'g'), imgTag);
			  }
			}
		}

		return result;
	}
	function getStoredToken() {
		const storedToken = localStorage.getItem('youtubeOAuthToken');
		const tokenExpiry = localStorage.getItem('youtubeOAuthExpiry');
		const refreshToken = localStorage.getItem('youtubeRefreshToken');
		if (storedToken && tokenExpiry && new Date().getTime() < parseInt(tokenExpiry)) {
			return storedToken;
		} else if (refreshToken) {
			refreshAccessToken(refreshToken);
			return null;
		} else {
			clearStoredToken();
			return null;
		}
	}
	function setStoredToken(token, expiresIn = 3600, refresh = null) {
		const expiryTime = new Date().getTime() + (expiresIn * 1000);
		localStorage.setItem('youtubeOAuthToken', token);
		localStorage.setItem('youtubeOAuthExpiry', expiryTime.toString());
		if (refresh) {
			localStorage.setItem('youtubeRefreshToken', refresh);
		}
	}function clearStoredToken() {
		localStorage.removeItem('youtubeOAuthToken');
		localStorage.removeItem('youtubeOAuthExpiry');
		localStorage.removeItem('youtubeRefreshToken');
		localStorage.removeItem('youtubeChannel');
        localStorage.removeItem('youtubeVideoId');
	}
    function showAuthButton() {
        const authElement = document.querySelector('.auth');
        if (authElement) authElement.classList.remove("hidden");
        document.querySelectorAll('.socket').forEach(ele=>ele.classList.add('hidden'));
        const policyFooter = document.querySelector('.policy-footer');
        if (policyFooter) policyFooter.classList.remove('hidden');
    }
    function showSocketInterface() {
        const authElement = document.querySelector('.auth');
        document.querySelectorAll('.socket').forEach(ele=>ele.classList.remove('hidden'));
        if (authElement) authElement.classList.add("hidden");
        const policyFooter = document.querySelector('.policy-footer');
        if (policyFooter) policyFooter.classList.add('hidden');
    }
	function handleVisibilityChange() {
		const wasVisible = isPageVisible;
		isPageVisible = document.visibilityState === 'visible';
		lastVisibilityChange = Date.now();
		
		if (isPageVisible && !wasVisible) {
			console.log('Page is now visible - checking polling state');
			
			// Clear any background keep-alive
			if (keepAliveInterval) {
				if (typeof keepAliveInterval.clear === 'function') {
					keepAliveInterval.clear();
				} else if (keepAliveInterval.intervalId) {
					clearInterval(keepAliveInterval.intervalId);
				}
				keepAliveInterval = null;
			}
			
			// Only resume if we have an active connection and aren't already polling
			if (liveChatId && !isPolling && !fetchTimeout) {
				const timeSinceLastPoll = Date.now() - lastPollingTime;
				const timeSinceLastSuccess = Date.now() - lastSuccessfulPollTime;
				const requiredInterval = Math.max(
					youtubeRecommendedInterval,
					foregroundPollingInterval || 5000
				);
				
				// Additional safety check for rapid visibility changes
				if (timeSinceLastSuccess < requiredInterval) {
					const remainingTime = requiredInterval - timeSinceLastSuccess;
					console.log(`Waiting ${remainingTime}ms before resuming (respecting YouTube interval)`);
					fetchTimeout = setTrackedTimeout(fetchChatMessages, remainingTime);
				} else if (timeSinceLastPoll < requiredInterval) {
					const remainingTime = requiredInterval - timeSinceLastPoll;
					console.log(`Waiting ${remainingTime}ms before resuming polling`);
					fetchTimeout = setTrackedTimeout(fetchChatMessages, remainingTime);
				} else {
					console.log('Safe to resume polling');
					fetchTimeout = setTrackedTimeout(fetchChatMessages, 1000); // Small delay to be safe
				}
			}
		} else if (!isPageVisible && wasVisible) {
			console.log('Page is now hidden - switching to background mode');
			
			// When going to background, trim queue to 200 messages
			if (messageQueue.length > 200) {
				messageQueue = messageQueue.slice(-200);
				console.log(`Trimmed message queue to 200 messages (was ${messageQueue.length})`);
			}
			
			// Cancel any pending fetch if we're going to background
			if (fetchTimeout && !isPolling) {
				if (typeof fetchTimeout.clear === 'function') {
					fetchTimeout.clear();
				} else {
					clearTimeout(fetchTimeout);
				}
				fetchTimeout = null;
			}
			
			if (!foregroundPollingInterval && pollInterval) {
				foregroundPollingInterval = pollInterval;
			}
			
			// Set up background keep-alive with proper interval
			if (!keepAliveInterval && liveChatId) {
				const scheduleNextKeepAlive = () => {
					const interval = Math.max(backgroundPollingInterval, youtubeRecommendedInterval);
					keepAliveInterval = modifiedSetTimeout(() => {
						backgroundKeepAlive();
						if (!isPageVisible && liveChatId) {
							scheduleNextKeepAlive();
						}
					}, interval);
				};
				scheduleNextKeepAlive();
			}
		}
	}
	async function fetchChatMessages() {
		if (!liveChatId || isPolling) return;
		
		// Double-check we're not polling too soon
		const timeSinceLastPoll = Date.now() - lastPollingTime;
		if (timeSinceLastPoll < youtubeRecommendedInterval) {
			console.warn(`Attempted to poll too soon. Waiting ${youtubeRecommendedInterval - timeSinceLastPoll}ms`);
			fetchTimeout = setTrackedTimeout(fetchChatMessages, youtubeRecommendedInterval - timeSinceLastPoll, !isPageVisible);
			return;
		}
		
		isPolling = true;
		lastPollingTime = Date.now();
		const token = getStoredToken();
		if (!token) {
			isPolling = false;
			refreshToken();
			return;
		}
		
		let response;
		try {
			let url = `https://www.googleapis.com/youtube/v3/liveChat/messages?liveChatId=${liveChatId}&part=snippet,authorDetails&maxResults=200`;
			if (nextPageToken) url += `&pageToken=${nextPageToken}`;
			
			response = await fetchWithTimeout(url, 5000, {
				'Authorization': `Bearer ${token}`,
				'Content-Type': 'application/json'
			});
			
			if (!response.ok) {
				const status = response.status;
				if (status === 401) {
					isPolling = false;
					await refreshAccessToken(localStorage.getItem('youtubeRefreshToken'));
					return;
				} else if (status === 403) {
					console.warn('Access forbidden - chat may be disabled or restricted');
					isPolling = false;
					fetchTimeout = setTrackedTimeout(fetchChatMessages, 30000, !isPageVisible);
					return;
				} else if (status === 429) {
					console.warn('Rate limited by YouTube API');
					isPolling = false;
					// Use exponential backoff for rate limits
					const backoffTime = Math.min(60000 * Math.pow(2, quickPollCount), 300000); // Max 5 minutes
					quickPollCount++;
					
					fetchTimeout = setTrackedTimeout(fetchChatMessages, backoffTime, !isPageVisible);
					return;
				}
				throw new Error(`HTTP error! status: ${status}`);
			}
			
			const data = await response.json();
			
			// ALWAYS respect YouTube's polling interval
			const recommendedInterval = data.pollingIntervalMillis || 5000;
			youtubeRecommendedInterval = recommendedInterval; // Store for future reference
			lastSuccessfulPollTime = Date.now(); // Track successful poll time
			
			if (data.items && data.items.length > 0) {
				// Process initial backlog timestamp
				if (initialBacklogProcessing && !initialBacklogTimestamp && data.items.length > 0) {
					const timestamps = data.items.map(item => new Date(item.snippet.publishedAt).getTime());
					initialBacklogTimestamp = Math.max(...timestamps);
					console.log('Initial backlog cutoff timestamp set:', new Date(initialBacklogTimestamp));
				}
				
				
				// Process all message types in a single loop
				data.items.forEach(item => {
				
					const publishedAt = new Date(item.snippet.publishedAt);
					const messageTime = publishedAt.getTime();
					if (!lastMessageTime || publishedAt > lastMessageTime) {
						const isBacklogMessage = initialBacklogProcessing && (messageTime <= initialBacklogTimestamp);
						
						// Process regular messages
						if (!isBacklogMessage) {
							queueMessage({
								authorName: item.authorDetails.displayName,
								message: item.snippet.displayMessage || item.snippet.textMessageDetails?.messageText || '',
								profileImageUrl: item.authorDetails.profileImageUrl,
								isChatOwner: item.authorDetails.isChatOwner,
								isChatSponsor: item.authorDetails.isChatSponsor,
								isChatModerator: item.authorDetails.isChatModerator,
								authorChannelId: item.authorDetails.channelId,
								publishedAt,
								skipEvent: isBacklogMessage
							});
						}
						
						// Process special message types
						if (item.snippet.superChatDetails) {
							processSuperChat({
								authorName: item.authorDetails.displayName,
								amount: item.snippet.superChatDetails.amountDisplayString,
								message: item.snippet.superChatDetails.userComment,
								tier: item.snippet.superChatDetails.tier,
								profileImageUrl: item.authorDetails.profileImageUrl,
								authorChannelId: item.authorDetails.channelId
							});
						}
						if (item.snippet.membershipDetails) {
							processMembership({
								authorName: item.authorDetails.displayName,
								level: item.snippet.membershipDetails.memberLevelName,
								profileImageUrl: item.authorDetails.profileImageUrl,
								authorChannelId: item.authorDetails.channelId
							});
						}
						
						// Update timestamp once for all message types
						lastMessageTime = publishedAt;
					}
				});
			}
			
			// Update pagination token
			nextPageToken = data.nextPageToken;
			
			// Handle completion of initial backlog
			if (initialBacklogProcessing && data.items.length < 200) {
				initialBacklogProcessing = false;
				console.log('Initial backlog processing complete');
			}
			
			// Reset quick poll count on successful request
			quickPollCount = 0;
			
			// Calculate next poll interval
			let nextPollInterval = recommendedInterval;
			
			// Only adjust for background, never go below recommended interval
			if (!isPageVisible) {
				nextPollInterval = Math.max(backgroundPollingInterval, recommendedInterval);
			}
			
			// Clear any existing timeout before setting new one
			if (fetchTimeout) {
				if (typeof fetchTimeout.clear === 'function') {
					fetchTimeout.clear();
				} else {
					clearTimeout(fetchTimeout);
				}
				fetchTimeout = null;
			}
			
			// Update spinner to show actual polling interval
			updatePollSpinner(nextPollInterval);
			
			// Schedule next poll
			fetchTimeout = setTrackedTimeout(fetchChatMessages, nextPollInterval, !isPageVisible);
			
		} catch (error) {
			console.error('Error fetching chat messages:', error);
			// Use exponential backoff for errors
			const backoffTime = Math.min(10000 * Math.pow(2, quickPollCount), 60000); // Max 1 minute
			quickPollCount++;
			
			// Clear any existing timeout before setting new one
			if (fetchTimeout) {
				if (typeof fetchTimeout.clear === 'function') {
					fetchTimeout.clear();
				} else {
					clearTimeout(fetchTimeout);
				}
				fetchTimeout = null;
			}
			
			fetchTimeout = setTrackedTimeout(fetchChatMessages, backoffTime, !isPageVisible);
		} finally {
			isPolling = false;
		}
	}
	
	function backgroundKeepAlive() {
		if (!isPageVisible && liveChatId) {
			console.log('Background keep-alive ping:', new Date().toISOString());
			
			// Only attempt to poll if we're not already polling and don't have a scheduled fetch
			if (!isPolling && !fetchTimeout) {
				const timeSinceLastPoll = Date.now() - lastPollingTime;
				const timeSinceLastSuccess = Date.now() - lastSuccessfulPollTime;
				const requiredInterval = Math.max(backgroundPollingInterval, youtubeRecommendedInterval);
				
				if (timeSinceLastPoll >= requiredInterval && timeSinceLastSuccess >= requiredInterval) {
					console.log('Sufficient time since last poll, fetching in background');
					fetchChatMessages();
				} else {
					const timeToWait = Math.max(
						requiredInterval - timeSinceLastPoll,
						requiredInterval - timeSinceLastSuccess
					);
					console.log(`Too soon to poll again in background, need to wait ${timeToWait}ms more`);
				}
			} else {
				console.log('Already polling or fetch scheduled, skipping background fetch');
			}
			
			// Audio context keep-alive to prevent browser from suspending the page
			if (typeof window.AudioContext !== 'undefined' || typeof window.webkitAudioContext !== 'undefined') {
				if (!window.keepAliveAudioContext) {
					const AudioContextClass = window.AudioContext || window.webkitAudioContext;
					window.keepAliveAudioContext = new AudioContextClass();
					const oscillator = window.keepAliveAudioContext.createOscillator();
					oscillator.type = 'sine';
					oscillator.frequency.setValueAtTime(0, window.keepAliveAudioContext.currentTime);
					const gainNode = window.keepAliveAudioContext.createGain();
					gainNode.gain.setValueAtTime(0, window.keepAliveAudioContext.currentTime);
					oscillator.connect(gainNode);
					gainNode.connect(window.keepAliveAudioContext.destination);
					oscillator.start();
				}
				if (window.keepAliveAudioContext.state === 'suspended') {
					window.keepAliveAudioContext.resume();
				}
			}
			
			// DOM manipulation to keep the page "active"
			if (document.getElementById('textarea')) {
				const timestamp = document.createElement('div');
				timestamp.style.display = 'none';
				timestamp.setAttribute('data-keepalive', Date.now());
				document.getElementById('textarea').appendChild(timestamp);
				
				// Clean up old timestamps to prevent memory leak
				const oldTimestamps = document.querySelectorAll('[data-keepalive]');
				if (oldTimestamps.length > 10) {
					oldTimestamps[0].remove();
				}
			}
		} else if (isPageVisible) {
			// Page became visible, clean up audio context
			if (window.keepAliveAudioContext) {
				try {
					window.keepAliveAudioContext.close();
					window.keepAliveAudioContext = null;
				} catch (e) {
					// Ignore errors when closing audio context
				}
			}
		}
	}

	function verifyAndUseToken(token) {
		try {
			getUserInfo(token).then(async userInfo => {
				if (userInfo && userInfo.items && userInfo.items.length > 0) {
					const userItem = userInfo.items[0];
					username = userItem.snippet.title;
					if (userItem.snippet.thumbnails && userItem.snippet.thumbnails.default) {
						const avatarContainer = document.getElementById('user-avatar');
						if (avatarContainer) {
							avatarContainer.innerHTML = '';
							const userImage = document.createElement('img');
							userImage.src = userItem.snippet.thumbnails.default.url;
							userImage.className = 'header-avatar';
							avatarContainer.appendChild(userImage);
						}
					}
					const redirectVideoId = sessionStorage.getItem("youtubeRedirectVideoId");
					const redirectChannel = sessionStorage.getItem("youtubeRedirectChannel");
					if (redirectVideoId) {
						videoId = redirectVideoId;
						channel = '';
						await connect(videoId);
						sessionStorage.removeItem("youtubeRedirectVideoId");
						sessionStorage.removeItem("youtubeRedirectChannel");
					} else if (redirectChannel) {
						channel = redirectChannel;
						videoId = '';
						document.getElementById('channel-input').value = channel;
						await connect();
						sessionStorage.removeItem("youtubeRedirectVideoId");
						sessionStorage.removeItem("youtubeRedirectChannel");
					} else if (videoId) {
						connect(videoId);
					} else if (channel) {
						document.getElementById('channel-input').value = channel;
						await connect();
					} else {
						updateHeaderInfo(username, 'No target specified');
						document.getElementById('textarea').innerHTML = '<div>Welcome! Please enter a YouTube channel name or video ID to connect.</div>';
						document.getElementById('viewer-count').textContent = '-';
						document.getElementById('subscriber-count').textContent = '-';
						document.getElementById('likes-count').textContent = '-';
					}
					showSocketInterface();
				} else {
					refreshToken();
				}
			}).catch(error => {
				if (error.message && error.message.includes('401')) {
					refreshAccessToken(localStorage.getItem('youtubeRefreshToken'));
				} else {
					console.error('Error validating token:', error);
					clearStoredToken();
					showAuthButton();
				}
			});
		} catch (error) {
			console.error('Error in verifyAndUseToken:', error);
			clearStoredToken();
			showAuthButton();
		}
	}
	function parseFragment(hash) {
		const tokens = {};
		hash.replace('#', '').split('&').forEach(param => {
			const [key, value] = param.split('=');
			tokens[key] = value;
		});
		if (tokens.access_token) {
			const expiresIn = tokens.expires_in ? parseInt(tokens.expires_in) : 3600;
			setStoredToken(tokens.access_token, expiresIn);
            window.history.replaceState({}, document.title, redirectURI);
			verifyAndUseToken(tokens.access_token);
		} else {
			console.error('No access token found in URL fragment');
			showAuthButton();
		}
	}
	async function refreshToken() {
		console.log('Attempting to refresh token or re-authenticate.');
        const storedRefreshToken = localStorage.getItem('youtubeRefreshToken');
        if (storedRefreshToken) {
            const refreshed = await refreshAccessToken(storedRefreshToken);
            if (refreshed) return;
        }
		clearStoredToken();
		showAuthButton();
	}
	function authUrl() {
		const state = nonce(15);
		sessionStorage.youtubeOAuthState = state;
		return 'https://ytauth.socialstream.ninja/auth' +
			'?client_id=' + clientId +
			'&redirect_uri=' + encodeURIComponent(redirectURI) +
			'&state=' + state;
	}
	async function refreshAccessToken(refreshTokenValue) {
		if (!refreshTokenValue) {
            console.log('No refresh token available for refreshAccessToken.');
            clearStoredToken();
            showAuthButton();
            return false;
        }
		try {
			const response = await fetch('https://ytauth.socialstream.ninja/refresh', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ refresh_token: refreshTokenValue })
			});
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
			const data = await response.json();
			setStoredToken(data.access_token, data.expires_in, data.refresh_token || refreshTokenValue);
			setTimeout(() => { verifyAndUseToken(data.access_token); }, 500);
			return true;
		} catch (error) {
			console.error('Error refreshing token:', error);
			clearStoredToken();
			showAuthButton();
			return false;
		}
	}
	async function handleAuthCallback() {
		const urlParams = new URLSearchParams(window.location.search);
		const code = urlParams.get('code');
		const state = urlParams.get('state');
		if (state !== sessionStorage.youtubeOAuthState) {
			console.error('State mismatch - possible CSRF attack');
			showAuthButton(); return;
		}
		if (code) {
			try {
				const response = await fetch('https://ytauth.socialstream.ninja/token', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ code: code, redirect_uri: redirectURI })
				});
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
				const data = await response.json();
				setStoredToken(data.access_token, data.expires_in, data.refresh_token);
				window.history.replaceState({}, document.title, redirectURI);
				verifyAndUseToken(data.access_token);
			} catch (error) {
				console.error('Error exchanging code for tokens:', error);
				showAuthButton();
			}
		}
	}
    function nonce(length) {
        var text = "";
        var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (var i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    function signOut() {
        clearPolling();
        clearStoredToken();
        username = "";
        channel = '';
        videoId = '';
        updateHeaderInfo(null, null);
        document.querySelectorAll('.socket').forEach(ele=>ele.classList.add('hidden'));
        document.querySelector('.auth').classList.remove('hidden');
        document.querySelector('#textarea').innerHTML = '';
        document.getElementById('viewer-count').textContent = '-';
        document.getElementById('subscriber-count').textContent = '-';
        document.getElementById('likes-count').textContent = '-';
        document.getElementById('events-list').innerHTML = '';
        document.getElementById('permissions-info').innerHTML = '';
        document.getElementById('channel-input').value = '';
        console.log('Signed out successfully');
    }
    function handleEnterKey(event) {
        if (event.key === 'Enter') handleSendMessage(event);
    }
	function handleSendMessage(event) {
		event.preventDefault();
		if (handleSendMessage.isSending) return;
		const inputElement = document.querySelector('#input-text');
		if (!inputElement) return;
		var msg = inputElement.value.trim();
		if (!msg || !liveChatId) {
			return;
		}
		handleSendMessage.isSending = true;
		const originalMsg = msg;
		inputElement.value = "";
		sendChatMessage(originalMsg).then(response => {
			if (response && response.success) {
				processMessage({
					authorName: username,
					message: originalMsg,
					profileImageUrl: response.authorDetails?.profileImageUrl || '',
					isChatOwner: response.authorDetails?.isChatOwner || false,
					isChatSponsor: response.authorDetails?.isChatSponsor || false,
					isChatModerator: response.authorDetails?.isChatModerator || false
				});
			}
			setTimeout(() => { handleSendMessage.isSending = false; }, 500);
		}).catch(() => {
			setTimeout(() => { handleSendMessage.isSending = false; }, 500);
		});
	}
	async function handleConnect() {
		const connectButton = document.getElementById('connect-button');
		const channelInput = document.getElementById('channel-input');
		const videoInput = document.getElementById('video-input');
		
		// If already connected, disconnect
		if (liveChatId || pollInterval) {
			clearPolling();
			updateHeaderInfo(username, 'Disconnected');
			document.getElementById('textarea').innerHTML = '<div>Disconnected from chat.</div>';
			document.getElementById('viewer-count').textContent = '-';
			document.getElementById('subscriber-count').textContent = '-';
			document.getElementById('likes-count').textContent = '-';
			document.getElementById('events-list').innerHTML = '';
			connectButton.textContent = 'Connect';
			connectButton.style.backgroundColor = '#2255dd';
			return;
		}
		
		const channelNameFromInput = channelInput.value.trim();
		const videoIdFromInput = videoInput.value.trim();
		clearPolling();
		if (videoIdFromInput) {
			localStorage.setItem('youtubeVideoId', videoIdFromInput);
			localStorage.removeItem('youtubeChannel');
			videoId = videoIdFromInput;
			channel = '';
			updateHeaderInfo(username, "Loading video: " + videoId);
			await connect(videoId);
			videoInput.value = '';
		} else if (channelNameFromInput) {
			localStorage.setItem('youtubeChannel', channelNameFromInput);
			localStorage.removeItem('youtubeVideoId');
			channel = channelNameFromInput;
			videoId = '';
			updateHeaderInfo(username, "Channel: " + channel);
			await connect();
			channelInput.value = '';
		}
	}
    async function getUserInfo(token) {
        try {
            const response = await fetchWithTimeout('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true', 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error('Error fetching user info:', error);
            if (error.message && error.message.includes('401')) throw error;
            return null;
        }
    }
    async function getChannelInfo(channelIdentifier) {
		const token = getStoredToken();
		if (!token) return null;
		if (userDetails[channelIdentifier]) return userDetails[channelIdentifier];
		try {
			// First try: direct channel ID lookup
			let response = await fetchWithTimeout(
				`https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelIdentifier}`, 5000,
				{ 'Authorization': `Bearer ${token}` }
			);
			let data = await response.json();
			
			// Second try: username lookup if first try failed and not a channel ID
			if ((!data.items || data.items.length === 0) && !channelIdentifier.startsWith('UC')) {
				response = await fetchWithTimeout(
					`https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&forUsername=${channelIdentifier}`, 5000,
					{ 'Authorization': `Bearer ${token}` }
				);
				data = await response.json();
			}
			
			// Third try: search query if previous attempts failed
			if ((!data.items || data.items.length === 0) && !channelIdentifier.startsWith('UC')) {
				// Handle @username format by removing @ if present
				const searchQuery = channelIdentifier.startsWith('@') ? 
					channelIdentifier.substring(1) : channelIdentifier;
					
				response = await fetchWithTimeout(
					`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${searchQuery}&type=channel&maxResults=1`, 5000,
					{ 'Authorization': `Bearer ${token}` }
				);
				const searchData = await response.json();
				if (searchData.items && searchData.items.length > 0) {
					const channelIdFromResult = searchData.items[0].id.channelId;
					response = await fetchWithTimeout(
						`https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelIdFromResult}`, 5000,
						{ 'Authorization': `Bearer ${token}` }
					);
					data = await response.json();
				}
			}
			
			if (data.items && data.items.length > 0) {
				userDetails[channelIdentifier] = data.items[0];
				userDetails[data.items[0].id] = data.items[0];
				return data.items[0];
			}
			return null;
		} catch (error) {
			console.error('Error fetching channel info:', error);
			return null;
		}
	}
    async function getLiveStreamInfo(channelId) {
        const token = getStoredToken();
        if (!token) return null;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&eventType=live&type=video&maxResults=1`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                const videoIdFromResult = data.items[0].id.videoId;
                const detailsResponse = await fetchWithTimeout(
                    `https://www.googleapis.com/youtube/v3/videos?part=snippet,liveStreamingDetails,statistics&id=${videoIdFromResult}`, 5000,
                    { 'Authorization': `Bearer ${token}` }
                );
                const detailsData = await detailsResponse.json();
                if (detailsData.items && detailsData.items.length > 0) {
                    return detailsData.items[0];
                }
            }
            return null;
        } catch (error) {
            console.error('Error fetching live stream info:', error);
            return null;
        }
    }
    async function getLiveChatId(videoIdForChat) {
        const token = getStoredToken();
        if (!token) return null;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${videoIdForChat}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            const data = await response.json();
            if (data.items && data.items.length > 0 && data.items[0].liveStreamingDetails) {
                return data.items[0].liveStreamingDetails.activeLiveChatId;
            }
            return null;
        } catch (error) {
            console.error('Error fetching live chat ID:', error);
            return null;
        }
    }
	function updatePollSpinner(interval) {
	  const spinner = document.getElementById('poll-spinner');
	  if (spinner) {
		interval -= 300;
		if (interval<100){interval=100};
		const seconds = (interval / 1000).toFixed(1);
		spinner.style.animation = 'none';
		void spinner.offsetWidth;
		spinner.style.animation = `spinner-rotation ${interval}ms ease-in-out 1`;
		document.getElementById('poll-time').textContent = `${seconds}s`;
	  }
	}
	function initializeSpinner() {
	  const chatHeader = document.querySelector('.chat-container h3');
	  if (!chatHeader) return;
	  chatHeader.className = 'chat-header';
	  chatHeader.innerHTML = `
		<span>Chat Messages</span>
		<div class="poll-spinner-container">
		  <div id="poll-spinner" class="poll-spinner"></div>
		  <span id="poll-time">5.0s</span>
		</div>
	  `;
	  updatePollSpinner(5000);
	}
	function queueMessage(messageData) {
		// Limit queue to 500 messages
		if (messageQueue.length >= 500) {
			messageQueue.splice(0, messageQueue.length - 499);
		}
		messageQueue.push(messageData);
		if (!isDisplaying) startDisplayQueue();
	}
	function startDisplayQueue() {
		if (isDisplaying || messageQueue.length === 0) return;
		isDisplaying = true;
		displayNextMessage();
	}
	function displayNextMessage() {
		if (messageQueue.length === 0) {
			isDisplaying = false;
			return;
		}
		
		isDisplaying = true;
		
		// Determine batch size based on queue length
		let batchSize = 1;
		if (messageQueue.length > 100) batchSize = 10;
		else if (messageQueue.length > 50) batchSize = 5;
		else if (messageQueue.length > 30) batchSize = 4;
		else if (messageQueue.length > 20) batchSize = 3;
		else if (messageQueue.length > 10) batchSize = 2;
		
		// Process a batch of messages
		const batchToProcess = messageQueue.splice(0, Math.min(batchSize, messageQueue.length));
		for (const message of batchToProcess) {
			processMessage(message);
		}
		
		// Calculate delay for next batch (more messages = shorter delay)
		let delay = 500; // Base delay between batches
		if (messageQueue.length > 50) delay = 80;
		else if (messageQueue.length > 20) delay = 100;
		else if (messageQueue.length > 10) delay = 200;
		else if (messageQueue.length > 4) delay = 300;
		
		// Schedule next batch processing with appropriate delay and method
		if (isPageVisible) {
			setTimeout(() => displayNextMessage(), delay);
		} else {
			modifiedSetTimeout(() => displayNextMessage(), delay);
		}
	}
		
	
    async function sendChatMessage(message) {
		const token = getStoredToken();
		if (!token || !liveChatId) return { success: false };
		try {
			const baseUrl = 'https://www.googleapis.com/youtube/v3/liveChat/messages';
			const url = `${baseUrl}?part=snippet,authorDetails`;
			const response = await fetchWithTimeout(url, 10000, {
				method: 'POST',
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${token}`,
				body: JSON.stringify({
					snippet: {
						liveChatId: liveChatId,
						type: 'textMessageEvent',
						textMessageDetails: { messageText: message }
					}
				})
			});
			const data = await response.json();
			//console.log('Chat message sent successfully:', data);
			return data;
		} catch (error) {
			console.error('Error sending chat message:', error);
			return { success: false };
		}
	}
	function oscillatorTimeout(callback, delay) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();

        const oscillator = ctx.createOscillator();
        const gain = ctx.createGain();
        gain.gain.value = 0;
        oscillator.connect(gain);
        gain.connect(ctx.destination);

        let rafId;
        let startTime = performance.now();
        let isDone = false;
        const checkTime = (timestamp) => {
            if (isDone) return;

            if ((timestamp - startTime) >= delay) {
                isDone = true;
                oscillator.onended = () => {};
                oscillator.disconnect();
                gain.disconnect();
                ctx.close();
                cancelAnimationFrame(rafId);
                callback();
                return;
            }
            rafId = requestAnimationFrame(checkTime);
        };
        oscillator.onended = () => {
            if (isDone) return;
            isDone = true;
            cancelAnimationFrame(rafId);
            oscillator.disconnect();
            gain.disconnect();
            ctx.close();
            callback();
        };

        oscillator.start();
        oscillator.stop(ctx.currentTime + delay/1000);
        rafId = requestAnimationFrame(checkTime);

        return {
            clear: () => {
                isDone = true;
                cancelAnimationFrame(rafId);
                oscillator.onended = () => {};
                oscillator.disconnect();
                gain.disconnect();
                ctx.close();
            }
        };
    }
	
	// Global queue for managing timeouts when page isn't visible
	const timeoutQueue = {
		items: [],
		activeOscillator: null,
		nextId: 1,
		
		add: function(callback, delay) {
			const id = this.nextId++;
			const executeTime = performance.now() + delay;
			
			this.items.push({
				id,
				callback,
				executeTime
			});
			
			// Sort the queue by execution time
			this.items.sort((a, b) => a.executeTime - b.executeTime);
			
			// If we have an active oscillator, check if we need to update its timing
			if (this.activeOscillator && this.items[0].id === id) {
				// This new item is now the first in the queue, so we need to update the oscillator
				this.activeOscillator.clear();
				this.activeOscillator = null;
				this.processQueue();
			} else if (!this.activeOscillator) {
				// Start the queue processing if no active oscillator
				this.processQueue();
			}
			
			// Return an object with clear method
			return {
				clear: () => this.remove(id)
			};
		},
		
		// Remove a timeout from the queue
		remove: function(id) {
			const index = this.items.findIndex(item => item.id === id);
			if (index !== -1) {
				this.items.splice(index, 1);
				
				// If we removed the first item and we have an active oscillator,
				// we need to clear it and start a new one for the next item
				if (index === 0 && this.activeOscillator) {
					this.activeOscillator.clear();
					this.activeOscillator = null;
					this.processQueue();
				}
			}
		},
		
		// Process the queue, executing due callbacks and setting up next oscillator
		processQueue: function() {
			if (this.items.length === 0) return;
			
			const now = performance.now();
			
			// Execute all items that are due
			while (this.items.length > 0 && this.items[0].executeTime <= now) {
				const item = this.items.shift();
				try {
					item.callback();
				} catch (e) {
					console.error('Error executing timeout callback:', e);
				}
			}
			
			// If there are more items, set up the next oscillator
			if (this.items.length > 0) {
				const nextItem = this.items[0];
				const nextDelay = Math.max(100, nextItem.executeTime - now);
				
				this.activeOscillator = this.createOscillator(() => {
					this.activeOscillator = null;
					this.processQueue();
				}, nextDelay);
			}
		},
		
		// Create an oscillator with the given callback and delay
		createOscillator: function(callback, delay) {
			const AudioContext = window.AudioContext || window.webkitAudioContext;
			const ctx = new AudioContext();

			const oscillator = ctx.createOscillator();
			const gain = ctx.createGain();
			gain.gain.value = 0;
			oscillator.connect(gain);
			gain.connect(ctx.destination);

			let rafId;
			let startTime = performance.now();
			let isDone = false;
			const checkTime = (timestamp) => {
				if (isDone) return;

				if ((timestamp - startTime) >= delay) {
					isDone = true;
					oscillator.onended = () => {};
					oscillator.disconnect();
					gain.disconnect();
					ctx.close();
					cancelAnimationFrame(rafId);
					callback();
					return;
				}
				rafId = requestAnimationFrame(checkTime);
			};
			oscillator.onended = () => {
				if (isDone) return;
				isDone = true;
				cancelAnimationFrame(rafId);
				oscillator.disconnect();
				gain.disconnect();
				ctx.close();
				callback();
			};

			oscillator.start();
			oscillator.stop(ctx.currentTime + delay/1000);
			rafId = requestAnimationFrame(checkTime);

			return {
				clear: () => {
					isDone = true;
					cancelAnimationFrame(rafId);
					oscillator.onended = () => {};
					oscillator.disconnect();
					gain.disconnect();
					ctx.close();
				}
			};
		}
	};

	function notifyVideoChange(videoId, channelId) {
		window.dispatchEvent(new CustomEvent('youtubeVideoChanged', {
			detail: {
				videoId: videoId || null,
				channelId: channelId || null
			},
			bubbles: true
		}));
		
		// Also request emotes for this video
		if (videoId) {
			requestEmotesFromExtension();
		}
	}
	
	function modifiedSetTimeout(callback, delay) {
		if (!isPageVisible && delay > 100) {
			return timeoutQueue.add(callback, delay);
		} else {
			const timeoutId = setTimeout(callback, delay);
			return {
				clear: () => clearTimeout(timeoutId)
			};
		}
	}

    async function getStreamStats() {
        if (!currentStream || !currentStream.id) return;
        const token = getStoredToken();
        if (!token) return;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/videos?part=statistics,liveStreamingDetails&id=${currentStream.id}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                const stats = data.items[0];
                if (stats.liveStreamingDetails && stats.liveStreamingDetails.concurrentViewers) {
                    updateStats('viewer_update', { meta: stats.liveStreamingDetails.concurrentViewers });
                }
                if (stats.statistics && stats.statistics.likeCount) {
                    updateStats('likes_update', { meta: stats.statistics.likeCount });
                }
            }
        } catch (error) {
            console.error('Error fetching stream stats:', error);
        }
    }
    async function getSubscriberCount(channelIdForSubs) {
        const token = getStoredToken();
        if (!token) return;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelIdForSubs}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (data.items && data.items.length > 0 && data.items[0].statistics) {
                updateStats('subscriber_update', { meta: data.items[0].statistics.subscriberCount });
            }
        } catch (error) {
            console.error('Error fetching subscriber count:', error);
        }
    }
	function clearPolling() {
		// Clear all tracked timeouts
		activeTimeouts.forEach(timeout => {
			try {
				if (typeof timeout.clear === 'function') {
					timeout.clear();
				} else if (timeout.timeoutId) {
					clearTimeout(timeout.timeoutId);
				} else {
					clearTimeout(timeout);
				}
			} catch (e) {
				// Ignore errors from already cleared timeouts
			}
		});
		activeTimeouts.clear();
		
		if (pollInterval) clearInterval(pollInterval);
		if (channelStatsInterval) clearInterval(channelStatsInterval);
		if (keepAliveInterval) {
			if (typeof keepAliveInterval.clear === 'function') {
				keepAliveInterval.clear();
			} else if (keepAliveInterval.intervalId) {
				clearInterval(keepAliveInterval.intervalId);
			} else {
				clearInterval(keepAliveInterval);
			}
		}
		if (fetchTimeout) {
			if (typeof fetchTimeout.clear === 'function') {
				fetchTimeout.clear();
			} else {
				clearTimeout(fetchTimeout);
			}
		}
		
		keepAliveInterval = null;
		foregroundPollingInterval = null;
		pollInterval = null;
		channelStatsInterval = null;
		fetchTimeout = null;
		
		// Track disconnection time and video ID
		if (liveChatId && currentStream) {
			lastDisconnectTime = Date.now();
			lastConnectedVideoId = currentStream.id;
		}
		
		liveChatId = null;
		nextPageToken = null;
		lastMessageTime = null;
		isPolling = false;
		currentStream = null;
		messageQueue = [];
		isDisplaying = false;
		quickPollCount = 0;
		lastSuccessfulPollTime = 0;
		youtubeRecommendedInterval = 5000; // Reset to default
		
		const chatHeader = document.querySelector('.chat-container h3');
		if (chatHeader) {
			chatHeader.className = '';
			chatHeader.textContent = 'Chat Messages';
		}
	}
	async function getChannelStats(channelIdForStats) {
		const token = getStoredToken();
		if (!token) return;
		try {
			const response = await fetchWithTimeout(
				`https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelIdForStats}`, 5000,
				{ 'Authorization': `Bearer ${token}` }
			);
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
			const data = await response.json();
			if (data.items && data.items.length > 0 && data.items[0].statistics) {
				const stats = data.items[0].statistics;
				if (stats.subscriberCount) {
					updateStats('subscriber_update', { meta: stats.subscriberCount });
					pushMessage({ type: youtubeShorts ? "youtubeshorts" : "youtube", event: 'subscriber_update', meta: stats.subscriberCount });
				}
				if (stats.viewCount) {
					pushMessage({ type: youtubeShorts ? "youtubeshorts" : "youtube", event: 'view_update', meta: stats.viewCount });
				}
			}
		} catch (error) {
			console.error('Error fetching channel stats:', error);
		}
	}
	async function connect(directVideoIdParam = null) {
		// Prevent double connections
		if (liveChatId || pollInterval) {
			console.warn('Already connected. Call clearPolling() first to disconnect.');
			return;
		}
		clearPolling();
		initialBacklogProcessing = true;
		initialBacklogTimestamp = null;
		const token = getStoredToken();
		if (!token) {
			console.error('No token available for connect');
			showAuthButton();
			return;
		}
		const channelToUse = channel;
		const videoIdToUse = directVideoIdParam || videoId;
		if (!videoIdToUse && !channelToUse) {
			updateHeaderInfo(username, 'No target specified');
			document.getElementById('viewer-count').textContent = '-';
			document.getElementById('subscriber-count').textContent = '-';
			document.getElementById('likes-count').textContent = '-';
			document.getElementById('textarea').innerHTML = '<div>Please enter a YouTube channel name or video ID to connect.</div>';
			return;
		}
		document.getElementById('textarea').innerHTML = '<div>Attempting to connect...</div>';
		try {
			let streamInfoToUse;
			let channelInfoForHeaderAndStats;
			let effectiveChannelIdToUse;
			let streamTitleToUse;
			let channelDisplayNameToUse;
			if (videoIdToUse) {
				const videoDetailsResponse = await fetchWithTimeout(
					`https://www.googleapis.com/youtube/v3/videos?part=snippet,liveStreamingDetails,statistics&id=${videoIdToUse}`,
					5000, { 'Authorization': `Bearer ${token}` }
				);
				if (!videoDetailsResponse.ok) throw new Error(`Failed to fetch video details for ${videoIdToUse}: ${videoDetailsResponse.status}`);
				const videoDetailsData = await videoDetailsResponse.json();
				if (!videoDetailsData.items || videoDetailsData.items.length === 0) {
					throw new Error(`Video not found or not accessible: ${videoIdToUse}`);
				}
				streamInfoToUse = videoDetailsData.items[0];
				const isVideoLive = streamInfoToUse.snippet.liveBroadcastContent === 'live';
				const isVideoUpcoming = streamInfoToUse.snippet.liveBroadcastContent === 'upcoming';
				const isVideoEnded = (streamInfoToUse.liveStreamingDetails && streamInfoToUse.liveStreamingDetails.actualEndTime) ||
									 streamInfoToUse.snippet.liveBroadcastContent === 'none';
				if (isVideoEnded) {
					liveChatId = null;
					effectiveChannelIdToUse = streamInfoToUse.snippet.channelId;
					streamTitleToUse = streamInfoToUse.snippet.title;
					channelInfoForHeaderAndStats = await getChannelInfo(effectiveChannelIdToUse);
					channelDisplayNameToUse = channelInfoForHeaderAndStats ? channelInfoForHeaderAndStats.snippet.title : streamInfoToUse.snippet.channelTitle;
					updateHeaderInfo(username, `${channelDisplayNameToUse} (Video: ${streamTitleToUse.substring(0,20)}...)`);
					document.getElementById('textarea').innerHTML = `<div>This video is not currently live. Showing stats for: ${streamTitleToUse}</div>`;
					if (streamInfoToUse.statistics) {
						document.getElementById('viewer-count').textContent = streamInfoToUse.statistics.viewCount || '-';
						document.getElementById('likes-count').textContent = streamInfoToUse.statistics.likeCount || '-';
					}
					if (channelInfoForHeaderAndStats && channelInfoForHeaderAndStats.statistics) {
						updateStats('subscriber_update', { meta: channelInfoForHeaderAndStats.statistics.subscriberCount });
					} else if (effectiveChannelIdToUse) {
						await getSubscriberCount(effectiveChannelIdToUse);
					}
					currentStream = { id: streamInfoToUse.id, title: streamTitleToUse, channelId: effectiveChannelIdToUse };
					notifyVideoChange(streamInfoToUse.id, effectiveChannelIdToUse);

					return;
				} else if (isVideoUpcoming) {
					liveChatId = streamInfoToUse.liveStreamingDetails?.activeLiveChatId;
					effectiveChannelIdToUse = streamInfoToUse.snippet.channelId;
					streamTitleToUse = streamInfoToUse.snippet.title;
					channelInfoForHeaderAndStats = await getChannelInfo(effectiveChannelIdToUse);
					channelDisplayNameToUse = channelInfoForHeaderAndStats ? channelInfoForHeaderAndStats.snippet.title : streamInfoToUse.snippet.channelTitle;
					updateHeaderInfo(username, `${channelDisplayNameToUse} (Upcoming: ${streamTitleToUse.substring(0,20)}...)`);
					if (!liveChatId) {
						document.getElementById('textarea').innerHTML = `<div>This is an upcoming stream. Chat may not be available yet.</div>`;
						document.getElementById('viewer-count').textContent = 'N/A';
						document.getElementById('likes-count').textContent = streamInfoToUse.statistics?.likeCount || '-';
					}
				} else if (!streamInfoToUse.liveStreamingDetails || !streamInfoToUse.liveStreamingDetails.activeLiveChatId) {
					throw new Error(`Video is not live or chat is not enabled: ${streamInfoToUse.snippet.title}`);
				} else {
					liveChatId = streamInfoToUse.liveStreamingDetails.activeLiveChatId;
					effectiveChannelIdToUse = streamInfoToUse.snippet.channelId;
					streamTitleToUse = streamInfoToUse.snippet.title;
					channelInfoForHeaderAndStats = await getChannelInfo(effectiveChannelIdToUse);
					channelDisplayNameToUse = channelInfoForHeaderAndStats ? channelInfoForHeaderAndStats.snippet.title : streamInfoToUse.snippet.channelTitle;
					updateHeaderInfo(username, `${channelDisplayNameToUse} (Live: ${streamTitleToUse.substring(0,20)}...)`);
				}
				currentStream = { id: streamInfoToUse.id, title: streamTitleToUse, channelId: effectiveChannelIdToUse };
				notifyVideoChange(streamInfoToUse.id, effectiveChannelIdToUse);

			} else if (channelToUse) {
                channelInfoForHeaderAndStats = await getChannelInfo(channelToUse);
                if (!channelInfoForHeaderAndStats) {
                    throw new Error(`Channel not found: ${channelToUse}`);
                }
                channelDisplayNameToUse = channelInfoForHeaderAndStats.snippet.title;
                effectiveChannelIdToUse = channelInfoForHeaderAndStats.id;
                updateHeaderInfo(username, channelDisplayNameToUse);
                streamInfoToUse = await getLiveStreamInfo(effectiveChannelIdToUse);
                if (!streamInfoToUse) {
                    if (channelInfoForHeaderAndStats.statistics && channelInfoForHeaderAndStats.statistics.subscriberCount) {
                        updateStats('subscriber_update', { meta: channelInfoForHeaderAndStats.statistics.subscriberCount });
                    }
                    throw new Error(`No active live stream found for channel: ${channelDisplayNameToUse}`);
                }
                streamTitleToUse = streamInfoToUse.snippet.title;
                liveChatId = streamInfoToUse.liveStreamingDetails?.activeLiveChatId || await getLiveChatId(streamInfoToUse.id);
                 if (!liveChatId && streamInfoToUse.snippet.liveBroadcastContent === 'upcoming') {
                    console.log(`Stream "${streamTitleToUse}" is upcoming. Chat may not be available yet.`);
                } else if (!liveChatId) {
                    throw new Error(`No live chat available for stream: ${streamTitleToUse}`);
                }
                currentStream = { id: streamInfoToUse.id, title: streamTitleToUse, channelId: effectiveChannelIdToUse };
				notifyVideoChange(streamInfoToUse.id, effectiveChannelIdToUse);

                updateHeaderInfo(username, channelDisplayNameToUse + (liveChatId ? ` (Live: ${streamTitleToUse.substring(0,20)}...)` : ` (Upcoming Stream)`));
            }
            document.getElementById('textarea').innerHTML = '';
            const connectMessageDiv = document.createElement("div");
            connectMessageDiv.innerText = `Target: ${channelDisplayNameToUse} - Stream: ${streamTitleToUse || 'N/A'}`;
            document.getElementById('textarea').appendChild(connectMessageDiv);
            if (streamInfoToUse) {
                if (streamInfoToUse.liveStreamingDetails && streamInfoToUse.liveStreamingDetails.concurrentViewers) {
                    updateStats('viewer_update', { meta: streamInfoToUse.liveStreamingDetails.concurrentViewers });
                } else {
                     document.getElementById('viewer-count').textContent = 'N/A';
                }
                if (streamInfoToUse.statistics && streamInfoToUse.statistics.likeCount) {
                    updateStats('likes_update', { meta: streamInfoToUse.statistics.likeCount });
                } else {
                     document.getElementById('likes-count').textContent = 'N/A';
                }
            }
            if (channelInfoForHeaderAndStats && channelInfoForHeaderAndStats.statistics && channelInfoForHeaderAndStats.statistics.subscriberCount) {
                updateStats('subscriber_update', { meta: channelInfoForHeaderAndStats.statistics.subscriberCount });
            } else if (effectiveChannelIdToUse) {
                await getSubscriberCount(effectiveChannelIdToUse);
            }
           if (liveChatId) {
				const chatAvailableMessage = document.createElement("div");
				chatAvailableMessage.innerText = "Connected to live chat.";
				document.getElementById('textarea').appendChild(chatAvailableMessage);
				// Update connect button to show disconnect
				const connectButton = document.getElementById('connect-button');
				if (connectButton) {
					connectButton.textContent = 'Disconnect';
					connectButton.style.backgroundColor = '#f44336';
				}
				initializeSpinner();
				// Calculate delay based on reconnection timing
				let initialFetchDelay = 2000; // Default 2 second delay
				
				// If reconnecting to the same video within 10 seconds, use longer delay
				if (currentStream && lastConnectedVideoId === currentStream.id) {
					const timeSinceDisconnect = Date.now() - lastDisconnectTime;
					if (timeSinceDisconnect < 10000) {
						initialFetchDelay = Math.max(5000, 10000 - timeSinceDisconnect);
						console.log(`Reconnecting to same video after ${timeSinceDisconnect}ms, using ${initialFetchDelay}ms delay`);
					}
				}
				
				if (!isPageVisible) {
					fetchTimeout = modifiedSetTimeout(fetchChatMessages, initialFetchDelay);
				} else {
					fetchTimeout = setTimeout(fetchChatMessages, initialFetchDelay);
				}
			} else {
                 const noChatMessage = document.createElement("div");
                 noChatMessage.style.color = "orange";
                 noChatMessage.innerText = "Live chat is not currently active for this stream.";
                 document.getElementById('textarea').appendChild(noChatMessage);
            }
            // Clear existing intervals
            if (pollInterval) clearInterval(pollInterval);
            if (channelStatsInterval) clearInterval(channelStatsInterval);
            
            // Stream stats (viewers & likes) - every 10 seconds
            if (currentStream && currentStream.id && liveChatId) {
                // Get stream stats immediately
                getStreamStats();
                // Then update every 10 seconds
                pollInterval = setInterval(() => {
                    getStreamStats();
                }, 10000);
            }
            
            // Channel stats (subscribers) - every 30 minutes
            if (effectiveChannelIdToUse) {
                // Get channel stats immediately
                getChannelStats(effectiveChannelIdToUse);
                // Then update every 30 minutes
                channelStatsInterval = setInterval(() => {
                    getChannelStats(effectiveChannelIdToUse);
                }, 30 * 60 * 1000); // 30 minutes
            }
            console.log('Connection process complete for target:', channelDisplayNameToUse);
			const channelInput = document.getElementById('channel-input');
            if (channelInput.value && channelToUse) channelInput.value = '';
        } catch (error) {
            console.error('Error connecting to YouTube:', error);
            updateHeaderInfo(username, 'Connection failed');
            const textarea = document.querySelector("#textarea");
            if (textarea) {
                textarea.innerHTML = '';
                var span = document.createElement("div");
                span.style.color = "red";
                span.innerText = `Error: ${error.message}`;
                textarea.appendChild(span);
            }
            document.getElementById('viewer-count').textContent = '-';
            document.getElementById('subscriber-count').textContent = '-';
            document.getElementById('likes-count').textContent = '-';
        }
    }
	
	function pushMessage(data) {
		window.dispatchEvent(new CustomEvent('youtubeMessage', { 
			detail: data, 
			bubbles: true 
		}));
	}
	

	function containsShorts(url) {
		const urlObj = new URL(url);
		const searchParams = new URLSearchParams(urlObj.search);
		const hasShortsParam = searchParams.has('shorts');
		const hasShortsPath = urlObj.pathname.includes('/shorts');
		return hasShortsParam || hasShortsPath;
	}
	
	var youtubeShorts = false;
	if (containsShorts(window.location.href)){
		youtubeShorts = true;
	}

	function processMessage(messageData) {
		try {
			const textarea = document.querySelector("#textarea");
			var span = document.createElement("div");
			let badgeHtml = '';
			let badgeText = '';
			
			if (messageData.isChatOwner) { badgeHtml += '<span class="chat-badge" title="Channel Owner"></span>'; badgeText = ""; }
			if (messageData.isChatModerator) { badgeHtml += '<span class="chat-badge" title="Moderator"></span>'; badgeText = ""; }
			if (messageData.isChatSponsor) { badgeHtml += '<span class="chat-badge" title="Member"></span>'; badgeText = ""; }

			//console.log("Processing message:", messageData.message, "EMOTELIST available:", !!EMOTELIST);
			if (!messageData.message && messageData.message !== '') {
				console.warn('Message data missing message property:', messageData);
			}
			const messageText = messageData.message || '';
			const messageWithEmojis = replaceEmojis(messageText);

			span.innerHTML = `${badgeHtml}<strong>${messageData.authorName}</strong>: ${messageWithEmojis}`;
			textarea.appendChild(span);
			while (textarea.childNodes.length > 20) {
				textarea.removeChild(textarea.firstChild);
			}
			textarea.scrollTop = textarea.scrollHeight;
			if (!messageData.skipEvent && messageWithEmojis) {
				pushMessage({
					chatname: messageData.authorName,
					chatbadges: (badgeText ? [{"type":"text", "text": badgeText}] : ""),
					userid: messageData.authorChannelId,
					backgroundColor: "",
					textColor: "",
					chatmessage: messageWithEmojis, // Use the version with emojis replaced
					chatimg: messageData.profileImageUrl || "",
					hasDonation: "",
					membership: messageData.isChatSponsor ? "member" : "",
					type: youtubeShorts ? "youtubeshorts" : "youtube",
					textonly: settings.textonlymode || false // Pass the setting to the extension
				});
			}
		} catch (e) {
			console.error('Error processing message:', e);
		}
	}
	
    function processSuperChat(superChatData) {
		try {
			addEvent(`Super Chat: ${superChatData.authorName} - ${superChatData.amount}`);
			const textarea = document.querySelector("#textarea");
			var span = document.createElement("div");
			span.innerHTML = `<strong>${superChatData.authorName}</strong> <span>${superChatData.amount}</span>: ${superChatData.message || ''}`;
			textarea.appendChild(span);
			if (textarea.childNodes.length > 100) textarea.childNodes[0].remove();
			textarea.scrollTop = textarea.scrollHeight;
			pushMessage({
				chatname: superChatData.authorName,
				chatbadges: "",
				userid: superChatData.authorChannelId,
				backgroundColor: "",
				textColor: "#111",
				chatmessage: superChatData.message || '',
				chatimg: superChatData.profileImageUrl || "",
				hasDonation: superChatData.amount,
				membership: "",
				type: youtubeShorts ? "youtubeshorts" : "youtube",
				event: "donation"
			});
		} catch (e) {
			console.error('Error processing super chat:', e);
		}
	}
	
	function processMembership(membershipData) {
		try {
			addEvent(`New Member: ${membershipData.authorName} - ${membershipData.level}`);
			const textarea = document.querySelector("#textarea");
			var span = document.createElement("div");
			span.innerHTML = `<strong>${escapeHtml(membershipData.authorName)}</strong> <span>joined as a member (${membershipData.level})</span>`;
			textarea.appendChild(span);
			
			while (textarea.childNodes.length > 20) {
				textarea.removeChild(textarea.firstChild);
			}
			textarea.scrollTop = textarea.scrollHeight;
			
			pushMessage({
				chatname: escapeHtml(membershipData.authorName),
				chatbadges: [{"type":"text", "text": ""}],
				userid: membershipData.authorChannelId,
				backgroundColor: "",
				textColor: "",
				chatmessage: `joined as a member (${membershipData.level})`,
				chatimg: membershipData.profileImageUrl || "",
				hasDonation: "",
				membership: "new_member",
				subtitle: membershipData.level,
				type: youtubeShorts ? "youtubeshorts" : "youtube",
				event: "new_member",
				textonly: settings.textonlymode || false
			});
		} catch (e) {
			console.error('Error processing membership:', e);
		}
	}
	function updateStats(type, data) {
		switch(type) {
			case 'viewer_update':
				document.getElementById('viewer-count').textContent = data.meta;
				if (settings.showviewercount || settings.hypemode){
					pushMessage({ type: youtubeShorts ? "youtubeshorts" : "youtube", event: 'viewer_update', meta: data.meta });
				}
				break;
			case 'subscriber_update':
				document.getElementById('subscriber-count').textContent = data.meta;
				break;
			case 'likes_update':
				document.getElementById('likes-count').textContent = data.meta;
				//pushMessage({ type: youtubeShorts ? "youtubeshorts" : "youtube", event: 'likes_update', meta: data.meta });
				break;
		}
	}
    function addEvent(text) {
        const eventslist = document.getElementById('events-list');
        const event = document.createElement('div');
        event.className = 'event-item'; event.textContent = text;
        eventslist.insertBefore(event, eventslist.firstChild);
        while (eventslist.children.length > 10) eventslist.removeChild(eventslist.lastChild);
    }
    function updateHeaderInfo(currentUsername, targetName) {
        const currentUserElement = document.getElementById('current-user');
        const currentChannelElement = document.getElementById('current-channel');
        if (currentUserElement) currentUserElement.textContent = currentUsername || 'Not signed in';
        if (currentChannelElement) currentChannelElement.textContent = targetName || 'No target';
    }
	function initializePage() {
		
		urlParams = new URLSearchParams(window.location.search);
		hashParams = new URLSearchParams(window.location.hash.slice(1));
		const urlVideoIdParam = urlParams.get("videoId") || urlParams.get("video_id") || urlParams.get("v") || hashParams.get("videoId");
		const urlChannelParam = urlParams.get("channel") || urlParams.get("username") || urlParams.get("c") || hashParams.get("channel");
		if (urlVideoIdParam || urlChannelParam) {
			sessionStorage.setItem("youtubeRedirectVideoId", urlVideoIdParam || "");
			sessionStorage.setItem("youtubeRedirectChannel", urlChannelParam || "");
		}
		if (urlVideoIdParam) {
			videoId = urlVideoIdParam;
			channel = '';
			localStorage.setItem("youtubeVideoId", videoId);
			localStorage.removeItem("youtubeChannel");
		} else if (urlChannelParam) {
			channel = urlChannelParam;
			videoId = '';
			localStorage.setItem("youtubeChannel", channel);
			localStorage.removeItem("youtubeVideoId");
		} else {
			videoId = localStorage.getItem("youtubeVideoId") || "";
			if (videoId) {
				channel = '';
				localStorage.removeItem("youtubeChannel");
			} else {
				channel = localStorage.getItem("youtubeChannel") || "";
			}
		}
		const signOutButton = document.getElementById('sign-out-button');
		if (signOutButton) signOutButton.addEventListener('click', signOut);
		const authLink = document.getElementById('auth-link');
		if (authLink) {
			authLink.addEventListener('click', function(e) {
				e.preventDefault();
				window.location.href = authUrl();
			});
		}
		document.addEventListener('visibilitychange', handleVisibilityChange);
		isPageVisible = document.visibilityState === 'visible';
		const sendButton = document.querySelector('#sendmessage');
		if (sendButton) sendButton.onclick = handleSendMessage;
		const inputText = document.querySelector('#input-text');
		if (inputText) inputText.addEventListener('keypress', handleEnterKey);
		const connectButton = document.getElementById('connect-button');
		if (connectButton) connectButton.addEventListener('click', handleConnect);
		const changeButton = document.getElementById('change-button');
		if (changeButton) {
			changeButton.addEventListener('click', function() {
				clearPolling();
				updateHeaderInfo(username, 'No target (Ready to connect)');
				document.getElementById('textarea').innerHTML = '<div>Connection cleared. Enter new channel name or video ID and click Connect.</div>';
				document.getElementById('viewer-count').textContent = '-';
				document.getElementById('subscriber-count').textContent = '-';
				document.getElementById('likes-count').textContent = '-';
				document.getElementById('events-list').innerHTML = '';
				channel = '';
				videoId = '';
				localStorage.removeItem('youtubeChannel');
				localStorage.removeItem('youtubeVideoId');
				// Reset connect button
				const connectButton = document.getElementById('connect-button');
				if (connectButton) {
					connectButton.textContent = 'Connect';
					connectButton.style.backgroundColor = '#2255dd';
				}
			});
		}
		const channelInput = document.getElementById('channel-input');
		const videoInput = document.getElementById('video-input');
		if (channelInput) {
			channelInput.addEventListener('keypress', function(event) {
				if (event.key === 'Enter') handleConnect();
			});
		}
		if (videoInput) {
			videoInput.addEventListener('keypress', function(event) {
				if (event.key === 'Enter') handleConnect();
			});
		}
		if (urlParams.has('code')) {
			handleAuthCallback();
			return;
		}
		setupSettingsListener();
		const storedToken = getStoredToken();
		if (storedToken) {
			verifyAndUseToken(storedToken);
		} else if (window.location.hash && window.location.hash.includes('access_token')) {
			parseFragment(window.location.hash);
		} else {
			showAuthButton();
		}
		
		loadEmojiData().catch(error => {
		  console.error('Failed to load emoji data:', error);
		});
	}
	
	function setupSettingsListener() {
		window.addEventListener('settingsChanged', function(e) {
			if (e.detail) {
				if ("EMOTELIST" in e.detail) {
					EMOTELIST = e.detail.EMOTELIST;
					console.log('EMOTELIST updated:', EMOTELIST);
				}
				if ("settings" in e.detail) {
					settings = e.detail.settings;
					console.log('settings updated:', settings);
				}
			}
		});
	}
	
	
	async function fetchWithTimeout(URL, timeout = 8000, headers = false) {
		const controller = new AbortController();
		const timeout_id = setTimeout(() => controller.abort(), timeout);
		try {
			const options = { signal: controller.signal };
			if (headers) {
				options.headers = new Headers();
				if (typeof headers === 'object') {
					if (headers.method) {
						options.method = headers.method;
						delete headers.method;
					}
					if (headers.body !== undefined) {
						options.body = headers.body;
						delete headers.body;
					}
					Object.entries(headers).forEach(([key, value]) => {
						if (value !== undefined) options.headers.set(key, value);
					});
				}
			}
			//console.log('Fetching:', URL, options);
			const response = await fetch(URL, options);
			clearTimeout(timeout_id);
			//console.log('Response status:', response.status, response.statusText);
			if (!response.ok) {
				const errorText = await response.text();
				console.error('API error response:', errorText);
				throw new Error(`API error: ${response.status} ${response.statusText}`);
			}
			return response;
		} catch (e) {
			clearTimeout(timeout_id);
			if (e.name === 'AbortError') {
				console.error('Request timed out after', timeout, 'ms:', URL);
				throw new Error(`Request timed out after ${timeout}ms: ${URL}`);
			} else {
				console.error('Fetch error:', e.name, e.message, URL);
				throw e;
			}
		} finally {
			clearTimeout(timeout_id);
		}
	}
    document.addEventListener('DOMContentLoaded', initializePage);
} catch(e) {
    console.error('YouTube integration error:', e);
    const body = document.querySelector('body');
    if (body) {
        const errorDiv = document.createElement('div');
        errorDiv.style.color = 'red';
        errorDiv.style.padding = '20px';
        errorDiv.textContent = 'A critical error occurred with the YouTube integration. Please check the console for details.';
    }
}
</script>
</body>
</html>