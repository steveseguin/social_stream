<html>
<head>
	<title>Social Stream Ninja</title>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
	<meta content="utf-8" http-equiv="encoding" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
	<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:; worker-src 'self' 'unsafe-inline' 'unsafe-eval' blob:;"/>
	<link rel="stylesheet" href="https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="main.css" />
	<style>
		.session-item {
			padding: 10px 15px;
			margin: 5px 0;
			border-radius: 6px;
			cursor: pointer;
			display: flex;
			justify-content: space-between;
			align-items: center;
			background: rgba(255, 255, 255, 0.05);
			transition: all 0.2s ease;
		}
		
		.session-item:hover {
			background: rgba(255, 255, 255, 0.1);
		}
		
		.session-item.selected {
			background: rgba(76, 175, 80, 0.3);
			border: 1px solid rgba(76, 175, 80, 0.6);
		}
		
		.session-item-name {
			font-weight: 500;
		}
		
		.session-item-actions {
			display: flex;
			gap: 10px;
			align-items: center;
		}
		
		.session-remove-btn {
			background: transparent;
			border: none;
			color: #e74c3c;
			cursor: pointer;
			padding: 5px;
			font-size: 16px;
			opacity: 0.7;
			transition: opacity 0.2s;
		}
		
		.session-remove-btn:hover {
			opacity: 1;
		}
		
		.session-remove-btn:disabled {
			opacity: 0.3;
			cursor: not-allowed;
		}
	</style>
</head>
<body>
    <nav id="main-navigation">
        <button class="menu-toggle" onclick="toggleMenu()">â˜°</button>
        <ul>
            <li><a href="#" data-page="streams">ğŸ­ Sources</a></li>
			<li><a href="#" data-page="link-overlay">ğŸ”— Links and Settings</a></li>
			<li><a href="#" data-page="dashboard">ğŸ“° Status and Logs</a></li>
            <li><a href="#" data-page="event-flow-editor">ğŸª¤ Event Flow Editor</a></li>
			<li><a href="#" data-page="vdo-ninja">ğŸ¦ Remote Camera Feed</a></li>
			<li><a href="#" data-page="sessions">ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sessions</a></li>
            </ul>
            <div class="language-selector">
                <select id="language-select" onchange="changeLanguage(this.value)">
                    <option value="en">ğŸ‡ºğŸ‡¸ English</option>
                    <option value="pt-BR">ğŸ‡§ğŸ‡· PortuguÃªs (Brasil)</option>
                    <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                    <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                    <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
                    <option value="it">ğŸ‡®ğŸ‡¹ Italiano</option>
                    <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
                    <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                    <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
                    <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                    <option value="tr">ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e</option>
                </select>
            </div>
    </nav>

    <main id="content-pane">
        <div id="streams-page">
            <div class="addnew">
                <p data-i18n="source.add">Add a new source:</p>
                <span><button onclick="newSourcePrompt('youtube');" data-source-type="youtube-username"><img src="https://socialstream.ninja/sources/images/youtube.png" class="icon"/>YouTube Username</button></span>
                <span><button onclick="newSourceVideoIDPrompt('youtube');" data-source-type="youtube-videoid"><img src="https://socialstream.ninja/sources/images/youtube.png" class="icon"/>YouTube Video ID</button></span>
                <span><button onclick="newSourcePrompt('twitch');" data-source-type="twitch"><img src="https://socialstream.ninja/sources/images/twitch.png" class="icon"/>Twitch Username</button></span>
                <span><button onclick="newSourcePrompt('kick');" data-source-type="kick"><img src="https://socialstream.ninja/sources/images/kick.png" class="icon"/>Kick Username</button></span>
                <span><button onclick="newSourcePrompt('instagramlive');" data-source-type="instagram"><img src="https://socialstream.ninja/sources/images/instagramlive.png" class="icon"/>Instagramlive Username</button></span>
                <span><button onclick="newSourcePrompt('facebook');" data-source-type="facebook"><img src="https://socialstream.ninja/sources/images/facebook.png" class="icon"/>Facebook Username</button></span>
                <span><button onclick="newSourcePrompt('tiktok');" data-source-type="tiktok"><img src="https://socialstream.ninja/sources/images/tiktok.png" class="icon"/>tiktok Username</button></span>
                <span><button onclick="newSourcePrompt('trovo');"><img src="https://socialstream.ninja/sources/images/trovo.png" class="icon"/>trovo Username</button></span>
                <span><button onclick="newSourcePrompt('picarto');"><img src="https://socialstream.ninja/sources/images/picarto.png" class="icon"/>picarto Username</button></span>
                <span><button onclick="newSourcePrompt('dlive');"><img src="https://socialstream.ninja/sources/images/dlive.png" class="icon"/>dlive Username</button></span>
                <span><button onclick="newSourcePrompt('x');"><img src="https://socialstream.ninja/sources/images/x.png" class="icon"/>X.com Username</button></span>
                <span><button onclick="newSourcePrompt('rumble');"><img src="https://socialstream.ninja/sources/images/rumble.png" class="icon"/>Rumble Username</button></span>
                <span><button onclick="newSourceVideoIDPrompt('rumble');"><img src="https://socialstream.ninja/sources/images/rumble.png" class="icon"/>Rumble Video URL</button></span>
                <span><button onclick="newSourcePrompt('beamstream');"><img src="https://socialstream.ninja/sources/images/beamstream.png" class="icon"/>Beamstream Username</button></span>
                <span><button onclick="newSourcePrompt('parti');"><img src="https://socialstream.ninja/sources/images/parti.png" class="icon"/>Parti User ID</button></span>
				<span><button onclick="newSourcePrompt('arenasocial');"><img src="https://socialstream.ninja/sources/images/arenasocial.png" class="icon"/>Arena Social Username</button></span>
                <span class="hidden"><button onclick="newSourcePrompt('pilled');"><img src="https://socialstream.ninja/sources/images/pilled.png" class="icon"/>Pilled Username</button></span>
                <span><button onclick="newSourcePrompt('bilibili');"><img src="https://socialstream.ninja/sources/images/bilibili.png" class="icon"/>BiliBili Stream ID</button></span>
                <span><button onclick="newOtherSourcePrompt('peertube');"><img src="https://socialstream.ninja/sources/images/peertube.png" class="icon"/>Peertube URL</button></span>
                <span><button title="Add a chat source that isn't listed by providing the chat URL" onclick="newOtherSourcePrompt();" data-source-type="other"><img src="https://socialstream.ninja/sources/images/unknown.png" class="icon"/>Other chat sites</button></span>
            </div>

            <div id="sources">
                <h2 style="margin: 10px;" data-i18n="app.title">Social Stream Ninja Standalone</h2>
                <span id='newver' class='hidden'>
                    <h1 data-i18n="app.newversion">NEW VERSION AVAILABLE</h1>
                    <a id="downloadlink" data-i18n="app.download">Download new version here</a>
                </span>
                <p style="margin: 0 0 15px 10px; color: #9d8c8c;">Added Sources:</p>
                </div>
        </div>

        <div id="dashboard-page" style="display:none;">
			<iframe id="frame2" class="loading" style="height:100%;width:100%" aria-hidden="true" allow="clipboard-write;document-domain;encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;accelerometer;midi *;geolocation;autoplay;camera;microphone;fullscreen;gyroscope;shared-array-buffer;" title="Background Service Loader"></iframe>
        </div>
			
		 <div id="link-overlay-page" style="display:none;">
			<iframe id="frame1" class="loading" style="height:100%;width:100%" allow="clipboard-write;document-domain;encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;accelerometer;midi *;geolocation;autoplay;camera;microphone;fullscreen;gyroscope;shared-array-buffer;" ></iframe>
        </div>
		
		 <div id="vdo-ninja-page" style="display:none;">
			<iframe id="frame3" class="loading" style="height:100%;width:100%" allow="clipboard-write;document-domain;encrypted-media;sync-xhr;usb;web-share;cross-origin-isolated;accelerometer;midi *;geolocation;autoplay;camera;microphone;fullscreen;gyroscope;shared-array-buffer;" ></iframe>
        </div>
		
		<div id="sessions-page" style="display:none;">
			<div class="sessions-container">
				<h2 data-i18n="sessions.title">User Sessions</h2>
				<p class="sessions-info" data-i18n="sessions.info">Manage multiple user profiles with separate settings and sources.</p>
				
				<div class="current-session-info">
					<h3 data-i18n="sessions.current">Current Session</h3>
					<div class="session-display">
						<span class="session-name" id="current-session-name">Default Session</span>
						<span class="session-label" data-i18n="sessions.active">Active</span>
					</div>
				</div>
				
				<div class="sessions-list">
					<h3 data-i18n="sessions.available">Available Sessions</h3>
					<div id="sessions-list-container">
						<!-- Sessions will be populated here -->
					</div>
					<button class="new-session-btn" onclick="createNewSession()" data-i18n="sessions.create">
						â• Create New Session
					</button>
					<div class="session-import-export">
						<button class="export-session-btn" onclick="exportCurrentSession()" data-i18n="sessions.export">
							ğŸ’¾ Export Current Session
						</button>
						<button class="import-session-btn" onclick="importSession()" data-i18n="sessions.import">
							ğŸ“‚ Import Session
						</button>
					</div>
				</div>
				
				<div class="session-warnings">
					<p>â„¹ï¸ <strong>Note:</strong> The "Default Session (Original)" contains all your existing sources and settings.</p>
					<p>ğŸ”„ <strong>Switching:</strong> Changing sessions will restart the application.</p>
					<p>âš ï¸ <strong>Important:</strong> Each session has completely separate settings, sources, and stored data.</p>
				</div>
			</div>
		</div>
			
	</main>

	<div id="sourceTemplate" class="hidden entry">
		<img data-sourceicon />
		<span>
			<div>
				<span data-channelname></span>
				<span data-sourcename></span>
			</div>
			<input data-sourceurl disabled class="white hidden" />
		</span>

		<div class="control-panel">
			<div class="auto-activate-toggle">
				<div class="toggle-switch-container">
					<label class="toggle-switch">
						<input type="checkbox" data-state-key="autoActivate">
						<span class="slider"></span>
					</label>
					<span class="toggle-label">Auto-activate on startup</span>
				</div>
			</div>
		</div>

		<span class='ws-status hidden'>Websocket Activated</span>

		<div class="entry-actions-main">
			<button onclick="activateSource(this)" data-activatehtml>â–¶ï¸ Activate source</button>
			<button onclick="signin(this)" title="Sign-in friendly compatible page" data-signin>ğŸ”‘ Sign-in</button>
			<button onclick="showTips(this)" title="Show tips for this platform" class="hidden help-btn" data-showtips>â“ Help!</button>
		</div>

		<div class="entry-actions-live">
			<button onclick="refreshWindow(this)" title="Reload this source" data-reloadhtml class="hidden icon-button">ğŸ”„</button>
			<button onclick="toggleSourceVisibility(this)" title="Toggle the visibility of this source" data-togglehtml class="hidden icon-button">ğŸ‘ï¸</button>
			<button onclick="toggleSourceMute(this)" title="Pause/mute the video in this source" data-togglemute class="hidden icon-button">ğŸ”‡</button>
			<button onclick="stopThis(this)" title="Stop and close this source" data-stophtml class="hidden icon-button">â¹ï¸</button>
		</div>

		<button title="Additional settings for this source" class="settings-btn button">âš™ï¸</button>
		<div class="settings-menu">
			<div class="settings-menu-section">
				<div class="settings-menu-header">Additional Controls</div>
				<div class="settings-menu-item" onclick="clearThis(this)" data-clearcache>
					ğŸ§¹ Clear cache & storage
				</div>
				<div class="settings-menu-item youtube-type-toggle hidden" onclick="toggleYouTubeType(this)">
					ğŸ”„ Switch to <span class="toggle-type-text">YouTube</span>
				</div>
				<div class="settings-menu-item" onclick="openUserAgentSettings(this)">
					ğŸŒ User Agent Settings
				</div>
				<div class="settings-menu-item" onclick="openSessionSettings(this)">
					ğŸ” Browser Session Settings
				</div>
				</div>
			<div class="settings-menu-section">
				<div class="settings-menu-header">Source Management</div>
				<div class="settings-menu-item danger" onclick="deleteThis(this)">
					ğŸ—‘ï¸ Remove source
				</div>
			</div>
		</div>
	</div>

    <div id="groupTemplate" class="hidden entry" data-is-group-header="true">
        <img data-sourceicon />
        <span>
            <div>
                <span data-channelname></span>
                <span data-targetname style="font-size: 0.8em; opacity: 0.7;"></span>
            </div>
        </span>
        <div class="control-panel">
             <div class="auto-activate-toggle">
				<div class="toggle-switch-container">
					<label class="toggle-switch">
						<input type="checkbox" data-state-key="autoActivate">
						<span class="slider"></span>
					</label>
					<span class="toggle-label">Auto-activate group</span>
				</div>
			</div>
        </div>
        <div class="button-group">
            <button onclick="handleYouTubeGroupActivationPrompt(this)">Select Live Sources</button>
            <button onclick="handleYouTubeGroupAutoActivation(this)">Auto-find & Activate</button>
        </div>
         <div class="group-actions">
            <button class="group-control" title="Toggle All Streams Visibility" onclick="toggleGroupVisibility(this)">ğŸ‘ï¸</button>
            <button class="group-control" title="Toggle All Streams Mute" onclick="toggleGroupMute(this)">ğŸ”Š</button>
            <button class="group-control" title="Stop All Streams" onclick="stopAllStreamsInGroup(this)">â¹ï¸</button>
            <button class="group-control" title="Reload All Streams" onclick="reloadAllStreamsInGroup(this)">ğŸ”„</button>
            <button title="Additional settings for this group" class="settings-btn button">âš™ï¸</button>
            <div class="settings-menu">
                <div class="settings-menu-section">
					<div class="settings-menu-header">Group Management</div>
					<div class="settings-menu-item danger" onclick="deleteThis(this)">
						ğŸ—‘ï¸ Remove group & its sources
					</div>
				</div>
            </div>
        </div>
        <div class="stream-group">
            </div>
    </div>


    <div id="tipsModal" class="modal hidden">
        <div class="modal-content tips-modal-content">
            <h2 id="tipsModalTitle">Tips</h2>
            <div id="tipsModalContent"></div>
            <button class="btn-primary" onclick="closeTipsModal()">Close</button>
        </div>
    </div>

    <div class="modal hidden" id="modal">
        <div class="modal-content">
            <h2>Unknown site or site not supported</h2>
            If the URL provided is for a custom domain, please select which source type is to be used:
            <select data-type="dropdown">
                <option value="option1">Option 1</option>
                <option value="option2">Option 2</option>
                <option value="option3">Option 3</option>
                </select>
            <button data-type="submit">Select</button><button data-type="cancel">Cancel</button>
        </div>
    </div>

    <div class="yt-stream-modal" style="display:none;" id="ytStreamModal">
        <div class="yt-stream-modal-content"> 
            <span class="yt-stream-close">Ã—</span>
            <h2>Available Live Streams</h2>
            <div class="yt-stream-list" id="ytStreamList"></div>
            <div class="yt-stream-buttons">
                <button class="yt-stream-button secondary" id="ytCancelButton">Cancel</button>
                <button class="yt-stream-button primary" id="ytActivateButton">Activate Selected</button>
            </div>
        </div>
    </div>
    
    <!-- User Agent Settings Modal -->
    <div class="modal hidden" id="userAgentModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>User Agent Settings</h2>
            <div style="margin-bottom: 20px;">
                <label for="userAgentSelect" style="display: block; margin-bottom: 8px; font-weight: bold;">Select User Agent:</label>
                <select id="userAgentSelect" style="width: 100%; padding: 8px; margin-bottom: 10px;">
                    <option value="AUTO">AUTO (Use config file)</option>
                </select>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input type="text" id="customUserAgentInput" placeholder="Enter custom user agent..." style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                    <button onclick="addCustomUserAgent()">Add</button>
                </div>
                <div id="customUserAgentsList" style="max-height: 200px; overflow-y: auto; margin-top: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 10px;"></div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeUserAgentModal()" style="background: #95a5a6;">Cancel</button>
                <button onclick="saveUserAgentSelection()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="modal hidden" id="sessionModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>Browser Session Settings</h2>
            <div style="margin-bottom: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select Browser Session:</label>
                    <small style="color: #ddd; display: block; margin-bottom: 10px;">Sessions allow you to be logged into different accounts on the same platform</small>
                </div>
                <div id="sessionsList" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 10px;">
                    <!-- Sessions will be populated here -->
                </div>
                <div style="margin-top: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #9d8c8c;">Create New Session:</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="customSessionName" placeholder="Session name (e.g., 'work-account')" style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                        <button onclick="addCustomSession()">Create</button>
                    </div>
                </div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeSessionModal()" style="background: #95a5a6;">Cancel</button>
                <button onclick="saveSessionSelection()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="toast-container" id="toastContainer"></div>
	
<script type="text/javascript" src="state.js"></script>
<script type="text/javascript" src="libs.js"></script>
<script type="text/javascript" src="manifest.js"></script>
<script type="text/javascript" src="thumbnail.js"></script>
<script type="text/javascript" src="youtube.js"></script>
<script>
var config = getDefaultConfig();
let configReady = false;
const storedConfig = localStorage.getItem('config');
if (storedConfig) {
	try {
		config = JSON.parse(storedConfig);
	} catch (e) {
		console.warn("Failed to parse stored config, using default.");
		config = getDefaultConfig();
	}
}

var urlParams = new URLSearchParams(window.location.search);
var devmode = urlParams.has("devmode");
var sourcemode = urlParams.get("sourcemode") || false;
// Ensure sourcemode has file:// protocol if it's a local path
if (sourcemode && !sourcemode.startsWith('http') && !sourcemode.startsWith('file://')) {
    if (sourcemode.match(/^[A-Za-z]:\//)) {
        // Windows path
        sourcemode = `file:///${sourcemode}`;
    } else if (sourcemode.startsWith('/')) {
        // Unix path
        sourcemode = `file://${sourcemode}`;
    }
}
var isBetaMode = false;
var session = {};
var ipcRenderer = null;

// Check if contextBridge exposed electron API (for windows with contextIsolation: true)
if (window.electron && window.electron.ipcRenderer) {
    console.log('[Electron] Found electron API via contextBridge');
    ipcRenderer = window.electron.ipcRenderer;
}
var localServer = "";

// Universal IPC Promise Handler
class UniversalIPCHandler {
    constructor(defaultTimeout = 15000) {
        this.callbacks = new Map();
        this.defaultTimeout = defaultTimeout;
        this.nextId = 1;
        this.maxCallbacks = 100; // Prevent unlimited growth
        this.metrics = {
            sent: 0,
            completed: 0,
            failed: 0,
            timedOut: 0
        };
        
        // Single listener for ALL IPC responses
        if (ipcRenderer) {
            ipcRenderer.on('ipc-response', (event, data) => {
                this.handleResponse(data);
            });
        }
        
        // Periodic cleanup - more aggressive
        this.cleanupInterval = setInterval(() => this.cleanup(), 10000); // Every 10 seconds
    }
    
    // Send any IPC message with optional custom timeout
    async send(channel, data, options = {}) {
        if (!ipcRenderer) {
            throw new Error('IPC not available');
        }
        
        const timeout = options.timeout || this.defaultTimeout;
        
        return new Promise((resolve, reject) => {
            // Check if we've hit the callback limit
            if (this.callbacks.size >= this.maxCallbacks) {
                // Force cleanup of oldest callbacks
                this.forceCleanup();
                
                // If still at limit, reject
                if (this.callbacks.size >= this.maxCallbacks) {
                    this.metrics.failed++;
                    reject(new Error(`IPC callback limit reached (${this.maxCallbacks}). Too many pending requests.`));
                    return;
                }
            }
            
            const callbackId = `${channel}-${this.nextId++}-${Date.now()}`;
            
            const timeoutId = setTimeout(() => {
                const callback = this.callbacks.get(callbackId);
                if (callback) {
                    this.callbacks.delete(callbackId);
                    this.metrics.timedOut++;
                    reject(new Error(`IPC timeout: ${channel} after ${timeout}ms`));
                }
            }, timeout);
            
            this.callbacks.set(callbackId, {
                resolve,
                reject,
                timeoutId,
                channel,
                timestamp: Date.now()
            });
            
            this.metrics.sent++;
            
            // Send with metadata
            ipcRenderer.send('ipc-request', {
                channel,
                callbackId,
                data,
                timestamp: Date.now()
            });
        });
    }
    
    handleResponse(response) {
        const { callbackId, error, result } = response;
        const callback = this.callbacks.get(callbackId);
        
        if (callback) {
            clearTimeout(callback.timeoutId);
            this.callbacks.delete(callbackId);
            
            if (error) {
                this.metrics.failed++;
                callback.reject(new Error(error));
            } else {
                this.metrics.completed++;
                callback.resolve(result);
            }
            
            // Log slow responses
            const duration = Date.now() - callback.timestamp;
            if (duration > 1000) {
                console.warn(`Slow IPC response for ${callback.channel}: ${duration}ms`);
            }
        }
    }
    
    // Cleanup old callbacks
    cleanup() {
        const now = Date.now();
        let cleaned = 0;
        
        this.callbacks.forEach((callback, id) => {
            if (now - callback.timestamp > 30000) { // 30 seconds (reduced from 60)
                clearTimeout(callback.timeoutId);
                callback.reject(new Error('Callback expired during cleanup'));
                this.callbacks.delete(id);
                cleaned++;
            }
        });
        
        if (cleaned > 0) {
            console.log(`IPC cleanup: removed ${cleaned} expired callbacks`);
        }
    }
    
    forceCleanup() {
        // Remove oldest callbacks until we're under 75% of limit
        const targetSize = Math.floor(this.maxCallbacks * 0.75);
        const sortedCallbacks = Array.from(this.callbacks.entries())
            .sort((a, b) => a[1].timestamp - b[1].timestamp);
        
        let cleaned = 0;
        while (this.callbacks.size > targetSize && sortedCallbacks.length > 0) {
            const [id, callback] = sortedCallbacks.shift();
            clearTimeout(callback.timeoutId);
            callback.reject(new Error('Callback forcefully cleaned due to limit'));
            this.callbacks.delete(id);
            cleaned++;
        }
        
        if (cleaned > 0) {
            console.warn(`IPC force cleanup: removed ${cleaned} callbacks to prevent memory overflow`);
        }
    }
    
    // Retry capability
    async sendWithRetry(channel, data, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await this.send(channel, data);
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                console.log(`Retry ${i + 1}/${maxRetries} for ${channel}`);
                await new Promise(r => setTimeout(r, 1000 * (i + 1)));
            }
        }
    }
    
    // Cleanup all resources
    destroy() {
        // Clear the interval
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        
        // Clear all pending callbacks
        this.callbacks.forEach((callback, id) => {
            clearTimeout(callback.timeoutId);
            callback.reject(new Error('IPC handler destroyed'));
        });
        this.callbacks.clear();
        
        console.log('IPC handler destroyed, metrics:', this.metrics);
    }
    
    // Get metrics
    getMetrics() {
        return {
            ...this.metrics,
            pending: this.callbacks.size,
            successRate: this.metrics.sent > 0 
                ? ((this.metrics.completed / this.metrics.sent) * 100).toFixed(1) + '%'
                : '0%'
        };
    }
}

// Create global instance
window.ipc = new UniversalIPCHandler();

// Function to rewrite old Kick URLs to new format
function rewriteKickUrl(url) {
    // Check if it's an old Kick chatroom URL
    const oldKickPattern = /^https:\/\/kick\.com\/([^\/]+)\/chatroom$/;
    const match = url.match(oldKickPattern);
    
    if (match) {
        // Rewrite to new format
        const username = match[1];
        const newUrl = `https://kick.com/popout/${username}/chat`;
        console.log(`Rewriting old Kick URL: ${url} -> ${newUrl}`);
        return newUrl;
    }
    
    // Return original URL if no rewriting needed
    return url;
}

// --- Core UI Update Functions ---
function updateSourceUI(element, source) {
    if (!element || !source) return;

    // Update data-target attribute
    element.dataset.target = source.target;
    
    element.querySelector("[data-sourceicon]").src = `https://socialstream.ninja/sources/images/${source.target || "unknown"}.png`;
    element.querySelector("[data-sourceicon]").title = source.target || "unknown";
    element.querySelector("[data-channelname]").textContent = source.username || "";
    element.querySelector("[data-sourcename]").textContent = source.videoId || "";
    const sourceUrlInput = element.querySelector("[data-sourceurl]");
    if (sourceUrlInput) {
        sourceUrlInput.value = source.url || "";
        sourceUrlInput.classList.toggle("hidden", !source.url);
    }
    
    if (tipsContent[source.target]) {
        element.querySelector("[data-showtips]")?.classList.remove("hidden");
    } else {
        element.querySelector("[data-showtips]")?.classList.add("hidden");
    }
    
    // Hide sign-in button when in websocket mode
    const signinButton = element.querySelector("[data-signin]");
    if (signinButton) {
        const isWebsocketMode = source.connectionMode === 'websocket' || 
                               source.connectionMode === 'tiktok-websocket';
        signinButton.classList.toggle("hidden", isWebsocketMode);
    }

    const visibilityControl = element.querySelector('[data-togglehtml]');
    if (visibilityControl) {
        visibilityControl.textContent = source.isVisible ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
        // Hide for TikTok websocket mode or when not active with a window
        const isTikTokWebsocket = source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket';
        visibilityControl.classList.toggle('hidden', isTikTokWebsocket || source.status !== 'active' || !source.vid);
    }
    
    const muteControl = element.querySelector('[data-togglemute]');
    if (muteControl) {
        muteControl.textContent = source.isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        muteControl.classList.toggle('active', source.isMuted);
        // Hide only for TikTok websocket mode (which doesn't support mute)
        const isTikTokWebsocket = source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket';
        muteControl.classList.toggle('hidden', isTikTokWebsocket);
    }
    
    const autoActivateCheckbox = element.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = source.autoActivate || false;
        
        // Set up the change handler if not already set
        if (!autoActivateCheckbox.hasAttribute('data-handler-set')) {
            autoActivateCheckbox.setAttribute('data-handler-set', 'true');
            autoActivateCheckbox.onchange = () => {
                stateManager.updateSource(source.id, { autoActivate: autoActivateCheckbox.checked });
                
                // Start or stop auto-checking for Rumble sources
                if (source.target === 'rumble') {
                    if (autoActivateCheckbox.checked) {
                        startRumbleAutoCheck(source.id);
                    } else {
                        stopRumbleAutoCheck(source.id);
                        // Clear video ID and chat ID when auto-activate is turned off for username-based sources
                        if (source.username && (source.videoId || source.chatId)) {
                            stateManager.updateSource(source.id, { videoId: null, chatId: null, url: null });
                        }
                    }
                }
            };
        }
    }

    const wsStatusElement = element.querySelector('.ws-status');
    if (source.connectionMode === 'websocket' || source.connectionMode === 'tiktok-websocket') {
        if (source.status === 'active' && source.wssId) {
            updateConnectionStatus(element, 'connected');
        } else if (source.status === 'inactive' && wsStatusElement && !wsStatusElement.classList.contains('error')) {
            updateConnectionStatus(element, 'clear');
        }
    } else {
         updateConnectionStatus(element, 'clear');
    }
    
    const activateButton = element.querySelector('[data-activatehtml]');
    const stopButton = element.querySelector('[data-stophtml]');
    const reloadButton = element.querySelector('[data-reloadhtml]'); 

    if (source.status === 'active' && (source.vid || source.wssId)) {
        activateButton?.classList.add('hidden');
        stopButton?.classList.remove('hidden');
        
        // Hide reload button for TikTok websocket mode
        const isTikTokWebsocket = source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket';
        if (reloadButton) {
            reloadButton.classList.toggle('hidden', isTikTokWebsocket || !source.vid);
        }
        
        element.dataset.vid = source.vid; 
    } else {
        activateButton?.classList.remove('hidden');
        stopButton?.classList.add('hidden');
        reloadButton?.classList.add('hidden'); 
        delete element.dataset.vid;
    }
    updateSourceUIAfterModeChange(element, source.connectionMode, (source.status === 'active'));
    
    // Show/hide YouTube type toggle based on source type and status
    const youtubeTypeToggle = element.querySelector('.youtube-type-toggle');
    if (youtubeTypeToggle) {
        if ((source.target === 'youtube' || source.target === 'youtubeshorts') && source.status !== 'active') {
            youtubeTypeToggle.classList.remove('hidden');
            const toggleText = youtubeTypeToggle.querySelector('.toggle-type-text');
            if (toggleText) {
                toggleText.textContent = source.target === 'youtube' ? 'YouTube Shorts' : 'YouTube';
            }
        } else {
            youtubeTypeToggle.classList.add('hidden');
        }
    }
}

function updateGroupUI(element, group) {
    if (!element || !group) return;

    element.querySelector("[data-sourceicon]").src = `https://socialstream.ninja/sources/images/${group.target || "unknown"}.png`;
    element.querySelector("[data-sourceicon]").title = group.target;
    element.querySelector("[data-channelname]").textContent = group.username || "";
    element.querySelector("[data-targetname]").textContent = group.target || "";

    const autoActivateCheckbox = element.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = group.autoActivate;
    }
    
    const visibilityButton = element.querySelector('.group-actions button[title="Toggle All Streams Visibility"]');
    if (visibilityButton) {
        visibilityButton.textContent = group.groupVisible ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
    }
    const muteButton = element.querySelector('.group-actions button[title="Toggle All Streams Mute"]');
    if (muteButton) {
        muteButton.textContent = group.groupMuted ? 'ğŸ”‡' : 'ğŸ”Š';
    }
    
    // Update the connection mode in the settings menu
    const settingsMenu = element.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.querySelectorAll('[data-action^="group-"]').forEach(item => {
            item.classList.remove('active');
        });
        const activeItem = settingsMenu.querySelector(`[data-action="group-${group.connectionMode || 'classic'}-mode"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
}


// --- Element Creation Functions ---
function createSourceElement(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source) {
        console.error("createSourceElement: Source not found in stateManager for ID:", sourceId);
        return null;
    }
    
    const ele = document.getElementById("sourceTemplate").cloneNode(true);
    ele.id = `source-${sourceId}`; 
    ele.dataset.sourceId = sourceId; 
    ele.dataset.target = source.target; 
    
    ele.classList.remove("hidden");
    
    updateSourceUI(ele, source);
    setupSourceControls(ele); 
    
    // Force mode selector to be visible for sources that support it
    const modeSelector = ele.querySelector('.mode-selector');
    if (modeSelector) {
        const target = source.target;
        // Check if platform supports websockets
        const hasWebSocketSupport = 
            target.startsWith('youtube') || 
            target === 'tiktok' ||
            (manifest?.content_scripts?.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            ) || false);
            
        if (hasWebSocketSupport) {
            modeSelector.classList.remove('hidden');
        }
    }

    return ele;
}

function createGroupElement(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group) {
        console.error("createGroupElement: Group not found in stateManager for ID:", groupId);
        return null;
    }

    const ele = document.getElementById("groupTemplate").cloneNode(true);
    ele.id = `group-${groupId}`; 
    ele.dataset.groupId = groupId; 
    ele.dataset.target = group.target; 
    ele.dataset.username = group.username; 

    ele.classList.remove("hidden");
    
    updateGroupUI(ele, group);
    setupGroupControls(ele); 

    const streamsContainer = ele.querySelector('.stream-group');
    if (streamsContainer) {
        console.log("Creating group element for:", groupId, "streams:", group.streams);
        group.streams.forEach(sourceId => {
            if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                console.log("Creating source element for stream:", sourceId);
                const sourceElement = createSourceElement(sourceId);
                if (sourceElement) {
                    console.log("Appending source element to group:", sourceId);
                    streamsContainer.appendChild(sourceElement);
                } else {
                    console.error("Failed to create source element for:", sourceId);
                }
            }
        });
    }
    return ele;
}

/* Modified createYouTubeEntry */
async function createYouTubeEntry(streamData, usernameForGroup, isShortSelected) {
    const target = isShortSelected ? 'youtubeshorts' : 'youtube';
    
    let group = stateManager.getGroups().find(g => g.username === usernameForGroup && g.target === target);
    let groupId = group ? group.id : null;

    if (!groupId) {
        console.warn(`Group for ${usernameForGroup} (${target}) not found. Creating now.`);
        groupId = stateManager.addGroup({ 
            target, 
            username: usernameForGroup, 
            isChannel: (usernameForGroup.startsWith('UC') || usernameForGroup.startsWith('@') ? true : false),
            autoActivate: false 
        });
        // The groupAdded listener will handle creating the group DOM element.
        // Wait for the DOM to potentially update.
        await Promise.resolve();
    }
    
    if (!groupId) {
         console.error("Cannot add YouTube entry: Failed to find or create a group ID for username:", usernameForGroup);
         return null;
    }
    const parentGroup = stateManager.getGroup(groupId);

    // Check if YouTube supports WebSockets
    let supportsWSS = false;
    if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }

    const sourceDataObject = {
        target: target,
        videoId: streamData.videoId,
        username: streamData.channelTitle || usernameForGroup,
        url: `https://www.youtube.com/live_chat?is_popout=1&v=${streamData.videoId}${isShortSelected ? '&shorts' : ''}`,
        isAutoDiscovered: true,
        groupId: groupId,
        title: streamData.title, 
        connectionMode: parentGroup?.connectionMode || 'classic',
        isVisible: parentGroup?.groupVisible !== undefined ? parentGroup.groupVisible : true,
        isMuted: parentGroup?.groupMuted !== undefined ? parentGroup.groupMuted : false,
        autoActivate: false,
        supportsWSS
    };

    const sourceId = stateManager.addSource(sourceDataObject);

    if (!sourceId) {
        console.error("Failed to add YouTube source to state manager for video ID:", streamData.videoId);
        return null;
    }
    

    // Instead of relying purely on the event listener, directly create and append if the listener hasn't already.
    // This makes it more robust for immediate activation needs.
    let sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
    if (!sourceElement) {
        console.log(`createYouTubeEntry: Element for ${sourceId} not found by listener, creating directly.`);
        sourceElement = createSourceElement(sourceId); // This function sets up UI and controls
        if (sourceElement) {
            const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
            const streamsContainer = groupElement?.querySelector('.stream-group');
            if (streamsContainer) {
                streamsContainer.appendChild(sourceElement);
            } else if (groupElement) {
                 console.warn("createYouTubeEntry: '.stream-group' not found, appending to group header for source:", sourceId);
                 groupElement.appendChild(sourceElement);
            } else {
                console.warn("createYouTubeEntry: Group element not found, appending to main #sources for source:", sourceId);
                document.getElementById("sources").appendChild(sourceElement);
            }
        }
    }
    
    if (!sourceElement) {
        console.error(`DOM element for YouTube source ID ${sourceId} could not be created or found.`);
        return null;
    }
    
    return sourceElement; 
}


async function newSourcePrompt(target) {
    let username, isChannelName = false;
    let prompt_message = `Enter the ${target} user name`;

    if (target === "facebook") {
        prompt_message += ".\nWhen you activate this source, you'll need to still manually select the video in the page.";
        username = window.prompt(prompt_message);
    } else if (target === "youtube" || target === "youtubeshorts") {
        prompt_message = `Enter the ${target} user name or channel name`;
        prompt_message += ".\nIf loading chat via username on Youtube, you must be live and the stream set to public for it to work.";
        const response = await ipcRenderer.sendSync('prompt', {
            title: `Enter the ${target} user name or channel name`,
            message: prompt_message,
            showChannelTypeCheckbox: true,
            showShortsCheckbox: (target === "youtubeshorts")
        });
        if (response && typeof response === 'object' && 'value' in response) {
            username = response.value;
            isChannelName = response.isChannelName || false;
        } else if (response) { 
            username = response;
            isChannelName = false;
        } else {
            return;
        }
    } else if (target === "rumble") {
        prompt_message = `Enter the Rumble username or channel name`;
        const response = await ipcRenderer.sendSync('prompt', {
            title: `Enter the Rumble username or channel name`,
            message: prompt_message,
            showChannelTypeCheckbox: true
        });
        if (response && typeof response === 'object' && 'value' in response) {
            username = response.value;
            isChannelName = response.isChannelName || false;
        } else if (response) { 
            username = response;
            isChannelName = false; // Default to user if not specified
        } else {
            return;
        }
    } else if (target === "parti") {
        prompt_message = `Enter the ${target} user ID.\n\nThis is a number which can be found at the end of the pop-out chat URL.`;
        username = window.prompt(prompt_message);
    } else {
        username = window.prompt(prompt_message);
    }

    if (username) {
        await newSource(target, username.trim(), false, {}, isChannelName);
    }
}

async function newSourceVideoIDPrompt(targetPlatform) {
    let videoID, target = targetPlatform, isShorts = false;
    if (target === "youtube" || target === "youtubeshorts") {
        const response = await ipcRenderer.sendSync('prompt', {
            title: "Enter the YouTube video ID or URL",
            message: "Example: dQw4w9WgXcQ or https://youtube.com/watch?v=dQw4w9WgXcQ\nThe video must be already LIVE, and set to public or unlisted.",
            showShortsCheckbox: true
        });
        if (response && response.value) {
            const extracted = extractYoutubeID(response.value); 
            if (extracted) {
                videoID = extracted.id;
                isShorts = extracted.isShorts || response.isShorts; 
                target = isShorts ? "youtubeshorts" : "youtube";
            } else { 
                videoID = response.value;
                isShorts = response.isShorts;
                target = isShorts ? "youtubeshorts" : "youtube";
            }
        } else {
            return;
        }
    } else if (target === "rumble") {
        const input = window.prompt("Enter the Rumble video URL (e.g., https://rumble.com/a1b2c3d4-now-live.html):");
        if (input) { 
            // Check if it's a full Rumble URL and extract the video ID or full path
            const trimmedInput = input.trim();
            if (trimmedInput.includes('rumble.com/')) {
                try {
                    const url = new URL(trimmedInput);
                    const pathname = url.pathname;
                    
                    if (pathname.includes('/chat/popup/')) {
                        // Extract chat ID from popup URL
                        const chatIdMatch = pathname.match(/\/chat\/popup\/(\d+)/);
                        if (chatIdMatch && chatIdMatch[1]) {
                            videoID = chatIdMatch[1];
                        }
                    } else if (pathname.startsWith('/')) {
                        // Extract the full path (everything after the first /)
                        videoID = pathname.substring(1).replace(/\?.*$/, ''); // Remove query params
                    }
                } catch (e) {
                    // If URL parsing fails, try regex
                    const matches = trimmedInput.match(/rumble\.com\/([vp]\w+-[^?#]+)/);
                    if (matches && matches[1]) {
                        videoID = matches[1];
                    } else {
                        videoID = trimmedInput;
                    }
                }
            } else if (/^[vp]\w+$/.test(trimmedInput)) {
                // Just a video ID was entered - we can't use this alone
                alert("Please enter the full Rumble URL, not just the video ID.\n\nExample: https://rumble.com/v60552h-newsmax2-live.html");
                return;
            } else {
                videoID = trimmedInput;
            }
        } else { return; }
    } else { 
        const input = window.prompt("Enter the " + target + " video ID");
        videoID = input;
        if (!videoID) return;
    }

    if (videoID) {
       await newSourceVideoID(target, videoID.trim(), false, {});
    }
}

async function cleanUpURL(url) {
	url = url.trim();
	
	// If it's already a chat popup URL, return it as-is
	if (url.startsWith("https://rumble.com/chat/popup/") || url.startsWith("http://rumble.com/chat/popup/")) {
		return url;
	}
	
	// For other Rumble URLs, try to fetch the chat ID
	if (url.startsWith("https://rumble.com/") || url.startsWith("http://rumble.com/")) {
		// Note: getRumbleVideoId actually returns the chat ID despite its name
		const chatId = await getRumbleVideoId(url);
		if (chatId) {
			return "https://rumble.com/chat/popup/" + chatId;
		}
	}
	
	return url;
}

async function newOtherSourcePrompt(target = "") {
    let URL = window.prompt("Enter the full URL for the source:");
    if (URL) {
        URL = (await cleanUpURL(URL.trim())).trim(); 
        let typeGuess = target;
        if (!typeGuess) {
            const guessedArr = checkSupported(URL); 
            if (guessedArr.length) {
                if (guessedArr.length === 1) {
                    typeGuess = guessedArr[0].split(".js")[0].split("/").pop();
                } else { 
                    try {
                        const chosenScript = await customPrompt(guessedArr.map(g => `sources/${g}`)); 
                        typeGuess = chosenScript.split(".js")[0].split("/").pop();
                    } catch (e) { Toast.error("Cancelled adding source."); return; }
                }
            } else { 
                const allSources = manifest.content_scripts.map(dom => dom.js[0].split(".js")[0].split("/").pop()).filter(Boolean);
                try {
                    const chosenScript = await customPrompt(allSources.map(s => `sources/${s}.js`));
                     typeGuess = chosenScript.split(".js")[0].split("/").pop();
                } catch (e) { 
                    Toast.error("Cancelled adding source."); 
                    return; 
                }
            }
        }
        if (typeGuess === "youtube" && (URL.includes("&shorts") || URL.includes("?shorts"))) {
            typeGuess = "youtubeshorts";
        }
        await newOtherSource(typeGuess, URL, false, {});
    }
}

/* Modified newSource */
async function newSource(target, username, startup = false, initialState = {}, isChannelName = false) {
    document.getElementById('welcomeFrame')?.remove();
    
     if (username) {
        let isUrl = false;
        try { new URL(username); isUrl = true; } catch (_) {}

        if (isUrl) {
            const url = new URL(username);
            const hostname = url.hostname.toLowerCase();
            if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
                const result = parseYoutubeUrl(url); 
                if (result.isYoutubeUrl && result.id) {
                    return newSourceVideoID(result.isShort ? "youtubeshorts" : "youtube", result.id, startup, initialState);
                } else if (result.isYoutubeUrl && result.username) {
                    target = result.isShort ? "youtubeshorts" : "youtube"; 
                    username = result.username;
                } else { 
                    username = url.pathname.split('/').filter(Boolean)[0]; 
                }
            } 
            else if (hostname.includes('rumble.com')) {
                 if (url.pathname.startsWith("/c/")) {
                    // Extract channel name from /c/channelname/livestreams
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    if (pathParts.length >= 2) {
                        username = pathParts[1]; // Get channel name
                        target = 'rumble';
                        isChannelName = true; // This is a channel URL
                    }
                } else if (url.pathname.startsWith("/user/")) {
                    // Extract username from /user/username/livestreams
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    if (pathParts.length >= 2) {
                        username = pathParts[1]; // Get username
                        target = 'rumble';
                        isChannelName = false; // This is a user URL
                    }
                } else if (url.pathname.startsWith("/chat/popup/")) {
                    // Direct chat popup URL - extract chat ID
                    const chatIdMatch = url.pathname.match(/\/chat\/popup\/(\d+)/);
                    if (chatIdMatch && chatIdMatch[1]) {
                        // For chat popup URLs, use newOtherSource instead
                        return newOtherSource('rumble', url.toString(), startup, initialState);
                    }
                } else {
                    // Try to extract video ID from URL like /v6vpthn-...
                    const videoIdMatch = url.pathname.match(/^\/([vp]\w+)-/);
                    if (videoIdMatch && videoIdMatch[1]) {
                        return newSourceVideoID('rumble', videoIdMatch[1], startup, initialState);
                    } else {
                        // Fall back to fetching video ID from page
                        const videoId = await getRumbleVideoId(url.toString()); 
                        if (videoId) return newSourceVideoID('rumble', videoId, startup, initialState);
                    }
                }
            }
        }
    }


    if (!username) { 
        console.warn("newSource called without username after prompt phase.");
        return;
    }

    let elementToReturnId; 

    if (target === "youtube" || target === "youtubeshorts") {
        const groupId = stateManager.addGroup({
            target,
            username,
            isChannel: isChannelName, 
            connectionMode: initialState.connectionMode || 'classic',
            autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
            groupVisible: initialState.groupVisible !== "false", 
            groupMuted: initialState.groupMuted === "true"
        });
        elementToReturnId = groupId; 
    } else {
        let sourceUrl = initialState.URL || initialState.url || ""; 
        let sourceFile = initialState.sourceFile || null; // Check for existing sourceFile

        if (!sourceUrl) { 
            if (target === "twitch") sourceUrl = `https://www.twitch.tv/popout/${username}/chat?popout=`;
            else if (target === "kick") sourceUrl = `https://kick.com/popout/${username}/chat`;
            else if (target === "parti") sourceUrl = `https://parti.com/popout-chat?id=${username}`;
            else if (target === "rumble") {
                if (isChannelName) {
                    sourceUrl = `https://rumble.com/c/${username}/livestreams`;
                } else {
                    sourceUrl = `https://rumble.com/user/${username}/livestreams`;
                }
            } 
            else if (target === "tiktok") sourceUrl = `https://www.tiktok.com/@${username.replace('@','')}/live`;
            else if (target === "trovo") sourceUrl = `https://trovo.live/chat/${username}`;
            else if (target === "instagram" || target === "instagramlive") sourceUrl = `https://www.instagram.com/${username}/live/`;
            else if (target === "picarto") sourceUrl = `https://picarto.tv/chatpopout/${username}/public`;
            else if (target === "dlive") sourceUrl = `https://dlive.tv/c/${username}/${username}`;
            else if (target === "x") sourceUrl = `https://x.com/${username}/chat`;
            else if (target === "beamstream") sourceUrl = `https://beamstream.gg/${username}/chat`;
            else if (target === "vimm") sourceUrl = `https://www.vimm.tv/c/${username}`;
            else if (target === "bilibili") sourceUrl = `https://live.bilibili.com/${username}`;
            else if (target === "facebook") sourceUrl = `https://www.facebook.com/${username}/videos`;
			else if (target === "arenasocial") sourceUrl = `https://arena.social/live/${username}`;
            // Add other URL constructions as needed
        }
        
        // Determine specific sourceFile if not provided in initialState
        if (!sourceFile) {
            if (target === "instagramlive" || target === "instagram") sourceFile = "sources/instagram.js";
            else if (target === "trovo") sourceFile = "sources/trovo.js";
            else if (target === "picarto") sourceFile = "sources/picarto.js";
            else if (target === "dlive") sourceFile = "sources/dlive.js";
            else if (target === "x") sourceFile = "sources/x.js";
            else if (target === "beamstream") sourceFile = "sources/beamstream.js";
            // Add other platform-specific script files here if necessary
        }


        // Check if platform supports WebSockets
        let supportsWSS = false;
        if (target === 'tiktok') {
            supportsWSS = true; // TikTok has built-in websocket support
        } else if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
            supportsWSS = manifest.content_scripts.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            );
        }
        
        // Set default connection mode based on platform
        let defaultMode = 'classic';
        // TikTok defaults to classic/standard mode since WebSocket is read-only
        
        // Force classic mode for platforms that don't have websocket support
        let connectionMode = initialState.connectionMode || defaultMode;
        if (!supportsWSS && connectionMode === 'websocket') {
            connectionMode = 'classic';
        }

        const sourceData = {
            target,
            username,
            url: sourceUrl,
            videoId: initialState.videoId || '', 
            connectionMode: connectionMode, // Use the validated connectionMode
            isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
            isMuted: initialState.togglemute === "true" || initialState.isMuted === true,
            autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
            supportsWSS,
            isChannel: target === 'rumble' ? isChannelName : undefined,
            ...initialState
        };
        if (sourceFile) { // Add sourceFile to the data if it was determined
            sourceData.sourceFile = sourceFile;
        }

        const sourceId = stateManager.addSource(sourceData);
        elementToReturnId = sourceId; 
    }
    
    manageWelcomePage();
    
    await Promise.resolve(); 
    const elementToReturn = elementToReturnId ? 
        (document.querySelector(`[data-source-id="${elementToReturnId}"]`) || document.querySelector(`[data-group-id="${elementToReturnId}"]`))
        : null;

    if (elementToReturn && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        if (elementToReturn.dataset.sourceId) { 
            const source = stateManager.getSource(elementToReturn.dataset.sourceId);
            if (source && source.autoActivate && !source.vid && !source.wssId) {
                 setTimeout(async () => {
                    const activateButton = elementToReturn.querySelector('[data-activatehtml]');
                    if (activateButton && !stateManager.getSource(source.id)?.vid && !stateManager.getSource(source.id)?.wssId) { 
                        await createWindow(activateButton);
                    }
                }, 2000 + Math.random() * 1000);
            }
        } else if (elementToReturn.dataset.groupId) { 
            const group = stateManager.getGroup(elementToReturn.dataset.groupId);
            if (group && group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                 setTimeout(async () => {
                    console.log('Auto-activating YouTube group from newSource:', group.username);
                     await handleYouTubeActivation(
                        group.username,
                        group.target === "youtubeshorts",
                        false, 
                        true,  
                        group.isChannel
                    );
                }, 2500 + Math.random() * 1000);
            }
        }
    }
    return elementToReturn;
}

async function newSourceVideoID(target, videoID, startup = false, initialState = {}) {
    document.getElementById('welcomeFrame')?.remove();
    
    if (!videoID) return;

    let url = initialState.URL || initialState.url || "";
    if (!url) { 
        if (target === "youtube" || target === "youtubeshorts") {
            url = `https://www.youtube.com/live_chat?is_popout=1&v=${videoID}${target === "youtubeshorts" ? "&shorts" : ""}`;
        } else if (target === "rumble") {
            // For Rumble, videoID might be alphanumeric (v6vpthn) or numeric (412388813)
            // We'll fetch the proper chat ID later during activation
            url = null; // Don't set a default URL, let activation handle it
        }
    }

    // Check if platform supports WebSockets
    let supportsWSS = false;
    if (target === 'tiktok') {
        supportsWSS = true; // TikTok has built-in websocket support
    } else if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // Set default connection mode based on platform
    let defaultMode = 'classic';
    // TikTok defaults to classic/standard mode since WebSocket is read-only

    const sourceId = stateManager.addSource({
        target,
        videoId: videoID,
        url: url,
        username: initialState.username || '', 
        connectionMode: initialState.connectionMode || defaultMode,
        isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
        isMuted: initialState.togglemute === "true" || initialState.isMuted === true,
        autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
        supportsWSS,
         ...initialState
    });
    
    manageWelcomePage();
    
    await Promise.resolve(); 
    const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);

    if (sourceElement && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        const source = stateManager.getSource(sourceId);
         if (source && source.autoActivate && !source.vid && !source.wssId) {
            setTimeout(async () => {
                const activateButton = sourceElement.querySelector('[data-activatehtml]');
                if (activateButton && !stateManager.getSource(source.id)?.vid && !stateManager.getSource(source.id)?.wssId) {
                    await createWindow(activateButton);
                }
            }, 2000 + Math.random() * 1000);
        }
    }
    return sourceElement;
}

/* Modified newOtherSource */
async function newOtherSource(target, URL, startup = false, initialState = {}) {
    document.getElementById('welcomeFrame')?.remove();
    if (!URL) return;

    let displayName = initialState.username || '';
    let chatId = null;
    
    // Check if this is a Rumble chat popup URL
    if (URL.includes('rumble.com/chat/popup/')) {
        const chatIdMatch = URL.match(/\/chat\/popup\/(\d+)/);
        if (chatIdMatch && chatIdMatch[1]) {
            chatId = chatIdMatch[1];
            displayName = `Rumble Chat ${chatId}`;
        }
    }
    
    if (!displayName) {
        try {
            const link = new URL(URL);
            const parts = link.hostname.split('.');
            displayName = parts.length >= 2 ? `${parts[parts.length - 2]}.${parts[parts.length - 1]}` : link.hostname;
        } catch {
            displayName = target || 'Unknown Source';
        }
    }
    
    // Determine sourceFile based on target, similar to how newSource handles it
    let sourceFile = initialState.sourceFile || null;
    if (!sourceFile && target) {
        // Example: if target is 'instagramlive', sourceFile should be 'sources/instagram.js'
        // This logic needs to be robust based on your platform-to-script mapping
        if (target === "instagramlive") {
            sourceFile = "sources/instagram.js";
        } else {
            // Default assumption: target maps directly to script name
            sourceFile = `sources/${target}.js`;
        }
    }


    // Check if platform supports WebSockets
    let supportsWSS = false;
    if (target === 'tiktok') {
        supportsWSS = true; // TikTok has built-in websocket support
    } else if (target && typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // Set default connection mode based on platform
    let defaultMode = 'classic';
    // TikTok defaults to classic/standard mode since WebSocket is read-only

    const sourceData = {
        target: target || 'unknown', 
        url: URL,
        username: displayName, 
        videoId: initialState.videoId || '', 
        connectionMode: initialState.connectionMode || defaultMode,
        isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
        isMuted: initialState.togglemute === "true" || initialState.isMuted === true,
        autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
        supportsWSS,
        ...initialState
    };
    
    // Add chatId if this is a Rumble chat popup
    if (chatId) {
        sourceData.chatId = chatId;
        // Clear username to prevent fetching videos for "rumble"
        if (target === 'rumble') {
            sourceData.username = displayName; // Keep the display name but it won't be used for fetching
            sourceData.videoId = ''; // Ensure videoId is empty
        }
    }
    
    // For Rumble URLs that aren't standard patterns, mark them as direct URLs
    if (target === 'rumble' && URL.includes('rumble.com') && !chatId) {
        // This is a custom Rumble URL that should be used as-is
        sourceData.isDirectUrl = true;
        // Keep the URL but clear fields that would trigger fetching
        sourceData.videoId = '';
        // Keep username for display but it won't be used for fetching
    }
    if (sourceFile) {
        sourceData.sourceFile = sourceFile;
    }
    
    const sourceId = stateManager.addSource(sourceData);

    manageWelcomePage();

    await Promise.resolve(); 
    const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);

     if (sourceElement && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        const source = stateManager.getSource(sourceId);
         if (source && source.autoActivate && !source.vid && !source.wssId) {
            setTimeout(async () => {
                const activateButton = sourceElement.querySelector('[data-activatehtml]');
                if (activateButton && !stateManager.getSource(source.id)?.vid && !stateManager.getSource(source.id)?.wssId) {
                    await createWindow(activateButton);
                }
            }, 2000 + Math.random() * 1000);
        }
    }
    return sourceElement;
}


async function newSourceOLD(target, username = false, startup = false, state = {}, isChannelName = false) {
    console.warn("newSourceOLD is deprecated and should not be called directly. Use newSourcePrompt or newSource.");
    if (username) {
        return newSource(target, username, startup, state, isChannelName);
    }
    return null;
}

async function cleanupYouTubeGroups() {
    console.log("Cleaning up YouTube video sources on startup...");
    
    // Get ALL sources, not just auto-discovered ones
    const allSources = stateManager.getSources();
    let removedCount = 0;
    
    allSources.forEach(source => {
        // Remove ONLY auto-discovered YouTube sources that have a video ID
        // These are expired streams that won't work anymore
        // Manual sources (isAutoDiscovered=false or undefined) are preserved
        if (source.target && source.target.startsWith('youtube') && source.videoId && source.isAutoDiscovered === true) {
            console.log("Removing auto-discovered YouTube video source:", source.id, "videoId:", source.videoId, "username:", source.username || "none");
            
            // Remove the source element from DOM if it exists
            const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
            if (sourceElement) {
                sourceElement.remove();
            }
            
            // Remove from state
            stateManager.removeSource(source.id);
            removedCount++;
        }
    });
    
    if (removedCount > 0) {
        console.log(`Removed ${removedCount} auto-discovered YouTube video sources on startup`);
        
        // Clean up orphaned stream references in groups
        const groups = stateManager.getGroups();
        groups.forEach(group => {
            if ((group.target === "youtube" || group.target === "youtubeshorts") && group.streams) {
                const validStreams = group.streams.filter(streamId => 
                    stateManager.getSource(streamId) !== null
                );
                
                if (validStreams.length !== group.streams.length) {
                    console.log(`Cleaned ${group.streams.length - validStreams.length} orphaned streams from group ${group.username}`);
                    group.streams = validStreams;
                }
            }
        });
        
        // Persist the cleaned state
        stateManager.persist();
    }
}

function setupGroupControls(groupHeaderElement) {
    if (!groupHeaderElement) return;
    const groupId = groupHeaderElement.dataset.groupId;
    if (!groupId) return;

    const group = stateManager.getGroup(groupId);
    if (!group) return;

    const target = group.target;
    const controlPanel = groupHeaderElement.querySelector('.control-panel');
    
    // Add connection mode selector for YouTube groups
    if (target && target.startsWith('youtube') && controlPanel) {
        let modeSelector = controlPanel.querySelector('.mode-selector');
        
        if (!modeSelector) {
            modeSelector = document.createElement('div');
            modeSelector.className = 'mode-selector';
            modeSelector.innerHTML = `
                <div class="mode-selector-label">Default Mode:</div>
                <div class="mode-options">
                    <div class="mode-option" 
                         data-mode="classic" 
                         onclick="setGroupConnectionMode(this.closest('.entry'), 'classic'); updateModeSelector(this)">
                        ğŸ“„ Standard
                    </div>
                    <div class="mode-option" 
                         data-mode="websocket" 
                         onclick="setGroupConnectionMode(this.closest('.entry'), 'websocket'); updateModeSelector(this)">
                        ğŸŒ WebSocket
                    </div>
                </div>
                <div class="mode-info">
                    <span class="info-icon" title="WebSocket mode uses less resources and provides additional data like followers/subs when signed in. Requires login for full features.">â„¹ï¸</span>
                </div>`;
            
            controlPanel.appendChild(modeSelector);
            
            // Update the active state based on current connection mode
            const currentMode = group.connectionMode || 'classic';
            modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.mode === currentMode) {
                    opt.classList.add('active');
                }
            });
        }
    }

    const autoActivateCheckbox = groupHeaderElement.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = group.autoActivate;
        autoActivateCheckbox.onchange = () => {
            stateManager.updateGroup(groupId, { autoActivate: autoActivateCheckbox.checked });
            
            // Start or stop auto-checking for YouTube groups
            if (group.target === "youtube" || group.target === "youtubeshorts") {
                if (autoActivateCheckbox.checked) {
                    startYouTubeGroupAutoCheck(groupId);
                } else {
                    stopYouTubeGroupAutoCheck(groupId);
                }
            }
        };
    }
    
    const settingsBtn = groupHeaderElement.querySelector('.settings-btn');
    const settingsMenu = groupHeaderElement.querySelector('.settings-menu');
    if (settingsBtn && settingsMenu) {
        settingsBtn.onclick = (e) => {
            e.stopPropagation();
            document.querySelectorAll('.settings-menu.active').forEach(menu => {
                if (menu !== settingsMenu) menu.classList.remove('active');
            });
            settingsMenu.classList.toggle('active');
        };
        document.addEventListener('click', (e) => {
            if (!settingsMenu.classList.contains('hidden') && !settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsMenu.classList.remove('active');
            }
        });
    }
}

function toggleGroupVisibility(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    stateManager.updateGroup(groupId, { groupVisible: !group.groupVisible });
}

function toggleGroupMute(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    stateManager.updateGroup(groupId, { groupMuted: !group.groupMuted });
}

function updateModeSelector(clickedOption) {
    const modeOptions = clickedOption.parentElement;
    modeOptions.querySelectorAll('.mode-option').forEach(opt => {
        opt.classList.remove('active');
    });
    clickedOption.classList.add('active');
}

function setGroupConnectionMode(groupElement, mode) {
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    
    // Update the group's connection mode
    stateManager.updateGroup(groupId, { connectionMode: mode });
    
    // Update all child sources to use the new mode
    const sources = stateManager.getSourcesByGroup(groupId);
    sources.forEach(source => {
        stateManager.updateSource(source.id, { connectionMode: mode });
        
        // Update the UI for each source
        const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
        if (sourceElement) {
            updateSourceUIAfterModeChange(sourceElement, mode, source.status === 'active');
        }
    });
    
    // Update the group's settings menu to show the active mode
    const settingsMenu = groupElement.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.querySelectorAll('[data-action^="group-"]').forEach(item => {
            item.classList.remove('active');
        });
        const activeItem = settingsMenu.querySelector(`[data-action="group-${mode}-mode"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
    
    // Close the settings menu
    const settingsBtn = groupElement.querySelector('.settings-btn');
    if (settingsBtn) {
        settingsBtn.classList.remove('active');
    }
    
    Toast.info("Connection Mode Updated", `All streams in ${group.username} are now using ${mode === 'websocket' ? 'WebSocket' : 'Standard'} mode`);
}

function stopAllStreamsInGroup(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && (source.vid || source.wssId)) {
            const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
            const stopButton = sourceElement?.querySelector('[data-stophtml]');
            if (stopButton) stopThis(stopButton); 
        }
    });
}

function reloadAllStreamsInGroup(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;

    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid) { 
            const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
            const reloadButton = sourceElement?.querySelector('[data-reloadhtml]');
            if (reloadButton) refreshWindow(reloadButton);
        }
    });
}

function handleYouTubeGroupActivationPrompt(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return;

    handleYouTubeActivation(group.username, group.target === "youtubeshorts", true, false, group.isChannel);
}

function handleYouTubeGroupAutoActivation(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return;
    
    handleYouTubeActivation(group.username, group.target === "youtubeshorts", false, true, group.isChannel);
}

// Store interval IDs for YouTube group checking
const youtubeGroupIntervals = new Map();

// Store backoff state for YouTube groups
const youtubeGroupBackoffState = new Map();

// Store interval IDs for Rumble auto-checking
const rumbleIntervals = new Map();

function startYouTubeGroupAutoCheck(groupId) {
    // Clear any existing interval for this group
    stopYouTubeGroupAutoCheck(groupId);
    
    const group = stateManager.getGroup(groupId);
    if (!group || !group.autoActivate) return;
    
    console.log(`Starting auto-check for YouTube group: ${group.username}`);
    
    // Initialize backoff state
    youtubeGroupBackoffState.set(groupId, {
        checkCount: 0,
        intervals: [60000, 360000, 960000] // 1 min, 6 min, 16 min
    });
    
    // Check immediately
    checkYouTubeGroupForNewStreamsWithBackoff(groupId);
}

function stopYouTubeGroupAutoCheck(groupId) {
    const timeoutId = youtubeGroupIntervals.get(groupId);
    if (timeoutId) {
        clearTimeout(timeoutId);
        youtubeGroupIntervals.delete(groupId);
        youtubeGroupBackoffState.delete(groupId);
        console.log(`Stopped auto-check for YouTube group: ${groupId}`);
    }
}

async function checkYouTubeGroupForNewStreamsWithBackoff(groupId) {
    // Check for new streams
    const foundNewStreams = await checkYouTubeGroupForNewStreams(groupId);
    
    // If we found NEW streams, stop checking (not just any streams)
    if (foundNewStreams) {
        stopYouTubeGroupAutoCheck(groupId);
        return;
    }
    
    // Get backoff state
    const backoffState = youtubeGroupBackoffState.get(groupId);
    if (!backoffState) return;
    
    // Determine next check interval
    let nextInterval;
    if (backoffState.checkCount < backoffState.intervals.length) {
        nextInterval = backoffState.intervals[backoffState.checkCount];
        backoffState.checkCount++;
    } else {
        // Use the last interval (16 minutes) for all subsequent checks
        nextInterval = backoffState.intervals[backoffState.intervals.length - 1];
    }
    
    const group = stateManager.getGroup(groupId);
    if (group) {
        const minutes = Math.floor(nextInterval / 60000);
        console.log(`No live streams found for YouTube group ${group.username}, checking again in ${minutes} minute(s)`);
    }
    
    // Schedule next check
    const timeoutId = setTimeout(() => {
        checkYouTubeGroupForNewStreamsWithBackoff(groupId);
    }, nextInterval);
    
    youtubeGroupIntervals.set(groupId, timeoutId);
}

async function checkYouTubeGroupForNewStreams(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return false;
    
    console.log(`Checking for new streams in YouTube group: ${group.username}`);
    
    let streams = [];
    let usingFallback = false;
    
    try {
        // Try the API first
        const response = await fetch(`https://api.socialstream.ninja/youtube/streams?username=${encodeURIComponent(group.username)}`);
        const data = await response.json();
        
        if (!data.success || !Array.isArray(data.data)) {
            console.warn("API response invalid, falling back to fetchYoutube");
            throw new Error("Invalid API response");
        }
        
        streams = data.data;
    } catch (error) {
        console.error("API call failed, attempting fallback to fetchYoutube:", error);
        
        // Fallback to fetchYoutube
        try {
            usingFallback = true;
            
            // Check if fetchYoutube is available
            if (typeof fetchYoutube !== 'function') {
                console.error("fetchYoutube function not available");
                return false;
            }
            
            // Try both alt=false and alt=true if needed
            let fetchResult = await fetchYoutube(group.username, false);
            if (!fetchResult || fetchResult.length === 0) {
                fetchResult = await fetchYoutube(group.username, true);
            }
            
            if (fetchResult && Array.isArray(fetchResult)) {
                streams = fetchResult;
                console.log(`Fallback successful, found ${streams.length} streams via fetchYoutube`);
            } else {
                console.error("Fallback to fetchYoutube also failed");
                return false;
            }
        } catch (fallbackError) {
            console.error("Fallback to fetchYoutube failed:", fallbackError);
            return false;
        }
    }
    
    // Filter streams based on type
    const isShorts = group.target === "youtubeshorts";
    const filteredStreams = streams.filter(stream => stream.isShort === isShorts);
    
    // Get existing video IDs for this group
    const existingVideoIds = new Set();
    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && source.videoId) {
            existingVideoIds.add(source.videoId);
        }
    });
    
    // Find new streams
    const newStreams = filteredStreams.filter(stream => !existingVideoIds.has(stream.videoId));
    
    if (newStreams.length > 0) {
        console.log(`Found ${newStreams.length} new streams for group ${group.username}${usingFallback ? ' (via fallback)' : ''}`);
        Toast.info("New Streams Found", `Found ${newStreams.length} new live stream(s) for ${group.username}`);
        
        // Auto-activate new streams if auto-activate is enabled
        for (const stream of newStreams) {
            const newSource = {
                target: group.target,
                username: group.username,
                url: `https://www.youtube.com/live_chat?is_popout=1&v=${stream.videoId}${group.target === 'youtubeshorts' ? '&shorts' : ''}`,
                groupId: groupId,
                videoId: stream.videoId,
                title: stream.title,
                autoActivate: true // Inherit auto-activate from group
            };
            
            console.log("Adding new YouTube stream:", newSource);
            stateManager.addSource(newSource);
            
            // Auto-activate the new source
            setTimeout(async () => {
                const addedSource = stateManager.getSources().find(s => s.videoId === stream.videoId);
                if (addedSource) {
                    const sourceElement = document.querySelector(`[data-source-id="${addedSource.id}"]`);
                    const activateButton = sourceElement?.querySelector('[data-activatehtml]');
                    if (activateButton) {
                        await createWindow(activateButton);
                    }
                }
            }, 500);
        }
    }
    
    // Return true only if we found NEW streams (not just any streams)
    return newStreams.length > 0;
}

// Rumble auto-check functions
function startRumbleAutoCheck(sourceId) {
    // Clear any existing interval for this source
    stopRumbleAutoCheck(sourceId);
    
    const source = stateManager.getSource(sourceId);
    if (!source || !source.autoActivate || source.target !== 'rumble') return;
    
    console.log(`Starting auto-check for Rumble source: ${source.username}`);
    
    // Check immediately
    checkRumbleForStream(sourceId);
    
    // Then check every minute until a stream is found
    const intervalId = setInterval(() => {
        checkRumbleForStream(sourceId);
    }, 60000); // 60 seconds
    
    rumbleIntervals.set(sourceId, intervalId);
}

function stopRumbleAutoCheck(sourceId) {
    const intervalId = rumbleIntervals.get(sourceId);
    if (intervalId) {
        clearInterval(intervalId);
        rumbleIntervals.delete(sourceId);
        console.log(`Stopped auto-check for Rumble source: ${sourceId}`);
    }
}

async function checkRumbleForStream(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source || source.target !== 'rumble') return;
    
    // Don't check if already activated
    if (source.status === 'active' && source.vid) {
        console.log(`Rumble source ${source.username} already active, stopping auto-check`);
        stopRumbleAutoCheck(sourceId);
        return;
    }
    
    console.log(`Checking for live stream for Rumble user: ${source.username}`);
    
    try {
        // Try to activate the source
        const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
        const activateButton = sourceElement?.querySelector('[data-activatehtml]');
        
        if (activateButton) {
            // Try to create the window
            const windowId = await createWindow(activateButton);
            
            if (windowId) {
                console.log(`Rumble stream found and activated for ${source.username}`);
                Toast.success("Rumble Stream Live", `${source.username} is now live on Rumble!`);
                
                // Stop checking since Rumble only allows one stream per user
                stopRumbleAutoCheck(sourceId);
            } else {
                console.log(`No live stream found for Rumble user ${source.username}, will check again in 1 minute`);
            }
        }
    } catch (error) {
        console.error("Error checking Rumble for stream:", error);
        // Keep checking on error
    }
}


function updateSourceUIAfterModeChange(sourceElement, mode, isActive = false) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    
    const target = source ? source.target : sourceElement.dataset.target;

    const activateButton = sourceElement.querySelector('[data-activatehtml]');
    const controlPanel = sourceElement.querySelector('.control-panel');
    
    const classicModePanelButton = controlPanel?.querySelector('.mode-option[data-mode="classic"]');
    const wsModePanelButton = controlPanel?.querySelector('.mode-option[data-mode="websocket"]');

    const settingsMenu = sourceElement.querySelector('.settings-menu');
    const classicMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-action="classic-mode"]');
    const wssMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-wss="true"]');
    const tiktokWssMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-tiktokwss="true"]');

    classicModePanelButton?.classList.remove('active');
    wsModePanelButton?.classList.remove('active');
    if (classicMenuItem) classicMenuItem.dataset.selected = "false";
    if (wssMenuItem) wssMenuItem.dataset.selected = "false";
    if (tiktokWssMenuItem) tiktokWssMenuItem.dataset.selected = "false";

    if (activateButton) { 
        if (isActive) { 
             activateButton.innerText = translate('btn.activate'); 
        } else {
            if (target === 'tiktok' && mode === 'tiktok-websocket') {
                activateButton.innerText = "Connect TikTok WebSocket";
            } else if (mode === 'websocket') {
                activateButton.innerText = "Connect WebSocket";
            } else { 
                activateButton.innerText = translate('btn.activate');
            }
        }
    }
    
    if (target === 'tiktok') {
        if (mode === 'tiktok-websocket') {
            if (tiktokWssMenuItem) tiktokWssMenuItem.dataset.selected = "true";
            // Don't hide the mode selector
        } else { 
            if (classicMenuItem) classicMenuItem.dataset.selected = "true";
            // Don't hide the mode selector
        }
    } else { 
        if (mode === 'websocket') {
            wsModePanelButton?.classList.add('active');
            if (wssMenuItem) wssMenuItem.dataset.selected = "true";
        } else { 
            classicModePanelButton?.classList.add('active');
            if (classicMenuItem) classicMenuItem.dataset.selected = "true";
        }
        // Don't hide the mode selector based on menu item visibility
    }
    
    // Update sign-in button visibility and behavior based on connection mode
    const signinButton = sourceElement.querySelector("[data-signin]");
    if (signinButton) {
        const isWebsocketMode = mode === 'websocket' || mode === 'tiktok-websocket';
        
        if (target === 'tiktok' && mode === 'tiktok-websocket') {
            // Show info instead of sign-in button for websocket mode
            signinButton.classList.remove("hidden");
            signinButton.setAttribute('data-tiktok-signin', 'true');
            signinButton.innerHTML = 'ğŸ“– Read-Only Mode';
            signinButton.style.cursor = 'help';
            signinButton.title = 'WebSocket mode is read-only. Use Standard mode to send messages.';
            signinButton.onclick = function() { 
                Toast.info('TikTok WebSocket Mode', 'This mode is read-only due to TikTok API limitations. To send messages, please use Standard mode instead.');
            };
            
            // Check if already authenticated
            const source = stateManager.getSource(sourceId);
            if (source && source.tiktokSessionId) {
                signinButton.innerHTML = 'âœ“ Signed In';
                signinButton.classList.add('authenticated');
            }
        } else if (isWebsocketMode) {
            // Hide for other websocket modes
            signinButton.classList.add("hidden");
        } else {
            // Regular sign-in button
            signinButton.classList.remove("hidden");
            signinButton.removeAttribute('data-tiktok-signin');
            signinButton.innerHTML = 'ğŸ”‘ Sign-in';
            signinButton.onclick = function() { signin(this); };
            signinButton.classList.remove('authenticated');
        }
    }
}


async function setSourceConnectionMode(sourceElement, mode, clickedMenuItemOrPanelButton) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source) return;

    console.log(`[Mode Switch] Setting connection mode for ${sourceId} from ${source.connectionMode} to ${mode}`);

    // If source is active, show a warning but don't prevent the mode change
    if (source.vid || source.wssId) { 
        Toast.warning("Mode Change", "Source is active. Stop it before activating with the new mode.");
    }

    stateManager.updateSource(sourceId, { connectionMode: mode });

    if (clickedMenuItemOrPanelButton && clickedMenuItemOrPanelButton.classList.contains('settings-menu-item')) {
        const mainActivateButton = sourceElement.querySelector('[data-activatehtml]');
        if (mainActivateButton && !mainActivateButton.classList.contains('hidden')) {
            await createWindow(mainActivateButton); 
        }
    }
}


function setupSourceControls(sourceElement) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    const isGroupHeader = sourceElement.dataset.isGroupHeader === "true";


    const settingsBtn = sourceElement.querySelector('.settings-btn');
    const settingsMenu = sourceElement.querySelector('.settings-menu');
    if (!settingsBtn || !settingsMenu) return;

    const target = source ? source.target : sourceElement.dataset.target;
    const username = source ? source.username : sourceElement.dataset.username; 
    const controlPanel = sourceElement.querySelector('.control-panel');

    const classicMenuItem = settingsMenu.querySelector('.settings-menu-item[data-action="classic-mode"]');
    const wssMenuItem = settingsMenu.querySelector('.settings-menu-item[data-wss="true"]');
    const tiktokWssMenuItem = settingsMenu.querySelector('.settings-menu-item[data-tiktokwss="true"]');

    let isYouTube = target && target.startsWith('youtube');
    let isTikTok = target === 'tiktok';
    let genericWsSupported = false;
    
    // Check if platform supports websockets
    if (!isYouTube && !isTikTok && target) { 
        // Check manifest for websocket support
        genericWsSupported = manifest?.content_scripts?.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // For YouTube entries, websocket is supported
    if (isYouTube) {
        genericWsSupported = true;
    }
    
    if (isTikTok) {
        wssMenuItem?.classList.add('hidden');
        tiktokWssMenuItem?.classList.remove('hidden');
        
        // Add TikTok-specific mode selector
        let modeSelector = controlPanel?.querySelector('.mode-selector');
        if (!modeSelector && controlPanel) {
            modeSelector = document.createElement('div');
            modeSelector.className = 'mode-selector';
            modeSelector.innerHTML = `
                <div class="mode-selector-label">Connection Mode:</div>
                <div class="mode-options">
                    <div class="mode-option" 
                         data-mode="classic" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'classic', this); updateModeSelector(this)">
                        ğŸ“„ Standard
                    </div>
                    <div class="mode-option" 
                         data-mode="tiktok-websocket" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'tiktok-websocket', this); updateModeSelector(this)">
                        ğŸŒ TikTok WS
                    </div>
                </div>
                <div class="mode-info">
                    <span class="info-icon" title="TikTok WebSocket mode is READ-ONLY. You can view messages but cannot send them due to TikTok API limitations. Use Standard mode for full interaction.">â„¹ï¸</span>
                </div>`;
            controlPanel.appendChild(modeSelector);
        }
        if (modeSelector) {
            modeSelector.classList.remove('hidden');
            // Update the active state based on current connection mode
            const currentMode = source?.connectionMode || 'classic';
            modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.mode === currentMode) {
                    opt.classList.add('active');
                }
            });
        }
    } else {
        tiktokWssMenuItem?.classList.add('hidden');
        if (isYouTube || genericWsSupported) {
            wssMenuItem?.classList.remove('hidden');
            let modeSelector = controlPanel?.querySelector('.mode-selector');
            if (!modeSelector && controlPanel) { 
                modeSelector = document.createElement('div');
                modeSelector.className = 'mode-selector';
                modeSelector.innerHTML = `
                    <div class="mode-selector-label">Connection Mode:</div>
                    <div class="mode-options">
                        <div class="mode-option" 
                             data-mode="classic" 
                             onclick="setSourceConnectionMode(this.closest('.entry'), 'classic', this); updateModeSelector(this)">
                            ğŸ“„ Standard
                        </div>
                        <div class="mode-option" 
                             data-mode="websocket" 
                             onclick="setSourceConnectionMode(this.closest('.entry'), 'websocket', this); updateModeSelector(this)">
                            ğŸŒ WebSocket
                        </div>
                    </div>
                    <div class="mode-info">
                        <span class="info-icon" title="WebSocket mode uses less resources and provides additional data like followers/subs when signed in. Requires login for full features.">â„¹ï¸</span>
                    </div>`;
                controlPanel.appendChild(modeSelector);
            }
            if (modeSelector) {
                modeSelector.classList.remove('hidden');
                // Update the active state based on current connection mode
                const currentMode = source?.connectionMode || 'classic';
                modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                    opt.classList.remove('active');
                    if (opt.dataset.mode === currentMode) {
                        opt.classList.add('active');
                    }
                });
            }
        } else { 
            wssMenuItem?.classList.add('hidden');
            // Don't remove the mode selector if it exists
        }
    }

    const autoActivateToggleDiv = controlPanel?.querySelector('.auto-activate-toggle');
    if (autoActivateToggleDiv) {
        const checkbox = autoActivateToggleDiv.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.onchange = () => {
                if (sourceId) { 
                    stateManager.updateSource(sourceId, { autoActivate: checkbox.checked });
                } else if (isGroupHeader && sourceElement.dataset.groupId) { 
                    stateManager.updateGroup(sourceElement.dataset.groupId, { autoActivate: checkbox.checked });
                }
            };
        }
    }

    settingsBtn.onclick = (e) => {
        e.stopPropagation();
        document.querySelectorAll('.settings-menu.active').forEach(menu => {
            if (menu !== settingsMenu) menu.classList.remove('active');
        });
        settingsMenu.classList.toggle('active');

        const currentSource = sourceId ? stateManager.getSource(sourceId) : null;
        const isActive = currentSource ? (!!currentSource.vid || !!currentSource.wssId) : false;
        const currentMode = currentSource ? currentSource.connectionMode : (sourceElement.dataset.lastConnectionMode || 'classic');

        settingsMenu.querySelectorAll('.connection-modes .settings-menu-item').forEach(item => {
            if (item.classList.contains('hidden')) return; 

            const itemMode = item.dataset.action === 'classic-mode' ? 'classic' :
                             item.dataset.wss === 'true' ? 'websocket' :
                             item.dataset.tiktokwss === 'true' ? 'tiktok-websocket' : null;

            const isSelected = itemMode === currentMode;
            item.dataset.selected = isSelected.toString(); 

            if (isActive) { 
                if (isSelected) { 
                    item.style.opacity = '1';
                    item.style.pointerEvents = 'auto';
                    item.title = 'Click to stop current connection';
                    const icon = item.querySelector('i');
                    if (icon) icon.textContent = 'â¹ï¸'; 
                } else { 
                    item.style.opacity = '0.5';
                    item.style.pointerEvents = 'none';
                    item.title = 'Stop current connection to change/activate another mode.';
                    const icon = item.querySelector('i');
                    if (icon) {
                        if (item.dataset.action === 'classic-mode') icon.textContent = 'ğŸ“„';
                        else if (item.dataset.wss === 'true' || item.dataset.tiktokwss === 'true') icon.textContent = 'ğŸŒ';
                    }
                }
            } else { 
                item.style.opacity = '1';
                item.style.pointerEvents = 'auto';
                const icon = item.querySelector('i');
                if (item.dataset.action === 'classic-mode') {
                    item.title = 'Use standard browser window for this source';
                    if (icon) icon.textContent = 'ğŸ“„';
                } else if (item.dataset.wss === 'true') {
                    item.title = 'Connect to the API directly using WebSocket';
                     if (icon) icon.textContent = 'ğŸŒ';
                } else if (item.dataset.tiktokwss === 'true') {
                    item.title = 'Connect to the TikTok API directly using WebSockets';
                    if (icon) icon.textContent = 'ğŸŒ';
                } else {
                    item.title = '';
                }
            }
        });
    };
    document.addEventListener('click', (e) => { 
        if (!settingsMenu.classList.contains('active')) return;
        if (!settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
            settingsMenu.classList.remove('active');
        }
    });

    if (source) {
        updateSourceUIAfterModeChange(sourceElement, source.connectionMode, (source.status === 'active'));
    } else if (!isGroupHeader) { 
        updateSourceUIAfterModeChange(sourceElement, 'classic', false);
    }
}

function setClassicMode(menuItemElement) { 
    const sourceElement = menuItemElement.closest('.entry');
    if (!sourceElement) return;
    setSourceConnectionMode(sourceElement, 'classic', menuItemElement);
}

async function activateSource(ele) {
    const parentElement = ele.closest('.entry');
    if (!parentElement) {
        console.error("activateSource: Could not find parent .entry");
        return;
    }
    await createWindow(ele);
}

/* Modified toggleSourceVisibility */
function toggleSourceVisibility(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source || !source.vid) {
        Toast.info("Info", "Source must be active to toggle visibility.");
        return;
    }
    
    const desiredUiState = !source.isVisible; // What the UI should become

    // Because main.js showWindow handler has inverted logic for explicit state:
    // if desiredUiState is true (want to show), send state: false to main
    // if desiredUiState is false (want to hide), send state: true to main
    const stateToSendToMain = !desiredUiState;

    console.log(`toggleSourceVisibility: sourceId=${sourceId}, current IsVisible=${source.isVisible}, desired UI State=${desiredUiState}, sending to main=${stateToSendToMain}`);

    if (!ipcRenderer) {
        console.error("ipcRenderer not available for toggleSourceVisibility");
        Toast.error("IPC Error", "Cannot communicate with main process.");
        return;
    }

    
    ipcRenderer.invoke('showWindow', {
        vid: source.vid,
        state: stateToSendToMain 
    }).then(responseFromMain => {
        // responseFromMain should be the *actual* new visibility state from main process
        let actualNewState = desiredUiState; // Default to desired if main doesn't respond clearly

        if (responseFromMain !== undefined && typeof responseFromMain.newState === 'boolean') {
            actualNewState = responseFromMain.newState;
        } else if (typeof responseFromMain === 'boolean') { // If main process just returns the boolean state
            actualNewState = responseFromMain;
        } else {
             console.warn('toggleSourceVisibility: Unexpected response from main process for showWindow IPC. Assuming desired state.', responseFromMain);
        }
        
        console.log(`toggleSourceVisibility: main process responded with actualNewState=${actualNewState}. Updating stateManager.`);
        stateManager.updateSource(sourceId, { isVisible: actualNewState });

    }).catch(error => {
        console.error("Error in toggleSourceVisibility IPC:", error);
        Toast.error("Visibility Error", "Could not toggle window visibility. Check console for details.");
        // Optionally, revert UI or state if IPC fails catastrophically, though sourceUpdated should handle UI
    });
}


function toggleSourceMute(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;

    const newMuteState = !source.isMuted;
    console.log(`Toggling mute for ${sourceId}: ${source.isMuted} -> ${newMuteState}`);
    
    // Update the state first
    stateManager.updateSource(sourceId, { isMuted: newMuteState });
    
    // Update UI immediately
    const button = ele;
    button.textContent = newMuteState ? 'ğŸ”‡' : 'ğŸ”Š';
    
    // If the window is active, also update the actual mute state
    if (source.vid && ipcRenderer) {
        console.log(`Sending mute command to window ${source.vid}: ${newMuteState}`);
        ipcRenderer.sendSync('muteWindow', {
            vid: source.vid,
            muteWindow: newMuteState
        });
    }
    
    // Verify the state was saved
    const updatedSource = stateManager.getSource(sourceId);
    console.log(`Mute state after update: ${updatedSource.isMuted}`);
}

async function deleteThis(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;

    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;

    if (sourceId) { 
        const source = stateManager.getSource(sourceId);
        if (source) {
            if (source.wssId && source.target === 'tiktok') {
                try {
                    if (ipcRenderer) await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
                } catch (e) { console.warn('Error disconnecting TikTok WSS during delete:', e); }
            } else if (source.vid) { 
                try {
                    if (ipcRenderer) await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
                } catch (e) { console.warn('Error closing window/WSS during delete:', e); }
            }
            stateManager.removeSource(sourceId); 
        }
    } else if (groupId) { 
        const group = stateManager.getGroup(groupId);
        if (group) {
            stateManager.removeGroup(groupId); 
        }
    }
    manageWelcomePage();
}


async function stopThis(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source) return;
    
    if (ele.dataset.connecting === "true" && source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket') {
        if (source.wssId && ipcRenderer) { 
            try {
                await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
            } catch (e) { console.warn("Error stopping TikTok connection attempt:", e); }
        }
        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null });
        updateConnectionStatus(entry, 'stopped', "Connection attempts stopped");
        return;
    }

    if (source.vid || source.wssId) {
        try {
            if (source.target === 'tiktok' && source.connectionMode === 'tiktok-websocket' && source.wssId && ipcRenderer) {
                await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
            } else if (source.vid && ipcRenderer) { 
                await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
            }
        } catch (error) {
            console.error('Error in stopThis during IPC call:', error);
        }
        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null });
        if (source.target === 'tiktok') updateConnectionStatus(entry, 'clear');
        
        // For Rumble sources, clear video ID and chat ID for username-based sources
        if (source.target === 'rumble' && source.username && (source.videoId || source.chatId)) {
            stateManager.updateSource(sourceId, { videoId: null, chatId: null, url: null });
        }
        
        // Restart auto-check for Rumble sources with auto-activate
        if (source.target === 'rumble' && source.autoActivate) {
            console.log(`Restarting auto-check for deactivated Rumble source: ${source.username}`);
            setTimeout(() => {
                startRumbleAutoCheck(sourceId);
            }, 1000); // Small delay before restarting
        }
    }
}


async function clearThis(ele) {
	const entry = ele.closest('.entry');
    if (!entry) return;
    
    let idsToClear = [];
    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;

    if (sourceId) {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid) idsToClear.push(source.vid);
    } else if (groupId) {
        const group = stateManager.getGroup(groupId);
        if (group) {
            group.streams.forEach(sId => {
                const stream = stateManager.getSource(sId);
                if (stream && stream.vid) idsToClear.push(stream.vid);
            });
        }
    }

	if (idsToClear.length === 0) {
		Toast.info("Info", "No active sources to clear cache for.");
		return;
	}

    const buttonText = ele.textContent;
    ele.textContent = idsToClear.length > 1 ? 'Clearing All...' : 'Clearing...';
    ele.disabled = true;

    for (const vid of idsToClear) {
        if (ipcRenderer) {
            try {
                const result = await ipcRenderer.invoke('clearWindowCache', vid); 
                if (!result.success) {
                    console.error('Failed to clear cache for', vid, result.error);
                    Toast.error("Error", `Cache clear failed for source window ${vid}.`);
                }
            } catch (error) {
                console.error('Error invoking clearWindowCache for', vid, error);
                Toast.error("Error", `Error clearing cache for source window ${vid}.`);
            }
        }
    }
    Toast.success("Success", `Cache cleared for ${idsToClear.length} source(s).`);
    ele.textContent = buttonText;
    ele.disabled = false;
}

async function refreshWindow(ele) {
	const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
	if (source && source.vid && ipcRenderer) {
		ipcRenderer.sendSync('reloadWindow', { 
			tab: source.vid 
		});
	};
}

async function createWindow(ele, tabid = false) { 
	if (!ele) { console.error('No element provided to createWindow'); return false; }
	if (!configReady) { 
        Toast.error("Config Error", "Configuration not ready. Please wait or check console.");
        return false;
    }

	const entry = ele.closest('.entry');
	if (!entry) { console.error("Could not find entry for createWindow"); return false; }
    
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) { console.error("No sourceId on entry for createWindow"); return false; }

    const source = stateManager.getSource(sourceId);
    console.log(`[CREATEWINDOW DEBUG] Source ID: ${sourceId}, Source:`, source);
    if (!source) { console.error("Source not found in stateManager:", sourceId); return false; }

    const target = source.target; // Move this declaration up before it's used

	if (source.vid || source.wssId) {
		console.log('Window/connection already active for this entry:', source.vid || source.wssId);
		console.log(`[Window Mapping Debug] Source ${sourceId} state:`, {
			vid: source.vid,
			wssId: source.wssId,
			connectionMode: source.connectionMode,
			target: source.target,
			username: source.username
		});
		
		// Check if we're switching connection modes
		const currentMode = source.connectionMode;
		const isTikTokModeSwitch = target === 'tiktok' && 
			((currentMode === 'tiktok-websocket' && source.vid && source.vid < 900000) || // Was classic, now websocket
			 (currentMode === 'classic' && source.vid && source.vid > 900000)); // Was websocket, now classic
		
		if (isTikTokModeSwitch) {
			console.log(`[Mode Switch] Switching TikTok from ${source.vid > 900000 ? 'websocket' : 'classic'} to ${currentMode}`);
			// Close the old connection/window
			try {
				if (source.vid > 900000 && source.wssId) {
					// Close websocket connection
					await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
				} else if (source.vid) {
					// Close classic window
					await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
				}
			} catch (e) {
				console.warn('Error closing old connection during mode switch:', e);
			}
			// Clear the old IDs
			stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive' });
		} else {
			// Verify the window actually exists before reusing the ID
			if (source.vid && ipcRenderer) {
				const windowExists = await ipcRenderer.invoke('checkWindowExists', { vid: source.vid });
				if (!windowExists) {
					stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive' });
				} else {
					return source.vid;
				}
			} else if (source.wssId && target === 'tiktok' && currentMode === 'tiktok-websocket') {
				// For TikTok websocket, we need to check if the connection still exists
				// The wssId alone doesn't mean the connection is active
				// Clear the stale wssId and allow new connection
				stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive' });
				return false;
			} else if (source.wssId) {
				return source.wssId;
			}
		}
	}

    let mode = source.connectionMode;
    // target already declared above
    
    // Validate connection mode - force classic for platforms without websocket support
    if (mode === 'websocket' && !source.supportsWSS) {
        // Check WebSocket support if not already stored
        const hasWebSocketSupport = (target === 'tiktok') || 
            (typeof manifest !== 'undefined' && manifest?.content_scripts?.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            ));
        
        if (!hasWebSocketSupport) {
            console.log(`Platform ${target} doesn't support websocket, switching to classic mode`);
            mode = 'classic';
            // Update the source to reflect the correct mode
            stateManager.updateSource(sourceId, { connectionMode: 'classic', supportsWSS: false });
        }
    }
    
    let windowId; 

	try {
        stateManager.updateSource(sourceId, { status: 'activating' }); 

        if (mode === 'tiktok-websocket' && target === 'tiktok') {
            windowId = await createTikTokWSSFromSource(source); 
        } else if (mode === 'websocket') {
            if (target && target.startsWith('youtube')) {
                windowId = await createYoutubeWebSocketWindowFromSource(source, tabid);
            } else { 
                 windowId = await createWindowWSSFromSource(source, tabid);
            }
        } else { 
			windowId = await createClassicWindowFromSource(source, tabid);
		}

        if (windowId) { 
            
            // For TikTok websocket, windowId is the virtual tab ID (900000+wssId)
            // We need to extract the actual wssId
            let actualWssId = null;
            if (mode === 'tiktok-websocket' && windowId > 900000) {
                actualWssId = windowId - 900000;
            } else if (mode.includes('websocket')) {
                actualWssId = windowId;
            }
            
            stateManager.updateSource(sourceId, {
                vid: windowId, 
                wssId: actualWssId, 
                status: 'active'
            });
            
            // Verify the assignment immediately
            const verifySource = stateManager.getSource(sourceId);
        } else {
            console.warn(`Activation failed for source ${sourceId}, windowId was:`, windowId);
            stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null });
            Toast.error("Activation Failed", `Could not activate ${source.username || source.target}. Main process might have failed.`);
        }
        return windowId; 
	} catch (error) {
		console.error(`Error in createWindow for source ${sourceId} (mode: ${mode}):`, error);
        stateManager.updateSource(sourceId, { status: 'error', error: error.message, vid: null, wssId: null });
		return false; 
	}
}

// Helper function to fetch with retries
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`Fetch attempt ${attempt} for ${url} with timeout of ${options.timeout || 10000}`);
            const response = await ipcRenderer.invoke('nodefetch', {
                url,
                ...options,
                timeout: options.timeout || 10000
            });
            
            if (!response) {
                throw new Error("No response received");
            }
            
            if (response.error) {
                throw new Error(response.error);
            }
            
            if (response.status && response.status >= 500) {
                throw new Error(`Server error: ${response.status}`);
            }
            
            return response;
        } catch (error) {
            lastError = error;
            console.warn(`Fetch attempt ${attempt} failed:`, error.message);
            
            if (attempt < maxRetries) {
                // Exponential backoff: 1s, 2s, 4s
                const delay22 = Math.pow(2, attempt - 1) * 5000;
                console.log(`Retrying in ${delay22}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay22));
            }
        }
    }
    
    throw lastError;
}

async function createClassicWindowFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let urlToLoad = source.url;

    if (source.target?.startsWith("youtube") && source.videoId && (!urlToLoad || !urlToLoad.includes(source.videoId))) {
        const isShort = source.target === "youtubeshorts";
        if (source.videoId) { 
             urlToLoad = `https://www.youtube.com/live_chat?is_popout=1&v=${source.videoId}${isShort ? '&shorts' : ''}`;
             if (source.url !== urlToLoad) {
                stateManager.updateSource(source.id, { url: urlToLoad });
             }
        } else if (source.username) { 
            console.log("Attempting to fetch video ID for YouTube classic activation:", source.username);
            const videoDescArray = await fetchYoutube(source.username, false) || await fetchYoutube(source.username, true);
            if (videoDescArray && videoDescArray.length > 0) {
                const videoDesc = videoDescArray[0];
                stateManager.updateSource(source.id, { videoId: videoDesc.videoId }); 
                urlToLoad = `https://www.youtube.com/live_chat?is_popout=1&v=${videoDesc.videoId}${isShort ? '&shorts' : ''}`;
                stateManager.updateSource(source.id, { url: urlToLoad });
            } else {
                 Toast.error("YouTube Error", `No live video found for ${source.username} to activate in classic mode.`);
                return false;
            }
        }
    } else if (source.target === "rumble" && source.username && !source.chatId && !source.isDirectUrl) {
        // Skip fetching if we already have a chat popup URL
        if (source.url && source.url.includes('/chat/popup/')) {
            console.log("Already have chat popup URL, skipping fetch");
            urlToLoad = source.url;
        } else if (/^\d+$/.test(source.username)) {
            // Check if the username is actually a numeric chat ID
            console.log(`Username appears to be a numeric chat ID: ${source.username}`);
            const chatId = source.username;
            urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
            stateManager.updateSource(source.id, { url: urlToLoad, chatId: chatId });
        } else {
            // For username-based Rumble sources, always fetch fresh video ID
            console.log("Attempting to fetch video ID for Rumble:", source.username);
            let videoId = null;
        
        // Try the primary option first (channel if isChannel is true, user otherwise)
        const tryChannelFirst = source.isChannel !== false; // Default to channel if not specified
        let videoInfo = await fetchRumble(source.username, !tryChannelFirst);
        
        // If not found, try the alternate option
        if (!videoInfo) {
            console.log("Rumble video not found with primary option, trying alternate...");
            videoInfo = await fetchRumble(source.username, tryChannelFirst);
        }
        
        if (videoInfo) {
            // Handle both old format (string) and new format (object)
            videoId = typeof videoInfo === 'string' ? videoInfo : videoInfo.videoId;
            const fullPath = typeof videoInfo === 'string' ? `${videoInfo}.html` : videoInfo.fullPath;
            
            // Fetch the chat ID from the video page
            console.log(`Fetching Rumble chat ID for video: ${videoId} (path: ${fullPath})`);
            const videoUrl = `https://rumble.com/${fullPath}`;
            
            try {
                const response = await fetchWithRetry(videoUrl, {
                    headers: {'User-Agent': config?.global?.userAgent || 'Mozilla/5.0'},
                    timeout: 10000
                }, 2); // Only 2 retries for Rumble to prevent long freezes
                
                if (response.status && response.status !== 200) {
                    console.error(`Rumble fetch returned status ${response.status}`);
                    if (response.status === 404) {
                        Toast.error("Rumble Error", `Video not found: ${videoUrl}`);
                    } else {
                        Toast.error("Rumble Error", `Rumble returned error ${response.status}`);
                    }
                    return false;
                }
                
                const htmlData = response?.data || response;
                if (htmlData && typeof htmlData === 'string') {
                    
                    // Try multiple patterns to find the numeric video/chat ID
                    let chatId = null;
                    
                    // Pattern 1: data-video-id attribute
                    const dataVideoIdMatch = htmlData.match(/data-video-id=["'](\d+)["']/);
                    if (dataVideoIdMatch && dataVideoIdMatch[1]) {
                        chatId = dataVideoIdMatch[1];
                    }
                    
                    // Pattern 2: content_id in hx-vals
                    if (!chatId) {
                        const contentIdMatch = htmlData.match(/&#34;content_id&#34;:(\d+)/);
                        if (contentIdMatch && contentIdMatch[1]) {
                            chatId = contentIdMatch[1];
                        }
                    }
                    
                    // Pattern 3: video_id in JavaScript
                    if (!chatId) {
                        const videoIdMatch = htmlData.match(/video_id:\s*(\d+)/);
                        if (videoIdMatch && videoIdMatch[1]) {
                            chatId = videoIdMatch[1];
                        }
                    }
                    
                    // Pattern 4: cvid in window.rads
                    if (!chatId) {
                        const cvidMatch = htmlData.match(/cvid:(\d+)/);
                        if (cvidMatch && cvidMatch[1]) {
                            chatId = cvidMatch[1];
                        }
                    }
                    
                    if (chatId) {
                        console.log(`Found Rumble chat ID: ${chatId} for video: ${videoId}`);
                        stateManager.updateSource(source.id, { videoId: videoId, chatId: chatId });
                        urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
                        stateManager.updateSource(source.id, { url: urlToLoad });
                    } else {
                        // Debug: look for any numeric IDs
                        const numericIds = htmlData.match(/\b\d{9,10}\b/g);
                        if (numericIds) {
                        }
                        console.warn(`Could not find chat ID for Rumble video: ${videoId}`);
                        Toast.error("Rumble Error", `Could not find chat ID for video ${videoId}`);
                        return false;
                    }
                } else {
                    console.error("Invalid response when fetching Rumble video page");
                    return false;
                }
            } catch (e) {
                console.error("Error fetching Rumble chat ID:", e);
                if (e.message.includes("timeout")) {
                    Toast.error("Rumble Error", "Connection timed out. Rumble might be slow or unreachable.");
                } else {
                    Toast.error("Rumble Error", `Failed to get chat ID: ${e.message}`);
                }
                return false;
            }
            } else {
                Toast.error("Rumble Error", `No live video found for ${source.username}.`);
                return false;
            }
        }
    } else if (source.target === "rumble" && source.chatId) {
        // Direct chat ID provided
        console.log("Using provided chat ID:", source.chatId);
        urlToLoad = `https://rumble.com/chat/popup/${source.chatId}`;
    } else if (source.target === "rumble" && source.isDirectUrl) {
        // Direct Rumble URL that should be used as-is
        console.log("Using direct Rumble URL:", source.url);
        urlToLoad = source.url;
    } else if (source.target === "rumble" && source.videoId && !source.username) {
        // For direct video ID entries, we need to fetch the chat ID
        {
            // Check if the videoId is actually a numeric chat ID
            if (/^\d+$/.test(source.videoId) && source.videoId.length >= 8) {
                // This looks like a chat ID, not a video ID
                console.log(`Video ID appears to be a chat ID: ${source.videoId}`);
                urlToLoad = `https://rumble.com/chat/popup/${source.videoId}`;
                stateManager.updateSource(source.id, { chatId: source.videoId, url: urlToLoad });
            } else {
                // We need to fetch the chat ID
                console.log(`Direct video ID entry needs chat ID, fetching...`);
                try {
                    let videoUrl;
                    
                    // Check if this is a full path or just a video ID
                    if (source.videoId.includes('-') || source.videoId.includes('.html')) {
                        // This looks like a full path
                        videoUrl = `https://rumble.com/${source.videoId}`;
                    } else if (/^[vp]\w+$/.test(source.videoId)) {
                        // This is just a video ID, we need to construct a URL
                        // Unfortunately, we can't know the full path without additional info
                        // Let's try the simple format first
                        videoUrl = `https://rumble.com/${source.videoId}.html`;
                    } else {
                        // Unknown format, try as-is
                        videoUrl = `https://rumble.com/${source.videoId}`;
                    }
                    
                    console.log(`Fetching Rumble page: ${videoUrl}`);
                    const response = await fetchWithRetry(videoUrl, {
                        headers: {'User-Agent': config?.global?.userAgent || 'Mozilla/5.0'},
                        timeout: 10000
                    }, 2); // Only 2 retries for Rumble to prevent long freezes
                
                if (response.status && response.status !== 200) {
                    console.error(`Rumble fetch returned status ${response.status}`);
                    if (response.status === 404) {
                        Toast.error("Rumble Error", `Video not found: ${videoUrl}`);
                    } else {
                        Toast.error("Rumble Error", `Rumble returned error ${response.status}`);
                    }
                    return false;
                }
                
                const htmlData = response?.data || response;
                if (htmlData && typeof htmlData === 'string') {
                    
                    // Try multiple patterns to find the numeric video/chat ID
                    let chatId = null;
                    
                    // Pattern 1: data-video-id attribute
                    const dataVideoIdMatch = htmlData.match(/data-video-id=["'](\d+)["']/);
                    if (dataVideoIdMatch && dataVideoIdMatch[1]) {
                        chatId = dataVideoIdMatch[1];
                    }
                    
                    // Pattern 2: content_id in hx-vals
                    if (!chatId) {
                        const contentIdMatch = htmlData.match(/&#34;content_id&#34;:(\d+)/);
                        if (contentIdMatch && contentIdMatch[1]) {
                            chatId = contentIdMatch[1];
                        }
                    }
                    
                    // Pattern 3: video_id in JavaScript
                    if (!chatId) {
                        const videoIdMatch = htmlData.match(/video_id:\s*(\d+)/);
                        if (videoIdMatch && videoIdMatch[1]) {
                            chatId = videoIdMatch[1];
                        }
                    }
                    
                    // Pattern 4: cvid in window.rads
                    if (!chatId) {
                        const cvidMatch = htmlData.match(/cvid:(\d+)/);
                        if (cvidMatch && cvidMatch[1]) {
                            chatId = cvidMatch[1];
                        }
                    }
                    
                    if (chatId) {
                        console.log(`Found Rumble chat ID: ${chatId} for video: ${source.videoId}`);
                        stateManager.updateSource(source.id, { chatId: chatId });
                        urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
                        stateManager.updateSource(source.id, { url: urlToLoad });
                    } else {
                        Toast.error("Rumble Error", `Could not find chat ID for video ${source.videoId}`);
                        return false;
                    }
                }
            } catch (e) {
                console.error("Error fetching Rumble chat ID:", e);
                if (e.message.includes("timeout")) {
                    Toast.error("Rumble Error", "Connection timed out. Rumble might be slow or unreachable.");
                } else {
                    Toast.error("Rumble Error", `Failed to get chat ID: ${e.message}`);
                }
                return false;
            }
            }
        }
    }
    
    if (!urlToLoad) {
        Toast.error("Activation Error", `No URL specified for ${source.username || source.target} (classic mode).`);
        return false;
    }
    
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[CreateClassicWindow] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateClassicWindow] Using AUTO user agent from config:', conf.userAgent);
    }

    const targetSourceFile = source.target === "youtubeshorts" ? "youtube" : source.target;
    const scriptPath = source.sourceFile || `sources/${targetSourceFile}.js`; // Use sourceFile from state if available

    try {
        // For now, fall back to sync while we debug the async issue
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlToLoad),
            config: conf,
            visible: source.isVisible,
            muted: source.isMuted,
            source: scriptPath, 
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            isBetaMode: isBetaMode,
            domain: new URL(urlToLoad).hostname
        });
        return response;
        
        // TODO: Fix async implementation
        /*
        const response = await window.ipc.send('createWindow', {
            url: rewriteKickUrl(urlToLoad),
            config: conf,
            visible: source.isVisible,
            muted: source.isMuted,
            source: scriptPath, 
            tab: tabid,
            isBetaMode: isBetaMode,
            domain: new URL(urlToLoad).hostname
        });
        return response; 
        */
    } catch(e) {
        console.error("Error in createClassicWindowFromSource:", e);
        Toast.error("Window Error", `Failed to create classic window: ${e.message}`);
        return false;
    }
}

async function createWindowWSSFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] };
    if (conf.wss) conf = { ...conf, ...conf.wss };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[CreateWindowWSS] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateWindowWSS] Using AUTO user agent from config:', conf.userAgent);
    }

    let urlWSS;
    if (devmode || sourcemode) {
        const baseUrl = sourcemode || 'http://localhost:8080/';
        urlWSS = `${baseUrl}sources/websocket/${source.target}.html?channel=${source.username}`;
        if (devmode) urlWSS += '&devmode=';
    } else {
        const domain = isBetaMode ? 'https://socialstream.ninja/beta/' : 'https://socialstream.ninja/';
        urlWSS = `${domain}sources/websocket/${source.target}.html?channel=${source.username}`;
    }
    
    const scriptPath = source.sourceFile || `sources/websocket/${source.target}.js`;


    try {
        // For now, fall back to sync while we debug the async issue
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlWSS.trim()),
            muted: source.isMuted,
            visible: source.isVisible,
            source: scriptPath, 
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            wss: true,
            config: conf,
            isBetaMode: isBetaMode
        });
        return response; 
    } catch (e) {
        console.error("Error in createWindowWSSFromSource:", e);
        Toast.error("WebSocket Error", `Failed to create WebSocket window: ${e.message}`);
        return false;
    }
}

async function createYoutubeWebSocketWindowFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] }; 
    if (conf.wss) conf = { ...conf, ...conf.wss };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[CreateYouTubeWSS] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateYouTubeWSS] Using AUTO user agent from config:', conf.userAgent);
    }

    const queryParams = new URLSearchParams();
    if (source.videoId) queryParams.set('videoId', source.videoId);
    else if (source.username) queryParams.set('channel', source.username);
    else {
        Toast.error("YouTube WSS Error", "Missing Video ID or Username for YouTube WebSocket.");
        return false;
    }

    let baseUrl;
    if (devmode || sourcemode) {
        baseUrl = sourcemode ? `${sourcemode}sources/websocket/youtube.html` : `http://localhost:8080/sources/websocket/youtube.html`;
        if (devmode && !queryParams.has('devmode')) queryParams.set('devmode','');
    } else {
        const domain = isBetaMode ? 'https://socialstream.ninja/beta/' : 'https://socialstream.ninja/';
        baseUrl = `${domain}sources/websocket/youtube.html`;
    }
    const urlWSS = `${baseUrl}?${queryParams.toString()}`;
    
    // For YouTube WSS, the script path is specific
    const scriptPath = devmode || sourcemode ? 
                       (sourcemode ? `${sourcemode}sources/websocket/youtube.js` : `http://localhost:8080/sources/websocket/youtube.js`) : 
                       (isBetaMode ? 'https://socialstream.ninja/beta/sources/websocket/youtube.js' : 'https://socialstream.ninja/sources/websocket/youtube.js');

    try {
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlWSS.trim()),
            muted: source.isMuted,
            visible: source.isVisible,
            source: scriptPath,
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            wss: true,
            config: conf,
            isBetaMode: isBetaMode
        });
         return response; 
    } catch (e) {
        console.error("Error in createYoutubeWebSocketWindowFromSource IPC call:", e, "URL:", urlWSS, "Script:", scriptPath);
        Toast.error("YouTube WSS Error", `Failed to create YouTube WebSocket: ${e.message}`);
        return false;
    }
}

async function createTikTokWSSFromSource(source) { 
    if (!ipcRenderer) return false;
    const cleanUsername = source.username?.replace('@', '').trim();
    if (!cleanUsername) {
        Toast.warning("TikTok WSS Error", 'No username found for TikTok connection');
        return false;
    }

    updateConnectionStatus(document.querySelector(`[data-source-id="${source.id}"]`), 'connecting');

    try {
        // Check if we have stored credentials for this source
        const sessionId = source.tiktokSessionId || null;
        const ttTargetIdc = source.tiktokTtTargetIdc || null;
        
        const wssID = ipcRenderer.sendSync('createTikTokConnection', { 
            username: cleanUsername,
            sessionId: sessionId,
            ttTargetIdc: ttTargetIdc
        }); 
        
        if (wssID === null || typeof wssID === 'undefined') { 
            throw new Error('Failed to create TikTok connection (IPC response null/undefined from main)');
        }
        return wssID; 
    } catch (error) {
        console.error('Error in TikTok WebSocket connection from source:', error);
        Toast.warning("TikTok WSS Error", `Connection Failed: ${error.message || 'Please try again.'}`);
        throw error; 
    }
}

// Simple modal functions for TikTok auth
function showModal(content) {
    // Remove any existing modal
    closeModal();
    
    const modal = document.createElement('div');
    modal.id = 'tiktok-auth-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    modal.innerHTML = content;
    
    // Close on background click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeModal();
        }
    });
    
    document.body.appendChild(modal);
}

function closeModal() {
    const modal = document.getElementById('tiktok-auth-modal');
    if (modal) {
        modal.remove();
    }
}

function showTikTokSignInMenu(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source) return;
    
    const isAuthenticated = source.tiktokSessionId ? true : false;
    
    let menuContent = `
        <div style="padding: 20px; background: #2a2a2a; border-radius: 8px;">
            <h3 style="margin-bottom: 15px;">TikTok Authentication</h3>
            ${isAuthenticated ? 
                `<p style="color: #4ade80; margin-bottom: 15px;">âœ“ Currently signed in</p>` : 
                `<p style="margin-bottom: 15px;">Sign in to TikTok for enhanced features:</p>
                <ul style="margin-bottom: 15px; margin-left: 20px;">
                    <li>Send chat messages</li>
                    <li>More stable connection</li>
                    <li>Access to all features</li>
                </ul>`
            }
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                ${!isAuthenticated ? `
                    <button onclick="tiktokSignIn('${sourceId}')" class="button" style="background: #6366f1;">
                        ğŸŒ Sign in with Browser
                    </button>
                    <button onclick="tiktokManualSignIn('${sourceId}')" class="button" style="background: #6b7280;">
                        ğŸ“ Enter Cookies Manually
                    </button>
                ` : `
                    <button onclick="clearTikTokAuth('${sourceId}')" class="button" style="background: #ef4444;">
                        ğŸ—‘ï¸ Clear Authentication
                    </button>
                `}
                <button onclick="closeModal()" class="button" style="background: #374151;">
                    Cancel
                </button>
            </div>
        </div>
    `;
    
    showModal(menuContent);
}

function clearTikTokAuth(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (source) {
        stateManager.updateSource(sourceId, {
            tiktokSessionId: null,
            tiktokTtTargetIdc: null
        });
        
        // Update UI
        const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (entry) {
            const signInBtn = entry.querySelector('[data-tiktok-signin]');
            if (signInBtn) {
                signInBtn.innerHTML = 'ğŸ”‘ TikTok Sign-in';
                signInBtn.classList.remove('authenticated');
            }
        }
        
        Toast.success("TikTok Sign-in", "Authentication cleared");
        closeModal();
    }
}

async function tiktokSignIn(sourceId) {
    closeModal();
    try {
        const result = await ipcRenderer.invoke('authenticateTikTok');
        if (result.success && result.credentials) {
            // Store credentials in the source
            const source = stateManager.getSource(sourceId);
            if (source) {
                stateManager.updateSource(sourceId, {
                    tiktokSessionId: result.credentials.sessionId,
                    tiktokTtTargetIdc: result.credentials.ttTargetIdc
                });
                Toast.success("TikTok Sign-in", "Successfully signed in to TikTok!");
                
                // Update UI to show authenticated status
                const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
                if (entry) {
                    const signInBtn = entry.querySelector('[data-tiktok-signin]');
                    if (signInBtn) {
                        signInBtn.innerHTML = 'âœ“ Signed In';
                        signInBtn.classList.add('authenticated');
                    }
                }
            }
        } else {
            Toast.error("TikTok Sign-in", result.error || "Sign-in failed");
        }
    } catch (error) {
        console.error('TikTok sign-in error:', error);
        Toast.error("TikTok Sign-in", error.message || "Sign-in failed");
    }
}

async function tiktokManualSignIn(sourceId) {
    closeModal();
    try {
        const result = await ipcRenderer.invoke('promptTikTokCookies');
        if (result.success && result.credentials) {
            // Store credentials in the source
            const source = stateManager.getSource(sourceId);
            if (source) {
                stateManager.updateSource(sourceId, {
                    tiktokSessionId: result.credentials.sessionId,
                    tiktokTtTargetIdc: result.credentials.ttTargetIdc
                });
                Toast.success("TikTok Sign-in", "Successfully added TikTok credentials!");
                
                // Update UI to show authenticated status
                const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
                if (entry) {
                    const signInBtn = entry.querySelector('[data-tiktok-signin]');
                    if (signInBtn) {
                        signInBtn.innerHTML = 'âœ“ Signed In';
                        signInBtn.classList.add('authenticated');
                    }
                }
            }
        }
    } catch (error) {
        console.error('TikTok manual sign-in error:', error);
        Toast.error("TikTok Sign-in", error.message || "Failed to add credentials");
    }
}

function cleanupTikTokConnection(entry, errorMessage = null) {
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    if (errorMessage) {
        updateConnectionStatus(entry, 'error', errorMessage);
    } else {
        updateConnectionStatus(entry, 'stopped', 'Connection stopped.');
        setTimeout(()=> updateConnectionStatus(entry, 'clear'), 3000);
    }
}

function updateUIForActiveTikTokConnection(element) {
    if (element) updateConnectionStatus(element, 'connected');
}

function updateConnectionStatus(element, status, message = null) {
	if (!element) return;
	let statusElement = element.querySelector('.ws-status');
	if (!statusElement) { 
		statusElement = document.createElement('div');
		statusElement.className = 'ws-status';
		const controlPanel = element.querySelector('.control-panel');
        if (controlPanel) {
            element.insertBefore(statusElement, controlPanel.nextSibling); 
        } else { 
            element.appendChild(statusElement);
        }
	}
	statusElement.classList.remove('hidden', 'error', 'connecting', 'connected', 'retry', 'stopped');
    statusElement.style.display = 'inline-flex'; 

	switch (status) {
		case 'connecting':
			statusElement.classList.add('connecting');
			statusElement.innerHTML = '<i class="las la-sync fa-spin"></i> Connecting...';
			break;
		case 'connected':
			statusElement.classList.add('connected');
			statusElement.innerHTML = '<i class="las la-check-circle"></i> WebSocket Connected';
			break;
		case 'error':
			statusElement.classList.add('error');
			statusElement.innerHTML = `<i class="las la-exclamation-circle"></i> ${message || 'Connection error'}`;
			break;
		case 'retry': 
			statusElement.classList.add('retry'); 
			statusElement.innerHTML = `<i class="las la-sync fa-spin"></i> ${message || 'Retrying connection...'}`;
			break;
		case 'stopped':
			statusElement.classList.add('stopped');
            statusElement.innerHTML = `<i class="las la-hand-paper"></i> ${message || 'Connection stopped'}`;
			setTimeout(() => {
				if (statusElement.classList.contains('stopped')) statusElement.style.display = 'none';
			}, 5000);
			break;
		case 'clear':
		default:
			statusElement.style.display = 'none'; 
            statusElement.innerHTML = '';
			break;
	}
}


async function signin(ele, tabid = false) {
    // Debug logs removed - they show the parent window's UA, not the sign-in window's
    
    if (!ipcRenderer) { console.error('IPC not available for signin'); return; }

    const entry = ele.closest('.entry');
    if (!entry) { console.error('Could not find parent entry element for signin'); return; }

    const sourceId = entry.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    console.log(`[SIGNIN DEBUG] Source ID: ${sourceId}, Source:`, source);
    if (!source && !entry.dataset.target) { 
         console.error('Cannot signin: no source data or target on element.'); return;
    }
    const targetPlatform = source ? source.target : entry.dataset.target;
    let urlForSignin = source ? source.url : entry.dataset.url; 

    let signinUrl = config?.[targetPlatform]?.signin?.url;
    if (!signinUrl && urlForSignin) {
        try {
            signinUrl = "https://" + getPrimaryDomain(urlForSignin);
        } catch { /* Use platform default */ }
    }
    if (!signinUrl) { 
        if (targetPlatform === 'youtube') signinUrl = 'https://youtube.com';
        else if (targetPlatform === 'twitch') signinUrl = 'https://www.twitch.tv';
        else { Toast.error("Sign-in Error", `No sign-in URL configured for ${targetPlatform}.`); return; }
    }

    let conf = config.global ? { ...config.global } : {};
    if (config.global?.signin) conf = { ...conf, ...config.global.signin };
    if (config[targetPlatform]) conf = { ...conf, ...config[targetPlatform] };
    if (config[targetPlatform]?.signin) conf = { ...conf, ...config[targetPlatform].signin };
    
    // Apply custom user agent if set
    if (source && source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        console.log('[SignIn] Using custom user agent:', conf.userAgent);
    } else {
        console.log('[SignIn] Using AUTO user agent from config:', conf.userAgent);
    }
    
    console.log(`[SIGN-IN DEBUG] Platform: ${targetPlatform}, URL: ${signinUrl}, CustomSession: ${source ? (source.customSession || 'AUTO') : 'AUTO'}`);
    try {
        const response = ipcRenderer.sendSync('signIn', {
            url: signinUrl.trim(),
            muted: true, visible: true, source: false, tab: tabid,
            customSession: source ? (source.customSession || 'AUTO') : 'AUTO',
            config: conf, configs: config
        });
        console.log("Sign-in window created with ID:", response);
        if (response && ipcRenderer) { 
            ipcRenderer.once(`window-closed-${response}`, () => {
                Toast.info("Sign-in window closed.", "Checking if source needs refresh...");
                
                // Just call refreshWindow directly with the element
                refreshWindow(ele);
            });
        }
        return response; 
    } catch (err) {
        console.error('Signin failed:', err);
        Toast.error("Sign-in Error", `Could not open sign-in window: ${err.message}`);
        return false;
    }
}

function refreshActivatedWindow(ele) { 
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;

    if (source && source.vid) { 
        refreshWindow(ele); 
    } else {
        Toast.info("Refresh Info", "Sign-in complete. Activate the source if it's not already running.");
    }
}

function processSettingsAndCreateSources() {
    console.log('[Startup] Processing settings and creating sources');
    cleanupYouTubeGroups(); 
    
    // Fix orphaned YouTube sources that should belong to groups
    const allSources = stateManager.getSources();
    allSources.forEach(source => {
        if (source.groupId && source.videoId && source.target && source.target.startsWith('youtube')) {
            const group = stateManager.getGroup(source.groupId);
            if (group && !group.streams.includes(source.id)) {
                console.log("Fixing orphaned YouTube source:", source.id, "adding to group:", source.groupId);
                group.streams.push(source.id);
                stateManager.persist();
            }
        }
    });

    const sourcesContainer = document.getElementById("sources");
    sourcesContainer.querySelectorAll(".entry:not(#sourceTemplate):not(#groupTemplate)").forEach(el => el.remove());

    const groups = stateManager.getGroups();
    groups.forEach(group => {
        if (!document.querySelector(`[data-group-id="${group.id}"]`)) {
            const groupElement = createGroupElement(group.id);
            if (groupElement) {
                sourcesContainer.appendChild(groupElement);
                if (group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                    setTimeout(async () => {
                        console.log('Auto-activating YouTube group from processSettings:', group.username);
                        await handleYouTubeActivation(
                            group.username,
                            group.target === "youtubeshorts",
                            false, 
                            true,  
                            group.isChannel
                        );
                    }, 2500 + Math.random() * 1000);
                }
            }
        } else { 
            const groupElement = document.querySelector(`[data-group-id="${group.id}"]`);
            const streamsContainer = groupElement?.querySelector('.stream-group');
            if (streamsContainer) {
                console.log("Processing existing group in processSettings:", group.id, "streams:", group.streams);
                group.streams.forEach(sourceId => {
                    if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                        console.log("Creating source element for existing group stream in processSettings:", sourceId);
                        const sourceElement = createSourceElement(sourceId);
                        if (sourceElement) {
                            console.log("Appending to existing group in processSettings:", sourceId);
                            streamsContainer.appendChild(sourceElement);
                        } else {
                            console.error("Failed to create source element in processSettings:", sourceId);
                        }
                    }
                });
            }
        }
    });

    const standaloneSources = stateManager.getSources().filter(s => !s.groupId); 
    console.log(`[Startup] Found ${standaloneSources.length} standalone sources`);
    standaloneSources.forEach(source => {
         if (!document.querySelector(`[data-source-id="${source.id}"]`)) {
            console.log(`[Startup] Creating element for source ${source.id}: autoActivate=${source.autoActivate}`);
            const sourceElement = createSourceElement(source.id);
            if (sourceElement) {
                sourcesContainer.appendChild(sourceElement);
                if (source.autoActivate && !source.vid && !source.wssId) { 
                    setTimeout(async () => {
                        const activateButton = sourceElement.querySelector('[data-activatehtml]');
                        const currentSrcState = stateManager.getSource(source.id); 
                        if (activateButton && currentSrcState && !currentSrcState.vid && !currentSrcState.wssId) {
                            await createWindow(activateButton);
                        }
                    }, 2000 + Math.random() * 1000);
                }
            }
        }
    });
    manageWelcomePage();
}


function isVideoAlreadyAdded(videoId) {
    if (!videoId) return false;
    return stateManager.isVideoIdAdded(videoId);
}


function initializeFeatures() {
    const betaToggle = new BetaToggle(); 
	betaToggle.checkBetaAvailability();

    streamSelector = new YouTubeStreamSelector(); 
	youtubeStatusManager = new YouTubeStatusManager(); 
}

class BetaToggle {
	constructor() {
		this.container = null;
		this.betaVersion = null;
		this.mainVersion = null;
		this.cachedManifest = {}; 
	}
	async checkBetaAvailability() {
		try {
            const betaUrl = 'https://socialstream.ninja/beta/manifest.json';
			const mainUrl = 'https://socialstream.ninja/manifest.json';
			if (this.cachedManifest[betaUrl]) {
				this.betaVersion = this.cachedManifest[betaUrl].version;
			}
			if (this.cachedManifest[mainUrl]) {
				this.mainVersion = this.cachedManifest[mainUrl].version;
			}
			if (!this.betaVersion || !this.mainVersion) {
				const fetchPromises = [];
				if (!this.betaVersion) {
					fetchPromises.push(
						fetch(betaUrl)
							.then(response => response.json())
							.then(data => { this.cachedManifest[betaUrl] = data; this.betaVersion = data.version; })
                            .catch(e => console.warn("Failed to fetch beta manifest", e))
					);
				}
				if (!this.mainVersion) {
					fetchPromises.push(
						fetch(mainUrl)
							.then(response => response.json())
							.then(data => { this.cachedManifest[mainUrl] = data; this.mainVersion = data.version; })
                            .catch(e => console.warn("Failed to fetch main manifest", e))
					);
				}
				await Promise.all(fetchPromises);
			}

            if (this.betaVersion && this.mainVersion) {
    			this.createToggle();
            } else {
                console.warn("Could not fetch necessary version manifests to create Beta Toggle.");
            }
		} catch (error) {
			console.error('Error checking beta availability:', error);
		}
	}
	compareVersions(version1, version2) { 
        if (!version1 || !version2) return 0;
		const parts1 = version1.split('.').map(Number);
		const parts2 = version2.split('.').map(Number);
		for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
			const num1 = parts1[i] || 0;
			const num2 = parts2[i] || 0;
			if (num1 > num2) return 1;
			if (num2 > num1) return -1;
		}
		return 0;
    }

	createToggle() {
        if (document.querySelector('.beta-toggle')) return;
        const currentBetaMode = stateManager.state.global.betaMode;

		this.container = document.createElement('div');
		this.container.className = 'beta-toggle';
        const versions = document.createElement('div');
		versions.className = 'beta-toggle-versions';
		versions.innerHTML = `
			<div>Production: v${this.mainVersion || 'N/A'}</div>
			<div>Beta: v${this.betaVersion || 'N/A'}</div>
		`;

		const toggleSwitchContainer = document.createElement('div');
        toggleSwitchContainer.className = 'beta-toggle-switch-container';
		const toggle = document.createElement('div');
		toggle.className = `beta-toggle-switch${currentBetaMode ? ' active' : ''}`;
		toggle.addEventListener('click', () => this.handleToggle());
        toggleSwitchContainer.appendChild(toggle);

		const label = document.createElement('span');
		label.className = 'beta-toggle-label';
		label.textContent = currentBetaMode ? 'Beta Active' : 'Production Active';

		this.container.appendChild(versions);
		this.container.appendChild(toggleSwitchContainer);
		this.container.appendChild(label);

        const sourcesDiv = document.getElementById("sources");
        if (sourcesDiv && sourcesDiv.firstChild) {
    		sourcesDiv.insertBefore(this.container, sourcesDiv.firstChild);
        } else if (sourcesDiv) {
            sourcesDiv.appendChild(this.container);
        }
	}
	async handleToggle() {
		const newBetaState = !stateManager.state.global.betaMode;
		stateManager.updateGlobal({ betaMode: newBetaState }); 
        isBetaMode = newBetaState; 

		const toggle = this.container.querySelector('.beta-toggle-switch');
		toggle.classList.toggle('active', newBetaState);
		const label = this.container.querySelector('.beta-toggle-label');
		label.textContent = newBetaState ? 'Beta Active' : 'Production Active';
        
        Toast.info("Mode Changed", `Switched to ${newBetaState ? 'Beta' : 'Production'} mode. Restart app or refresh page for full effect if issues arise.`);

		if (!devmode && !sourcemode) {
            console.log(`Beta mode toggled. Now: ${newBetaState}. Re-initializing parts or consider app reload.`);
            await initializeApplication(); 
		} else {
            console.log("Beta mode toggled, but dev/sourcemode active.");
        }
	}
}

async function initializeConfig() { 
    configReady = false;
	try {
		const os = getOperatingSystem();
		const configFileName = getConfigFileName(os);
		const currentBetaMode = stateManager.initialized ? stateManager.state.global.betaMode : (localStorage.getItem('betaMode') === 'true'); 

		const configUrl =
			sourcemode ? `${sourcemode}/settings/${configFileName}` :
			devmode ? `file:///C:/Users/steve/Code/social_stream/settings/${configFileName}` :
			currentBetaMode ? `https://socialstream.ninja/beta/settings/${configFileName}` :
			`https://socialstream.ninja/settings/${configFileName}`;
		
		const response = await fetch(configUrl.trim());
		const data = await response.json();
		if (data) {
			config = data;
			localStorage.setItem('config', JSON.stringify(data));
		}
	} catch (e) {
        Toast.error("Error", 'Failed to load the user-agent config file.');
		console.error('Failed to load remote config:', e);
		const storedConfigTemp = localStorage.getItem('config'); 
		if (storedConfigTemp) {
			try {
				const parsedConfig = JSON.parse(storedConfigTemp);
				if (!parsedConfig || Object.keys(parsedConfig).length === 0) {
					console.error('Parsed stored config is empty, using default.');
					config = getDefaultConfig();
				} else {
					config = parsedConfig;
				}
			} catch (parseError) {
				console.error('Failed to parse stored config, using default:', parseError);
				config = getDefaultConfig();
			}
		} else { 
			config = getDefaultConfig();
		}
	}
	configReady = true;
	return config;
}

// DOMContentLoaded Listener
document.addEventListener('DOMContentLoaded', async function() {
    await stateManager.init();
    
    // Clean up stale window IDs on startup
    const sources = stateManager.getSources();
    for (const source of sources) {
        // Check regular windows
        if (source.vid && ipcRenderer) {
            const windowExists = await ipcRenderer.invoke('checkWindowExists', { vid: source.vid });
            if (!windowExists) {
                stateManager.updateSource(source.id, { vid: null, status: 'inactive' });
            }
        }
        
        // Clean up websocket IDs on startup - websocket connections don't persist across app restarts
        if (source.wssId) {
            console.log(`Clearing stale wssId ${source.wssId} for ${source.id} on startup`);
            stateManager.updateSource(source.id, { vid: null, wssId: null, status: 'inactive' });
        }
        
        // Clear video IDs and chat IDs for username-based Rumble sources
        if (source.target === 'rumble' && source.username && (source.videoId || source.chatId)) {
            stateManager.updateSource(source.id, { videoId: null, chatId: null, url: null });
        }
    }
    
    // Listen for source updates to keep UI in sync
    stateManager.on('sourceUpdated', ({ sourceId, updates }) => {
        console.log(`Source ${sourceId} updated:`, updates);
        const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (sourceElement) {
            const source = stateManager.getSource(sourceId);
            if (source) {
                // Update mute button state if mute state changed
                if ('isMuted' in updates) {
                    const muteButton = sourceElement.querySelector('[data-togglemute]');
                    if (muteButton) {
                        muteButton.classList.toggle('active', source.isMuted);
                        console.log(`Updated mute button UI for ${sourceId}: ${source.isMuted}`);
                    }
                }
                // Update visibility button state if visibility changed
                if ('isVisible' in updates) {
                    const visibilityButton = sourceElement.querySelector('[data-togglehtml]');
                    if (visibilityButton) {
                        visibilityButton.classList.toggle('active', !source.isVisible);
                    }
                }
            }
        }
    });
    
    // Start auto-checking for YouTube groups and Rumble sources with auto-activate enabled
    setTimeout(() => {
        // Verify fetchYoutube is available
        if (typeof fetchYoutube !== 'function') {
            console.error("Warning: fetchYoutube function not available. YouTube fallback scraping will not work.");
            console.error("Make sure youtube.js is properly loaded.");
        } else {
            console.log("fetchYoutube function is available for fallback.");
        }
        
        // Check YouTube groups
        const groups = stateManager.getGroups();
        groups.forEach(group => {
            if (group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                console.log(`Starting auto-check for YouTube group on startup: ${group.username}`);
                startYouTubeGroupAutoCheck(group.id);
            }
        });
        
        // Check Rumble sources
        const sources = stateManager.getSources();
        sources.forEach(source => {
            // Only auto-check username-based Rumble sources
            if (source.autoActivate && source.target === 'rumble' && source.username && source.status !== 'active') {
                console.log(`Starting auto-check for Rumble source on startup: ${source.username}`);
                startRumbleAutoCheck(source.id);
            }
        });
    }, 2000); // Small delay to ensure UI is ready 

    // Check for pending import from session import
    const pendingImport = localStorage.getItem('pendingImport');
    if (pendingImport) {
        try {
            const importData = JSON.parse(pendingImport);
            // Restore all the localStorage data from the import
            for (const [key, value] of Object.entries(importData)) {
                if (value !== null) {
                    localStorage.setItem(key, value);
                }
            }
            localStorage.removeItem('pendingImport');
            // Re-initialize state manager with imported data
            await stateManager.init();
            Toast.success('Import Complete', 'Session data has been imported successfully');
        } catch (e) {
            console.error('Error applying pending import:', e);
            Toast.error('Import Error', 'Failed to apply imported session data');
            localStorage.removeItem('pendingImport');
        }
    }

    isBetaMode = stateManager.state.global.betaMode;
    localStorage.setItem('betaMode', isBetaMode.toString());
    localStorage.setItem('youtubeAutoAdd', stateManager.state.global.youtubeAutoAdd.toString());
    localStorage.setItem('youtubeAutoCleanup', stateManager.state.global.youtubeAutoCleanup.toString());
    localStorage.setItem('youtubeCheckInterval', stateManager.state.global.youtubeCheckInterval.toString());

    /* Modified sourceAdded listener */
    stateManager.on('sourceAdded', ({ source }) => {
        console.log("sourceAdded event:", source.id, "videoId:", source.videoId, "groupId:", source.groupId);
        let element = document.querySelector(`[data-source-id="${source.id}"]`);
        if (element) {
            console.warn(`sourceAdded listener: Element for source ${source.id} already exists. Updating UI.`);
            updateSourceUI(element, source);
            // Ensure it's in the correct parent if misplaced (e.g., if group DOM wasn't ready)
            const correctParentSelector = source.groupId ? `[data-group-id="${source.groupId}"] .stream-group` : '#sources';
            const correctParent = document.querySelector(correctParentSelector);
            if (correctParent && element.parentElement !== correctParent && !(element.parentElement.id === 'sources' && !source.groupId) ) {
                 console.log(`Moving ${source.id} to correct parent: ${correctParentSelector}`);
                 correctParent.appendChild(element);
            }
            return;
        }

        element = createSourceElement(source.id); 
        if (!element) {
            console.error(`sourceAdded listener: Failed to create element for source ${source.id}`);
            return;
        }

        if (!source.groupId) {
            document.getElementById("sources").appendChild(element);
        } else {
            const groupElement = document.querySelector(`[data-group-id="${source.groupId}"]`);
            if (groupElement) {
                const streamsContainer = groupElement.querySelector('.stream-group');
                if (streamsContainer) {
                    streamsContainer.appendChild(element);
                } else {
                    console.warn(`sourceAdded listener: '.stream-group' not found in group ${source.groupId}. Appending source ${source.id} to group header as fallback.`);
                    groupElement.appendChild(element); 
                }
            } else {
                console.warn(`sourceAdded listener: Group element for groupId ${source.groupId} not found. Appending source ${source.id} to main 'sources' list temporarily.`);
                document.getElementById("sources").appendChild(element);
            }
        }
        manageWelcomePage();
    });


    stateManager.on('sourceUpdated', ({ sourceId, updates, oldState }) => {
        const element = document.querySelector(`[data-source-id="${sourceId}"]`);
        const source = stateManager.getSource(sourceId);
        if (element && source) {
            updateSourceUI(element, source);
        }
        
        if ('groupId' in updates) {
            const currentElement = document.querySelector(`[data-source-id="${sourceId}"]`); 
            if (!currentElement) return; 

            if (oldState.groupId && oldState.groupId !== updates.groupId) {
                const oldGroupStreamsContainer = document.querySelector(`[data-group-id="${oldState.groupId}"] .stream-group`);
                const elInOldGroup = oldGroupStreamsContainer?.querySelector(`[data-source-id="${sourceId}"]`);
                elInOldGroup?.remove();
            }
            
            if (updates.groupId) {
                 const newGroupEl = document.querySelector(`[data-group-id="${updates.groupId}"]`);
                 const streamsContainer = newGroupEl?.querySelector('.stream-group');
                 if (streamsContainer && !streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                    streamsContainer.appendChild(currentElement); 
                 } else if (!streamsContainer && newGroupEl && !newGroupEl.querySelector(`[data-source-id="${sourceId}"]`)) {
                    newGroupEl.appendChild(currentElement); 
                 }
            } else if (!updates.groupId && currentElement.parentElement?.closest?.('[data-is-group-header="true"]')) { 
                 if (currentElement.parentElement.id !== 'sources') {
                    document.getElementById("sources").appendChild(currentElement); 
                 }
            }
        }
    });

    stateManager.on('sourceRemoved', ({ sourceId, source }) => {
        const element = document.querySelector(`[data-source-id="${sourceId}"]`);
        element?.remove();
        manageWelcomePage();
    });

    /* Modified groupAdded listener */
    stateManager.on('groupAdded', ({ group }) => {
        let groupElement = document.querySelector(`[data-group-id="${group.id}"]`);
        if (groupElement) {
            console.warn(`groupAdded listener: Group element for ID ${group.id} already exists. Updating UI and checking children.`);
            updateGroupUI(groupElement, group); 
            const streamsContainer = groupElement.querySelector('.stream-group');
            if (streamsContainer) {
                group.streams.forEach(sourceId => {
                    if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                        const tempSourceElement = document.getElementById("sources").querySelector(`:scope > [data-source-id="${sourceId}"]`);
                        if (tempSourceElement) {
                            streamsContainer.appendChild(tempSourceElement); 
                        } else {
                            const sourceElement = createSourceElement(sourceId); 
                            if (sourceElement) streamsContainer.appendChild(sourceElement);
                        }
                    }
                });
            }
            return;
        }

        groupElement = createGroupElement(group.id); 
        if (groupElement) {
            document.getElementById("sources").appendChild(groupElement);
            const streamsContainer = groupElement.querySelector('.stream-group');
            if (streamsContainer) {
                group.streams.forEach(sourceId => {
                    const sourceState = stateManager.getSource(sourceId);
                    if (sourceState?.groupId === group.id) { 
                        const tempSourceElement = document.getElementById("sources").querySelector(`:scope > [data-source-id="${sourceId}"]`);
                        if (tempSourceElement) { 
                            if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) { 
                                streamsContainer.appendChild(tempSourceElement); 
                            }
                        }
                    }
                });
            }
        }
        manageWelcomePage();
    });
    
    stateManager.on('groupUpdated', ({ groupId, updates }) => {
        const element = document.querySelector(`[data-group-id="${groupId}"]`);
        const group = stateManager.getGroup(groupId);
        if (element && group) {
            updateGroupUI(element, group);
        }
    });
    
    stateManager.on('groupRemoved', ({ groupId, group }) => {
        const element = document.querySelector(`[data-group-id="${groupId}"]`);
        element?.remove();
        manageWelcomePage();
    });
    
    stateManager.on('globalUpdated', ({ updates }) => {
        if ('betaMode' in updates) {
            isBetaMode = updates.betaMode;
             console.log("Global betaMode updated, re-initializing application for full effect.");
             initializeApplication(); 
        }
        if (youtubeStatusManager && (
            'youtubeAutoAdd' in updates || 
            'youtubeAutoCleanup' in updates || 
            'youtubeCheckInterval' in updates
        )) {
            youtubeStatusManager.settingsChanged(updates); 
        }
    });


    initializeFeatures(); 
	await checkForUpdates();

	let ready = await initializeApplication();
	if (ready) {
		processSettingsAndCreateSources(); 
	} else {
        console.error("Application initialization failed. Some features may be unavailable.");
        Toast.error("Initialization Error", "App could not start correctly. Please check console or try restarting.");
    }

	if (!window.streamSelector) {
		window.streamSelector = new YouTubeStreamSelector();
	}

	const navigationLinks = document.querySelectorAll('#main-navigation a');
    const frame1 = document.getElementById('frame1');
	const frame2 = document.getElementById('frame2');
	const frame3 = document.getElementById('frame3');

	function switchToPage(pageId) { 
        navigationLinks.forEach(link => {
			link.classList.toggle('active', link.dataset.page === pageId);
		});

        document.getElementById('streams-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('dashboard-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('link-overlay-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('vdo-ninja-page')?.style.setProperty('display', 'none', 'important');
        if (frame1) frame1.style.setProperty('display', 'none', 'important');
        if (frame2) frame2.style.setProperty('display', 'none', 'important');
        if (frame3) frame3.style.setProperty('display', 'none', 'important');


        const streamsPage = document.getElementById('streams-page');
        const dashboardPage = document.getElementById('dashboard-page');
        const linkOverlayPage = document.getElementById('link-overlay-page');
        const vdoNinjaPage = document.getElementById('vdo-ninja-page');

		if (pageId === 'dashboard' || pageId === 'event-flow-editor') {
			if (dashboardPage) dashboardPage.style.display = 'block'; 
			if (frame2) {
				frame2.style.display = 'block'; 
                const viewFunction = pageId === 'dashboard' ? 'showDashboardView' : 'showEditorView';
                // Use postMessage for cross-origin communication
                const sendViewMessage = () => {
                    try {
                        frame2.contentWindow.postMessage({ action: viewFunction }, '*');
                    } catch (err) {
                        console.error('Failed to communicate with iframe:', err);
                    }
                };
                
                // Check if iframe is already loaded
                if (frame2.contentDocument && frame2.contentDocument.readyState === 'complete') {
                    sendViewMessage();
                } else {
                    // Wait for iframe to load
                    frame2.addEventListener('load', sendViewMessage, { once: true });
                    // Also try sending after a delay in case the load event already fired
                    setTimeout(sendViewMessage, 500);
                }
			}
		} else if (pageId === 'link-overlay') {
			if (linkOverlayPage) linkOverlayPage.style.display = 'block';
			if (frame1) frame1.style.display = 'block';
		} else if (pageId === 'streams') {
			if (streamsPage) streamsPage.style.display = 'block';
		} else if (pageId === 'vdo-ninja') {
			if (vdoNinjaPage) vdoNinjaPage.style.display = 'block';
			if (frame3) frame3.style.display = 'block';
		}

        if ((pageId === 'dashboard' || pageId === 'event-flow-editor') && frame2 && (!frame2.src || frame2.src === "about:blank")) {
			setupIframeSource(); 
		} else if (pageId === 'link-overlay' && frame1 && (!frame1.src || frame1.src === "about:blank")) {
			let popupSrc = "";
            if (sourcemode) {
                popupSrc = `${sourcemode}popup.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                if (devmode) popupSrc += "&devmode";
            } else if (devmode) {
                popupSrc = `file:///C:/Users/steve/Code/social_stream/popup.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
                popupSrc = `${domain}/popup.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
			frame1.src = popupSrc;
            frame1.classList.add('loading');
		} else if (pageId === 'vdo-ninja' && frame3 && (!frame3.src || frame3.src === "about:blank")) {
			let vdoSrc = "";
            if (sourcemode) {
                vdoSrc = `${sourcemode}vdo.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                 if (devmode) vdoSrc += "&devmode";
            } else if (devmode) {
                vdoSrc = `file:///C:/Users/steve/Code/social_stream/vdo.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
    			vdoSrc = `${domain}/vdo.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
			frame3.src = vdoSrc;
            frame3.classList.add('loading');
		}
        stateManager.updateGlobal({ currentPage: pageId });
    }

	navigationLinks.forEach(link => {
		link.addEventListener('click', function(event) {
			event.preventDefault();
			const pageId = this.dataset.page;
			switchToPage(pageId);
		});
	});

    const initialPage = stateManager.state.global.currentPage || 'streams';
	switchToPage(initialPage); 

    if (ipcRenderer) {
        ipcRenderer.on('fromMainToIndex', (event, ...args) => { 
            log("FROM MAIN TO INDEX", args[0]);
            if (args[0] == "serverStarted") {
                console.log("serverStarted");
                localServer = "&localserver";
                setupIframeSource(); 
            } else if (args[0] == "serverStopped") {
                console.log("serverStopped");
                localServer = "";
                setupIframeSource(); 
            }
            const currentFrame1Src = document.getElementById("frame1")?.src;
            let expectedFrame1Src = "";
             if (sourcemode) {
                expectedFrame1Src = `${sourcemode}popup.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                if (devmode) expectedFrame1Src += "&devmode";
            } else if (devmode) {
                expectedFrame1Src = `file:///C:/Users/steve/Code/social_stream/popup.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
                expectedFrame1Src = `${domain}/popup.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
            if (document.getElementById("frame1") && currentFrame1Src !== expectedFrame1Src) {
                 document.getElementById("frame1").src = expectedFrame1Src;
            }
        });

        ipcRenderer.on(`window-hidden`, (event, ...args) => {
            let tabId = args[0]?.tabID;
            if (tabId) {
                const sourceToUpdate = stateManager.getSources({ vid: tabId })[0];
                if (sourceToUpdate) {
                    stateManager.updateSource(sourceToUpdate.id, { isVisible: false });
                }
            }
        });
        
        ipcRenderer.on(`window-shown`, (event, ...args) => { 
            let tabId = args[0]?.tabID;
            if (tabId) {
                const sourceToUpdate = stateManager.getSources({ vid: tabId })[0];
                if (sourceToUpdate) {
                    stateManager.updateSource(sourceToUpdate.id, { isVisible: true });
                }
            }
        });


        ipcRenderer.on('tiktokConnectionStatus', (event, data) => {
            if (!data || !data.wssID) return;
            const sourceToUpdate = stateManager.getSources({ wssId: data.wssID })[0];
            if (!sourceToUpdate) return;

            const entryElement = document.querySelector(`[data-source-id="${sourceToUpdate.id}"]`);

            switch (data.status) {
                case 'connected':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'active' }); 
                    if (entryElement) updateConnectionStatus(entryElement, 'connected');
                    break;
                case 'disconnected': 
                    stateManager.updateSource(sourceToUpdate.id, { status: 'error', error: data.error || 'Connection lost.', vid: null, wssId: null });
                    if (entryElement) updateConnectionStatus(entryElement, 'error', data.error || 'Connection lost. Will attempt to reconnect if configured.');
                    break;
                case 'error':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'error', error: data.error || 'Connection error' });
                     if (entryElement) updateConnectionStatus(entryElement, 'error', data.error || 'Connection error');
                    break;
                case 'failed': 
                case 'fatal_error':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'error', error: data.error || 'Connection failed', vid: null, wssId: null, connectionMode: 'classic' }); 
                     if (entryElement) updateConnectionStatus(entryElement, 'error', data.error || 'Connection failed');
                    break;
                case 'reconnecting':
                    stateManager.updateSource(sourceToUpdate.id, { status: 'activating' }); 
                     if (entryElement) updateConnectionStatus(entryElement, 'retry', `Retrying ${data.attempt || '?'}/${data.maxAttempts || '?'}`);
                    break;
                case 'stopped_by_user': 
                    stateManager.updateSource(sourceToUpdate.id, { status: 'inactive', vid:null, wssId:null });
                    if (entryElement) updateConnectionStatus(entryElement, 'stopped', 'Connection stopped by user.');
                    break;
            }
        });
    } 
});

console.log('[Electron] Current user agent:', navigator.userAgent);
console.log('[Electron] Window.electron exists?', !!window.electron);
console.log('[Electron] Process exists?', typeof process !== 'undefined');

// Check multiple ways to detect Electron (now that we hide it from UA)
const isElectron = (navigator.userAgent.toLowerCase().indexOf('electron/') > -1) || 
                   (typeof process !== 'undefined' && process.versions && process.versions.electron) ||
                   (window && window.process && window.process.type) ||
                   (window.electron && window.electron.ipcRenderer) || // Check for our preload exposure
                   (typeof require !== 'undefined'); // Node integration check

if (isElectron || window.electron) {
	console.log('[Electron] Detected Electron environment');
	try {
		if (!ipcRenderer) {
			// First try window.electron (from contextBridge in preload)
			if (window.electron && window.electron.ipcRenderer) {
				console.log('[Electron] Using ipcRenderer from contextBridge');
				ipcRenderer = window.electron.ipcRenderer;
			} 
			// Then try require (only works if nodeIntegration is enabled)
			else if (typeof require !== 'undefined') {
				console.log('[Electron] Attempting to require electron.ipcRenderer');
				ipcRenderer = require('electron').ipcRenderer;
			} else {
				console.log('[Electron] No access to ipcRenderer - nodeIntegration disabled and no contextBridge');
			}
			console.log('[Electron] Successfully loaded ipcRenderer:', !!ipcRenderer);
		}
		if (ipcRenderer) { 
            window.prompt = function(title, val, message = "") {
				log("window.prompt");
                let options = {};
                if (typeof title === 'object' && title !== null) {
                    options = title;
                } else { 
                    options.title = title;
                    options.message = message || val || ""; 
                    if (typeof val !== 'undefined' && message === "") options.value = val; 
                }
				return ipcRenderer.sendSync('prompt', options);
			};
			window.alert = function(title, val) { 
				log("window.alert");
				return ipcRenderer.send('alert', { 
					title: title, 
					message: val || title 
				});
			};
        }
    } catch(e) { 
        console.error("[Electron] IPC setup failed:", e);
        console.error("[Electron] This usually means nodeIntegration is disabled");
    }
}

var sourceTemplate = document.getElementById("sourceTemplate");
var groupTemplate = document.getElementById("groupTemplate"); 
var youtubeStatusManager = null;
var streamSelector = null;
var cachedManifest = {}; 
var iframes = document.querySelectorAll('iframe');
Array.prototype.forEach.call(iframes, function(iframe) {
	iframe.onload = function() { this.classList.remove('loading'); };
});
const basePath = window.location.href.split('index.html')[0];
function sleep(ms) { 
    return new Promise((resolve) => { setTimeout(resolve, ms); });
}

async function loadManifest() {
	const manifestUrl = getManifestUrl(); 
	try {
		const response = await fetch(manifestUrl);
        if (!response.ok) {
            throw new Error(`Manifest fetch failed: ${response.status} ${response.statusText}`);
        }
		const data = await response.json();
		if (data) {
			cachedManifest[manifestUrl] = data; 
			log("Fetched and cached remote manifest", data.version);
			localStorage.setItem('cachedManifest', JSON.stringify(data)); 
			return data;
		}
	} catch (e) {
		console.error('Error loading manifest from network:', e, manifestUrl);
		const storedManifest = localStorage.getItem('cachedManifest');
		if (storedManifest) {
			try {
				const parsedManifest = JSON.parse(storedManifest);
                const tempManifestUrl = parsedManifest.url; 
                if (tempManifestUrl === manifestUrl || !tempManifestUrl) { 
    				log("Using cached manifest from local storage.", parsedManifest.version);
	    			return parsedManifest;
                } else {
                    console.warn("Cached manifest URL does not match current mode's expected URL. Discarding old cache.");
                }
			} catch (parseError) {
				console.error('Error parsing cached manifest:', parseError);
			}
		}
	}
	return null; 
}
function getManifestUrl() { 
	if (sourcemode) return sourcemode + "manifest.json";
	if (devmode) return "file:///C:/Users/steve/Code/social_stream/manifest.json";
	if (isBetaMode) return "https://socialstream.ninja/beta/manifest.json";
	return "https://socialstream.ninja/manifest.json";
}
async function initializeApplication() {
	let newconfig = await initializeConfig(); 
	if (!newconfig) {
		console.error("Failed to initialize configuration.");
        Toast.error("Config Error", "Critical configuration failed to load.");
		return false;
	}
	config = newconfig;
	setupIframeSource(); 

	let loadedManifest = await loadManifest();
	if (!loadedManifest) {
		Toast.warning("Manifest Warning", "Failed to load remote manifest. Using cached version if available.");
        const cached = localStorage.getItem('cachedManifest'); 
        try {
            if (cached) manifest = JSON.parse(cached);
            else manifest = { content_scripts: [] };
            if (!manifest.content_scripts) manifest.content_scripts = [];
        } catch { manifest = { content_scripts: [] }; }
	} else {
    	manifest = loadedManifest;
    }
	console.log(manifest)
	console.log(config);
	return true;
}
function setupIframeSource() { 
	const frame2 = document.getElementById("frame2");
    if (!frame2) return;
	let iframesrc = "";
	// Get the language code for the URL
	const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
	const langParam = `&ln=${langCode}`;
	
	// Check if we should show the editor view initially
	const viewParam = window.initialEditorView ? '&view=editor' : '';
	
	if (sourcemode) {
		 if (devmode) {
			document.getElementById("sources")?.classList.add("dev");
			iframesrc = `${sourcemode}background.html?sourcemode=${encodeURIComponent(sourcemode)}&devmode&ssapp=2${localServer}${langParam}${viewParam}`;
		 } else {
			iframesrc = `${sourcemode}background.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}${langParam}${viewParam}`;
		}
	} else if (devmode) {
		document.getElementById("sources")?.classList.add("dev");
		iframesrc = `file:///C:/Users/steve/Code/social_stream/background.html?devmode&ssapp=2${localServer}${langParam}${viewParam}`;
	} else if (isBetaMode) {
		iframesrc = `https://socialstream.ninja/beta/background.html?v=2&ssapp=2${localServer}${langParam}${viewParam}`;
	} else {
		iframesrc = `https://socialstream.ninja/background.html?v=2&ssapp=2${localServer}${langParam}${viewParam}`;
	}

	if (!frame2.src || (iframesrc !== frame2.src)) {
		frame2.src = iframesrc;
        frame2.classList.add('loading');
	}
}
async function checkForUpdates() { 
    try {
		const response = await fetch('https://api.github.com/repos/steveseguin/social_stream/releases');
		const data = await response.json();
		// Find the latest non-prerelease version
		const latestRelease = data.find(release => !release.prerelease);
		if (latestRelease?.tag_name && ipcRenderer) {
			const currentVersion = await ipcRenderer.sendSync('getVersion'); 
			if (currentVersion && compareVersions(currentVersion, latestRelease.tag_name) === -1) { 
				const newver = document.getElementById("newver");
                if (newver) { 
    				newver.classList.remove("hidden");
	    			document.getElementById("downloadlink").href = `https://github.com/steveseguin/social_stream/releases/tag/${latestRelease.tag_name}`;
		    		newver.innerHTML = `<h1>NEW VERSION AVAILABLE</h1> <a id="downloadlink" href="https://github.com/steveseguin/social_stream/releases/tag/${latestRelease.tag_name}" target="_blank">Download new version here</a> <b>v${latestRelease.tag_name}</b> (installed: v${currentVersion})`;
                }
			}
		}
	} catch (e) {
		console.error('Error checking for updates:', e);
	}
}

// Session Management Functions
async function loadSessions() {
	try {
		const { sessions, currentSession } = await ipcRenderer.invoke('getSessions');
		
		// Update current session display
		const currentSessionElement = document.getElementById('current-session-name');
		if (currentSessionElement && sessions[currentSession]) {
			currentSessionElement.textContent = sessions[currentSession].name;
		}
		
		// Populate sessions list
		const container = document.getElementById('sessions-list-container');
		if (!container) return;
		
		container.innerHTML = '';
		
		Object.entries(sessions).forEach(([id, session]) => {
			const sessionEl = document.createElement('div');
			sessionEl.className = 'session-item';
			if (id === currentSession) {
				sessionEl.classList.add('current');
			}
			
			sessionEl.innerHTML = `
				<div class="session-info">
					<h4 class="session-name">${session.name}</h4>
					${session.description ? `<p class="session-description">${session.description}</p>` : ''}
					<span class="session-date">Created: ${new Date(session.created).toLocaleDateString()}</span>
				</div>
				<div class="session-actions">
					${id !== currentSession ? `<button onclick="switchToSession('${id}')" class="switch-btn"><i class="las la-sign-in-alt"></i> Switch</button>` : '<span class="active-label">Active</span>'}
					${id !== 'default' ? `
						<button onclick="renameSession('${id}')" class="rename-btn"><i class="las la-edit"></i></button>
						<button onclick="deleteSession('${id}')" class="delete-btn"><i class="las la-trash"></i></button>
					` : '<span class="default-label">Original Data</span>'}
				</div>
			`;
			
			container.appendChild(sessionEl);
		});
	} catch (e) {
		console.error('Error loading sessions:', e);
	}
}

async function createNewSession() {
	const name = prompt('Enter a name for the new session:');
	if (!name) return;
	
	const description = prompt('Enter a description (optional):', 'A fresh start with no sources or settings');
	
	try {
		const result = await ipcRenderer.invoke('createSession', { name, description });
		if (result.success) {
			const switchNow = confirm('Session created! Do you want to switch to it now?\n\nNote: This will restart the application.');
			if (switchNow) {
				await switchToSession(result.sessionId);
			} else {
				loadSessions();
			}
		}
	} catch (e) {
		console.error('Error creating session:', e);
		alert('Failed to create session');
	}
}

async function switchToSession(sessionId) {
	const confirmSwitch = confirm('Switching sessions will restart the application. Continue?');
	if (!confirmSwitch) return;
	
	try {
		await ipcRenderer.invoke('switchSession', sessionId);
	} catch (e) {
		console.error('Error switching session:', e);
		alert('Failed to switch session');
	}
}

async function deleteSession(sessionId) {
	const confirmDelete = confirm('Are you sure you want to delete this session? This cannot be undone.');
	if (!confirmDelete) return;
	
	try {
		const result = await ipcRenderer.invoke('deleteSession', sessionId);
		if (result.success) {
			loadSessions();
		} else {
			alert(result.message || 'Failed to delete session');
		}
	} catch (e) {
		console.error('Error deleting session:', e);
		alert('Failed to delete session');
	}
}

async function renameSession(sessionId) {
	const currentName = document.querySelector(`[onclick="renameSession('${sessionId}')"]`)
		?.closest('.session-item')?.querySelector('.session-name')?.textContent;
	
	const newName = prompt('Enter new name:', currentName);
	if (!newName || newName === currentName) return;
	
	try {
		const result = await ipcRenderer.invoke('renameSession', sessionId, newName);
		if (result.success) {
			loadSessions();
		} else {
			alert(result.message || 'Failed to rename session');
		}
	} catch (e) {
		console.error('Error renaming session:', e);
		alert('Failed to rename session');
	}
}

async function exportCurrentSession() {
	try {
		// Show loading indicator
		Toast.info('Exporting...', 'Gathering all session data from all windows...');
		
		// Get current session data
		const { sessions, currentSession } = await ipcRenderer.invoke('getSessions');
		const sessionData = sessions[currentSession];
		
		if (!sessionData) {
			Toast.error('Export Failed', 'No current session found');
			return;
		}
		
		// Get ALL session data including cookies from all windows/partitions
		const allSessionDataResult = await ipcRenderer.invoke('exportAllSessionData');
		
		if (!allSessionDataResult.success) {
			throw new Error(allSessionDataResult.error || 'Failed to export session data');
		}
		
		// Combine with current window's localStorage data
		const exportData = {
			sessionInfo: {
				name: sessionData.name,
				description: sessionData.description,
				createdAt: sessionData.createdAt,
				exportedAt: new Date().toISOString(),
				currentSessionId: currentSession
			},
			// Include all session data from all windows/partitions
			allSessions: allSessionDataResult.data,
			// Include current window's localStorage as well
			mainWindowLocalStorage: {
				socialStreamState: localStorage.getItem('socialStreamState'),
				settings: localStorage.getItem('settings'),
				betaMode: localStorage.getItem('betaMode'),
				youtubeAutoAdd: localStorage.getItem('youtubeAutoAdd'),
				youtubeAutoCleanup: localStorage.getItem('youtubeAutoCleanup'),
				youtubeCheckInterval: localStorage.getItem('youtubeCheckInterval'),
				cachedManifest: localStorage.getItem('cachedManifest'),
				config: localStorage.getItem('config'),
				language: localStorage.getItem('language')
			},
			version: '2.0'
		};
		
		// Create a blob and download it
		const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = `session-${sessionData.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}-complete.json`;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);
		
		// Show summary
		const sessionCount = Object.keys(allSessionDataResult.data.sessions).length;
		Toast.success('Export Complete', `Exported "${sessionData.name}" with data from ${sessionCount} windows/partitions`);
	} catch (e) {
		console.error('Error exporting session:', e);
		Toast.error('Export Failed', 'Failed to export session: ' + e.message);
	}
}

async function importSession() {
	try {
		// Create file input
		const input = document.createElement('input');
		input.type = 'file';
		input.accept = '.json';
		
		input.onchange = async (event) => {
			const file = event.target.files[0];
			if (!file) return;
			
			try {
				const content = await file.text();
				const importData = JSON.parse(content);
				
				// Validate the import data - support both old and new formats
				if (!importData.version || !importData.sessionInfo) {
					throw new Error('Invalid session file format');
				}
				
				// Check if this is the new format with all session data
				const isNewFormat = importData.version === '2.0' && importData.allSessions;
				
				// Prompt for session name
				const name = prompt('Enter a name for the imported session:', importData.sessionInfo.name || 'Imported Session');
				if (!name) return;
				
				const description = prompt('Enter a description (optional):', 
					importData.sessionInfo.description || `Imported from ${importData.sessionInfo.name} on ${new Date().toLocaleDateString()}`);
				
				// Create new session
				const result = await ipcRenderer.invoke('createSession', { name, description });
				if (!result.success) {
					throw new Error(result.error || 'Failed to create session');
				}
				
				// Ask if they want to switch to the imported session
				const switchNow = confirm('Session imported! Do you want to switch to it now?\n\nNote: This will restart the application and load the imported data.');
				
				if (switchNow) {
					if (isNewFormat) {
						// New format: Import all session data including cookies
						Toast.info('Importing...', 'Restoring all session data including cookies...');
						
						// Import all the session data (cookies, etc)
						const importResult = await ipcRenderer.invoke('importAllSessionData', importData.allSessions);
						
						if (!importResult.success) {
							throw new Error(importResult.error || 'Failed to import session data');
						}
						
						// Store the main window localStorage data
						localStorage.setItem('pendingImport', JSON.stringify(importData.mainWindowLocalStorage));
						
						// Store the full session data for window restoration
						await ipcRenderer.invoke('store-set', 'pendingSessionImport', importData.allSessions);
						
						const summary = `Imported ${importResult.results.totalSessions} sessions with ${importResult.results.totalCookies} cookies`;
						Toast.success('Import Progress', summary);
					} else {
						// Old format: Only localStorage
						localStorage.setItem('pendingImport', JSON.stringify(importData.localStorage));
					}
					
					// Switch to the new session
					await ipcRenderer.invoke('switchSession', result.sessionId);
				} else {
					if (isNewFormat) {
						// Import session data without switching
						Toast.info('Importing...', 'Restoring session data...');
						const importResult = await ipcRenderer.invoke('importAllSessionData', importData.allSessions);
						
						if (importResult.success) {
							const summary = `Imported ${importResult.results.totalSessions} sessions with ${importResult.results.totalCookies} cookies`;
							Toast.success('Import Complete', `Session "${name}" imported. ${summary}`);
						} else {
							Toast.warning('Partial Import', `Session "${name}" created but some data could not be imported`);
						}
					} else {
						Toast.success('Import Complete', `Session "${name}" imported successfully. You can switch to it later.`);
					}
					await loadSessions();
				}
				
			} catch (e) {
				console.error('Error processing import file:', e);
				Toast.error('Import Failed', 'Failed to import session: ' + e.message);
			}
		};
		
		input.click();
	} catch (e) {
		console.error('Error importing session:', e);
		Toast.error('Import Failed', 'Failed to import session');
	}
}

// Navigation handling
function showPage(pageName) {
	// Hide all pages
	const pages = document.querySelectorAll('#content-pane > div');
	pages.forEach(page => {
		page.style.display = 'none';
	});
	
	// Show the selected page
	const selectedPage = document.getElementById(pageName + '-page');
	if (selectedPage) {
		selectedPage.style.display = 'block';
		
		// Check if this page needs an iframe and create/update it
		const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
		const existingIframe = selectedPage.querySelector('iframe');
		
		// Pages that should have iframes with socialstream.ninja content
		const iframePages = {
			'link-overlay': `https://socialstream.ninja/overlays/?ln=${langCode}`,
			'dashboard': `https://socialstream.ninja/dashboard/?ln=${langCode}`,
			'event-flow-editor': `https://socialstream.ninja/eventflow/?ln=${langCode}`,
			'vdo-ninja': `https://vdo.ninja/?ln=${langCode}`
		};
		
		if (iframePages[pageName]) {
			if (!existingIframe) {
				// Create iframe if it doesn't exist
				const iframe = document.createElement('iframe');
				iframe.style.width = '100%';
				iframe.style.height = '100%';
				iframe.style.border = 'none';
				iframe.src = iframePages[pageName];
				selectedPage.appendChild(iframe);
			} else {
				// Update existing iframe with language parameter
				try {
					if (existingIframe.src && existingIframe.src !== 'about:blank') {
						const url = new URL(existingIframe.src);
						url.searchParams.set('ln', langCode);
						if (existingIframe.src !== url.toString()) {
							existingIframe.src = url.toString();
						}
					}
				} catch (e) {
					console.error('Error updating iframe URL:', e);
					// If URL is invalid, just set the new URL
					existingIframe.src = iframePages[pageName];
				}
			}
		}
	}
	
	// Update active nav link
	const navLinks = document.querySelectorAll('#main-navigation a');
	navLinks.forEach(link => {
		link.classList.remove('active');
		if (link.getAttribute('data-page') === pageName) {
			link.classList.add('active');
		}
	});
	
	// Save current page to localStorage
	localStorage.setItem('currentPage', pageName);
	
	// Load sessions when sessions page is shown
	if (pageName === 'sessions') {
		loadSessions();
	}
}

// Translation system
const translations = {
	'en': {
		// Navigation
		'nav.streams': 'ğŸ­ Sources',
		'nav.linkoverlay': 'ğŸ”— Links and Settings',
		'nav.dashboard': 'ğŸ“° Status and Logs',
		'nav.eventfloweditor': 'ğŸª¤ Event Flow Editor',
		'nav.vdoninja': 'ğŸ¦ Remote Camera Feed',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sessions',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ Activate source',
		'btn.signin': 'ğŸ”‘ Sign-in',
		'btn.help': 'â“ Help!',
		'btn.stop': 'â¹ï¸ Stop',
		'btn.reload': 'ğŸ”„ Reload',
		'btn.visible': 'ğŸ‘ï¸ Visible',
		'btn.hidden': 'ğŸ™ˆ Hidden',
		'btn.muted': 'ğŸ”‡ Muted',
		'btn.unmuted': 'ğŸ”Š Volume',
		
		// Settings menu
		'settings.title': 'Additional settings for this source',
		'settings.header': 'Additional Controls',
		'settings.clear': 'ğŸ§¹ Clear cache & storage',
		'settings.remove': 'ğŸ—‘ï¸ Remove source',
		
		// Sessions
		'sessions.title': 'User Sessions',
		'sessions.info': 'Manage multiple user profiles with separate settings and sources.',
		'sessions.current': 'Current Session',
		'sessions.available': 'Available Sessions',
		'sessions.create': 'â• Create New Session',
		'sessions.export': 'ğŸ’¾ Export Current Session',
		'sessions.import': 'ğŸ“‚ Import Session',
		'sessions.switch': 'Switch',
		'sessions.active': 'Active',
		
		// Sources
		'source.add': 'Add a new source:',
		'source.mode.standard': 'ğŸ“„ Standard',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Auto-activate',
		'source.youtube.username': 'YouTube Username',
		'source.youtube.videoid': 'YouTube Video ID',
		'source.twitch': 'Twitch Username',
		'source.kick': 'Kick Username',
		'source.instagram': 'Instagram Username',
		'source.facebook': 'Facebook Username',
		'source.tiktok': 'TikTok Username',
		'source.other': 'Other chat sites',
		
		// App info
		'app.title': 'Social Stream Ninja Standalone',
		'app.newversion': 'NEW VERSION AVAILABLE',
		'app.download': 'Download new version here',
		
		// Groups
		'group.togglevisibility': 'Toggle All Streams Visibility',
		'group.togglemute': 'Toggle All Streams Mute',
		'group.stopall': 'Stop All Streams',
		'group.reloadall': 'Reload All Streams',
		'group.remove': 'ğŸ—‘ï¸ Remove group & its sources',
	},
	
	'pt-BR': {
		// Navigation
		'nav.streams': 'ğŸ­ Fontes',
		'nav.linkoverlay': 'ğŸ”— Links e ConfiguraÃ§Ãµes',
		'nav.dashboard': 'ğŸ“° Status e Logs',
		'nav.eventfloweditor': 'ğŸª¤ Editor de Fluxo de Eventos',
		'nav.vdoninja': 'ğŸ¦ Feed de CÃ¢mera Remota',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ SessÃµes',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ Ativar fonte',
		'btn.signin': 'ğŸ”‘ Entrar',
		'btn.help': 'â“ Ajuda!',
		'btn.stop': 'â¹ï¸ Parar',
		'btn.reload': 'ğŸ”„ Recarregar',
		'btn.visible': 'ğŸ‘ï¸ VisÃ­vel',
		'btn.hidden': 'ğŸ™ˆ Oculto',
		'btn.muted': 'ğŸ”‡ Mudo',
		'btn.unmuted': 'ğŸ”Š Som',
		
		// Settings menu
		'settings.title': 'ConfiguraÃ§Ãµes adicionais para esta fonte',
		'settings.header': 'Controles Adicionais',
		'settings.clear': 'ğŸ§¹ Limpar cache e armazenamento',
		'settings.remove': 'ğŸ—‘ï¸ Remover fonte',
		
		// Sessions
		'sessions.title': 'SessÃµes de UsuÃ¡rio',
		'sessions.info': 'Gerencie mÃºltiplos perfis de usuÃ¡rio com configuraÃ§Ãµes e fontes separadas.',
		'sessions.current': 'SessÃ£o Atual',
		'sessions.available': 'SessÃµes DisponÃ­veis',
		'sessions.create': 'â• Criar Nova SessÃ£o',
		'sessions.switch': 'Alternar',
		'sessions.active': 'Ativa',
		
		// Sources
		'source.add': 'Adicionar nova fonte:',
		'source.mode.standard': 'ğŸ“„ PadrÃ£o',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Ativar automaticamente',
		'source.youtube.username': 'Nome de usuÃ¡rio do YouTube',
		'source.youtube.videoid': 'ID do vÃ­deo do YouTube',
		'source.twitch': 'Nome de usuÃ¡rio do Twitch',
		'source.kick': 'Nome de usuÃ¡rio do Kick',
		'source.instagram': 'Nome de usuÃ¡rio do Instagram',
		'source.facebook': 'Nome de usuÃ¡rio do Facebook',
		'source.tiktok': 'Nome de usuÃ¡rio do TikTok',
		'source.other': 'Outros sites de chat',
		
		// App info
		'app.title': 'Social Stream Ninja AutÃ´nomo',
		'app.newversion': 'NOVA VERSÃƒO DISPONÃVEL',
		'app.download': 'Baixe a nova versÃ£o aqui',
		
		// Groups
		'group.togglevisibility': 'Alternar Visibilidade de Todas as TransmissÃµes',
		'group.togglemute': 'Alternar Som de Todas as TransmissÃµes',
		'group.stopall': 'Parar Todas as TransmissÃµes',
		'group.reloadall': 'Recarregar Todas as TransmissÃµes',
		'group.remove': 'ğŸ—‘ï¸ Remover grupo e suas fontes',
	},
	
	'es': {
		// Navigation
		'nav.streams': 'ğŸ­ Fuentes',
		'nav.linkoverlay': 'ğŸ”— Enlaces y ConfiguraciÃ³n',
		'nav.dashboard': 'ğŸ“° Estado y Registros',
		'nav.eventfloweditor': 'ğŸª¤ Editor de Flujo de Eventos',
		'nav.vdoninja': 'ğŸ¦ TransmisiÃ³n de CÃ¡mara Remota',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sesiones',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ Activar fuente',
		'btn.signin': 'ğŸ”‘ Iniciar sesiÃ³n',
		'btn.help': 'â“ Â¡Ayuda!',
		'btn.stop': 'â¹ï¸ Detener',
		'btn.reload': 'ğŸ”„ Recargar',
		'btn.visible': 'ğŸ‘ï¸ Visible',
		'btn.hidden': 'ğŸ™ˆ Oculto',
		'btn.muted': 'ğŸ”‡ Silenciado',
		'btn.unmuted': 'ğŸ”Š Sonido',
		
		// Settings menu
		'settings.title': 'ConfiguraciÃ³n adicional para esta fuente',
		'settings.header': 'Controles Adicionales',
		'settings.clear': 'ğŸ§¹ Limpiar cachÃ© y almacenamiento',
		'settings.remove': 'ğŸ—‘ï¸ Eliminar fuente',
		
		// Sessions
		'sessions.title': 'Sesiones de Usuario',
		'sessions.info': 'Gestione mÃºltiples perfiles de usuario con configuraciones y fuentes separadas.',
		'sessions.current': 'SesiÃ³n Actual',
		'sessions.available': 'Sesiones Disponibles',
		'sessions.create': 'â• Crear Nueva SesiÃ³n',
		'sessions.switch': 'Cambiar',
		'sessions.active': 'Activa',
		
		// Sources
		'source.add': 'AÃ±adir nueva fuente',
		'source.mode.standard': 'ğŸ“„ EstÃ¡ndar',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Activar automÃ¡ticamente',
		'source.youtube.username': 'Nombre de usuario de YouTube',
		'source.youtube.videoid': 'ID de video de YouTube',
		'source.twitch': 'Nombre de usuario de Twitch',
		'source.kick': 'Nombre de usuario de Kick',
		'source.instagram': 'Nombre de usuario de Instagram',
		'source.facebook': 'Nombre de usuario de Facebook',
		'source.tiktok': 'Nombre de usuario de TikTok',
		'source.other': 'Otros sitios de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Independiente',
		'app.newversion': 'NUEVA VERSIÃ“N DISPONIBLE',
		'app.download': 'Descarga la nueva versiÃ³n aquÃ­',
		
		// Groups
		'group.togglevisibility': 'Alternar Visibilidad de Todas las Transmisiones',
		'group.togglemute': 'Alternar Sonido de Todas las Transmisiones',
		'group.stopall': 'Detener Todas las Transmisiones',
		'group.reloadall': 'Recargar Todas las Transmisiones',
		'group.remove': 'ğŸ—‘ï¸ Eliminar grupo y sus fuentes',
	},
	
	'fr': {
		// Navigation
		'nav.streams': 'ğŸ­ Sources',
		'nav.linkoverlay': 'ğŸ”— Liens et ParamÃ¨tres',
		'nav.dashboard': 'ğŸ“° Ã‰tat et Journaux',
		'nav.eventfloweditor': 'ğŸª¤ Ã‰diteur de Flux d\'Ã‰vÃ©nements',
		'nav.vdoninja': 'ğŸ¦ Flux de CamÃ©ra Ã  Distance',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sessions',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ Activer la source',
		'btn.signin': 'ğŸ”‘ Se connecter',
		'btn.help': 'â“ Aide!',
		'btn.stop': 'â¹ï¸ ArrÃªter',
		'btn.reload': 'ğŸ”„ Recharger',
		'btn.visible': 'ğŸ‘ï¸ Visible',
		'btn.hidden': 'ğŸ™ˆ CachÃ©',
		'btn.muted': 'ğŸ”‡ Muet',
		'btn.unmuted': 'ğŸ”Š Son',
		
		// Settings menu
		'settings.title': 'ParamÃ¨tres supplÃ©mentaires pour cette source',
		'settings.header': 'ContrÃ´les SupplÃ©mentaires',
		'settings.clear': 'ğŸ§¹ Effacer le cache et le stockage',
		'settings.remove': 'ğŸ—‘ï¸ Supprimer la source',
		
		// Sessions
		'sessions.title': 'Sessions Utilisateur',
		'sessions.info': 'GÃ©rez plusieurs profils utilisateur avec des paramÃ¨tres et sources sÃ©parÃ©s.',
		'sessions.current': 'Session Actuelle',
		'sessions.available': 'Sessions Disponibles',
		'sessions.create': 'â• CrÃ©er une Nouvelle Session',
		'sessions.switch': 'Changer',
		'sessions.active': 'Active',
		
		// Sources
		'source.add': 'Ajouter une nouvelle source',
		'source.mode.standard': 'ğŸ“„ Standard',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Activation automatique',
		'source.youtube.username': 'Nom d\'utilisateur YouTube',
		'source.youtube.videoid': 'ID de vidÃ©o YouTube',
		'source.twitch': 'Nom d\'utilisateur Twitch',
		'source.kick': 'Nom d\'utilisateur Kick',
		'source.instagram': 'Nom d\'utilisateur Instagram',
		'source.facebook': 'Nom d\'utilisateur Facebook',
		'source.tiktok': 'Nom d\'utilisateur TikTok',
		'source.other': 'Autres sites de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autonome',
		'app.newversion': 'NOUVELLE VERSION DISPONIBLE',
		'app.download': 'TÃ©lÃ©chargez la nouvelle version ici',
		
		// Groups
		'group.togglevisibility': 'Basculer la VisibilitÃ© de Tous les Flux',
		'group.togglemute': 'Basculer le Son de Tous les Flux',
		'group.stopall': 'ArrÃªter Tous les Flux',
		'group.reloadall': 'Recharger Tous les Flux',
		'group.remove': 'ğŸ—‘ï¸ Supprimer le groupe et ses sources',
	},
	
	'de': {
		// Navigation
		'nav.streams': 'ğŸ­ Quellen',
		'nav.linkoverlay': 'ğŸ”— Links und Einstellungen',
		'nav.dashboard': 'ğŸ“° Status und Protokolle',
		'nav.eventfloweditor': 'ğŸª¤ Ereignisfluss-Editor',
		'nav.vdoninja': 'ğŸ¦ Remote-Kamera-Feed',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sitzungen',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ Quelle aktivieren',
		'btn.signin': 'ğŸ”‘ Anmelden',
		'btn.help': 'â“ Hilfe!',
		'btn.stop': 'â¹ï¸ Stoppen',
		'btn.reload': 'ğŸ”„ Neu laden',
		'btn.visible': 'ğŸ‘ï¸ Sichtbar',
		'btn.hidden': 'ğŸ™ˆ Versteckt',
		'btn.muted': 'ğŸ”‡ Stumm',
		'btn.unmuted': 'ğŸ”Š Ton',
		
		// Settings menu
		'settings.title': 'ZusÃ¤tzliche Einstellungen fÃ¼r diese Quelle',
		'settings.header': 'ZusÃ¤tzliche Steuerungen',
		'settings.clear': 'ğŸ§¹ Cache und Speicher lÃ¶schen',
		'settings.remove': 'ğŸ—‘ï¸ Quelle entfernen',
		
		// Sessions
		'sessions.title': 'Benutzersitzungen',
		'sessions.info': 'Verwalten Sie mehrere Benutzerprofile mit separaten Einstellungen und Quellen.',
		'sessions.current': 'Aktuelle Sitzung',
		'sessions.available': 'VerfÃ¼gbare Sitzungen',
		'sessions.create': 'â• Neue Sitzung erstellen',
		'sessions.switch': 'Wechseln',
		'sessions.active': 'Aktiv',
		
		// Sources
		'source.add': 'Neue Quelle hinzufÃ¼gen',
		'source.mode.standard': 'ğŸ“„ Standard',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Automatisch aktivieren',
		'source.youtube.username': 'YouTube-Benutzername',
		'source.youtube.videoid': 'YouTube-Video-ID',
		'source.twitch': 'Twitch-Benutzername',
		'source.kick': 'Kick-Benutzername',
		'source.instagram': 'Instagram-Benutzername',
		'source.facebook': 'Facebook-Benutzername',
		'source.tiktok': 'TikTok-Benutzername',
		'source.other': 'Andere Chat-Seiten',
		
		// App info
		'app.title': 'Social Stream Ninja EigenstÃ¤ndig',
		'app.newversion': 'NEUE VERSION VERFÃœGBAR',
		'app.download': 'Neue Version hier herunterladen',
		
		// Groups
		'group.togglevisibility': 'Sichtbarkeit aller Streams umschalten',
		'group.togglemute': 'Ton aller Streams umschalten',
		'group.stopall': 'Alle Streams stoppen',
		'group.reloadall': 'Alle Streams neu laden',
		'group.remove': 'ğŸ—‘ï¸ Gruppe und ihre Quellen entfernen',
	},
	
	'it': {
		// Navigation
		'nav.streams': 'ğŸ­ Fonti',
		'nav.linkoverlay': 'ğŸ”— Collegamenti e Impostazioni',
		'nav.dashboard': 'ğŸ“° Stato e Registri',
		'nav.eventfloweditor': 'ğŸª¤ Editor di Flusso Eventi',
		'nav.vdoninja': 'ğŸ¦ Feed Telecamera Remota',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Sessioni',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ Attiva fonte',
		'btn.signin': 'ğŸ”‘ Accedi',
		'btn.help': 'â“ Aiuto!',
		'btn.stop': 'â¹ï¸ Ferma',
		'btn.reload': 'ğŸ”„ Ricarica',
		'btn.visible': 'ğŸ‘ï¸ Visibile',
		'btn.hidden': 'ğŸ™ˆ Nascosto',
		'btn.muted': 'ğŸ”‡ Muto',
		'btn.unmuted': 'ğŸ”Š Audio',
		
		// Settings menu
		'settings.title': 'Impostazioni aggiuntive per questa fonte',
		'settings.header': 'Controlli Aggiuntivi',
		'settings.clear': 'ğŸ§¹ Cancella cache e archiviazione',
		'settings.remove': 'ğŸ—‘ï¸ Rimuovi fonte',
		
		// Sessions
		'sessions.title': 'Sessioni Utente',
		'sessions.info': 'Gestisci piÃ¹ profili utente con impostazioni e fonti separate.',
		'sessions.current': 'Sessione Corrente',
		'sessions.available': 'Sessioni Disponibili',
		'sessions.create': 'â• Crea Nuova Sessione',
		'sessions.switch': 'Cambia',
		'sessions.active': 'Attiva',
		
		// Sources
		'source.add': 'Aggiungi nuova fonte',
		'source.mode.standard': 'ğŸ“„ Standard',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Attivazione automatica',
		'source.youtube.username': 'Nome utente YouTube',
		'source.youtube.videoid': 'ID video YouTube',
		'source.twitch': 'Nome utente Twitch',
		'source.kick': 'Nome utente Kick',
		'source.instagram': 'Nome utente Instagram',
		'source.facebook': 'Nome utente Facebook',
		'source.tiktok': 'Nome utente TikTok',
		'source.other': 'Altri siti di chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autonomo',
		'app.newversion': 'NUOVA VERSIONE DISPONIBILE',
		'app.download': 'Scarica la nuova versione qui',
		
		// Groups
		'group.togglevisibility': 'Attiva/Disattiva VisibilitÃ  di Tutti i Flussi',
		'group.togglemute': 'Attiva/Disattiva Audio di Tutti i Flussi',
		'group.stopall': 'Ferma Tutti i Flussi',
		'group.reloadall': 'Ricarica Tutti i Flussi',
		'group.remove': 'ğŸ—‘ï¸ Rimuovi gruppo e le sue fonti',
	},
	
	'ja': {
		// Navigation
		'nav.streams': 'ğŸ­ ã‚½ãƒ¼ã‚¹',
		'nav.linkoverlay': 'ğŸ”— ãƒªãƒ³ã‚¯ã¨è¨­å®š',
		'nav.dashboard': 'ğŸ“° ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨ãƒ­ã‚°',
		'nav.eventfloweditor': 'ğŸª¤ ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼',
		'nav.vdoninja': 'ğŸ¦ ãƒªãƒ¢ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ãƒ•ã‚£ãƒ¼ãƒ‰',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ ã‚»ãƒƒã‚·ãƒ§ãƒ³',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ ã‚½ãƒ¼ã‚¹ã‚’æœ‰åŠ¹åŒ–',
		'btn.signin': 'ğŸ”‘ ã‚µã‚¤ãƒ³ã‚¤ãƒ³',
		'btn.help': 'â“ ãƒ˜ãƒ«ãƒ—ï¼',
		'btn.stop': 'â¹ï¸ åœæ­¢',
		'btn.reload': 'ğŸ”„ ãƒªãƒ­ãƒ¼ãƒ‰',
		'btn.visible': 'ğŸ‘ï¸ è¡¨ç¤º',
		'btn.hidden': 'ğŸ™ˆ éè¡¨ç¤º',
		'btn.muted': 'ğŸ”‡ ãƒŸãƒ¥ãƒ¼ãƒˆ',
		'btn.unmuted': 'ğŸ”Š éŸ³å£°',
		
		// Settings menu
		'settings.title': 'ã“ã®ã‚½ãƒ¼ã‚¹ã®è¿½åŠ è¨­å®š',
		'settings.header': 'è¿½åŠ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«',
		'settings.clear': 'ğŸ§¹ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢',
		'settings.remove': 'ğŸ—‘ï¸ ã‚½ãƒ¼ã‚¹ã‚’å‰Šé™¤',
		
		// Sessions
		'sessions.title': 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³',
		'sessions.info': 'åˆ¥ã€…ã®è¨­å®šã¨ã‚½ãƒ¼ã‚¹ã§è¤‡æ•°ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç®¡ç†ã—ã¾ã™ã€‚',
		'sessions.current': 'ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³',
		'sessions.available': 'åˆ©ç”¨å¯èƒ½ãªã‚»ãƒƒã‚·ãƒ§ãƒ³',
		'sessions.create': 'â• æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆ',
		'sessions.switch': 'åˆ‡ã‚Šæ›¿ãˆ',
		'sessions.active': 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–',
		
		// Sources
		'source.add': 'æ–°ã—ã„ã‚½ãƒ¼ã‚¹ã‚’è¿½åŠ ',
		'source.mode.standard': 'ğŸ“„ ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'è‡ªå‹•æœ‰åŠ¹åŒ–',
		'source.youtube.username': 'YouTubeãƒ¦ãƒ¼ã‚¶ãƒ¼å',
		'source.youtube.videoid': 'YouTubeå‹•ç”»ID',
		'source.twitch': 'Twitchãƒ¦ãƒ¼ã‚¶ãƒ¼å',
		'source.kick': 'Kickãƒ¦ãƒ¼ã‚¶ãƒ¼å',
		'source.instagram': 'Instagramãƒ¦ãƒ¼ã‚¶ãƒ¼å',
		'source.facebook': 'Facebookãƒ¦ãƒ¼ã‚¶ãƒ¼å',
		'source.tiktok': 'TikTokãƒ¦ãƒ¼ã‚¶ãƒ¼å',
		'source.other': 'ãã®ä»–ã®ãƒãƒ£ãƒƒãƒˆã‚µã‚¤ãƒˆ',
		
		// App info
		'app.title': 'Social Stream Ninja ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³',
		'app.newversion': 'æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒåˆ©ç”¨å¯èƒ½',
		'app.download': 'ã“ã¡ã‚‰ã‹ã‚‰æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰',
		
		// Groups
		'group.togglevisibility': 'ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ',
		'group.togglemute': 'ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãƒŸãƒ¥ãƒ¼ãƒˆã‚’åˆ‡ã‚Šæ›¿ãˆ',
		'group.stopall': 'ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢',
		'group.reloadall': 'ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒªãƒ­ãƒ¼ãƒ‰',
		'group.remove': 'ğŸ—‘ï¸ ã‚°ãƒ«ãƒ¼ãƒ—ã¨ãã®ã‚½ãƒ¼ã‚¹ã‚’å‰Šé™¤',
	},
	
	'zh': {
		// Navigation
		'nav.streams': 'ğŸ­ æ¥æº',
		'nav.linkoverlay': 'ğŸ”— é“¾æ¥å’Œè®¾ç½®',
		'nav.dashboard': 'ğŸ“° çŠ¶æ€å’Œæ—¥å¿—',
		'nav.eventfloweditor': 'ğŸª¤ äº‹ä»¶æµç¼–è¾‘å™¨',
		'nav.vdoninja': 'ğŸ¦ è¿œç¨‹æ‘„åƒå¤´ç”»é¢',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ ä¼šè¯',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ æ¿€æ´»æ¥æº',
		'btn.signin': 'ğŸ”‘ ç™»å½•',
		'btn.help': 'â“ å¸®åŠ©ï¼',
		'btn.stop': 'â¹ï¸ åœæ­¢',
		'btn.reload': 'ğŸ”„ é‡æ–°åŠ è½½',
		'btn.visible': 'ğŸ‘ï¸ å¯è§',
		'btn.hidden': 'ğŸ™ˆ éšè—',
		'btn.muted': 'ğŸ”‡ é™éŸ³',
		'btn.unmuted': 'ğŸ”Š éŸ³é‡',
		
		// Settings menu
		'settings.title': 'æ­¤æ¥æºçš„é™„åŠ è®¾ç½®',
		'settings.header': 'é™„åŠ æ§åˆ¶',
		'settings.clear': 'ğŸ§¹ æ¸…é™¤ç¼“å­˜å’Œå­˜å‚¨',
		'settings.remove': 'ğŸ—‘ï¸ åˆ é™¤æ¥æº',
		
		// Sessions
		'sessions.title': 'ç”¨æˆ·ä¼šè¯',
		'sessions.info': 'ä½¿ç”¨å•ç‹¬çš„è®¾ç½®å’Œæ¥æºç®¡ç†å¤šä¸ªç”¨æˆ·é…ç½®æ–‡ä»¶ã€‚',
		'sessions.current': 'å½“å‰ä¼šè¯',
		'sessions.available': 'å¯ç”¨ä¼šè¯',
		'sessions.create': 'â• åˆ›å»ºæ–°ä¼šè¯',
		'sessions.switch': 'åˆ‡æ¢',
		'sessions.active': 'æ´»åŠ¨',
		
		// Sources
		'source.add': 'æ·»åŠ æ–°æ¥æº',
		'source.mode.standard': 'ğŸ“„ æ ‡å‡†',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'è‡ªåŠ¨æ¿€æ´»',
		'source.youtube.username': 'YouTubeç”¨æˆ·å',
		'source.youtube.videoid': 'YouTubeè§†é¢‘ID',
		'source.twitch': 'Twitchç”¨æˆ·å',
		'source.kick': 'Kickç”¨æˆ·å',
		'source.instagram': 'Instagramç”¨æˆ·å',
		'source.facebook': 'Facebookç”¨æˆ·å',
		'source.tiktok': 'TikTokç”¨æˆ·å',
		'source.other': 'å…¶ä»–èŠå¤©ç½‘ç«™',
		
		// App info
		'app.title': 'Social Stream Ninja ç‹¬ç«‹ç‰ˆ',
		'app.newversion': 'æ–°ç‰ˆæœ¬å¯ç”¨',
		'app.download': 'åœ¨æ­¤ä¸‹è½½æ–°ç‰ˆæœ¬',
		
		// Groups
		'group.togglevisibility': 'åˆ‡æ¢æ‰€æœ‰æµçš„å¯è§æ€§',
		'group.togglemute': 'åˆ‡æ¢æ‰€æœ‰æµçš„é™éŸ³',
		'group.stopall': 'åœæ­¢æ‰€æœ‰æµ',
		'group.reloadall': 'é‡æ–°åŠ è½½æ‰€æœ‰æµ',
		'group.remove': 'ğŸ—‘ï¸ åˆ é™¤ç»„åŠå…¶æ¥æº',
	},
	
	'ko': {
		// Navigation
		'nav.streams': 'ğŸ­ ì†ŒìŠ¤',
		'nav.linkoverlay': 'ğŸ”— ë§í¬ ë° ì„¤ì •',
		'nav.dashboard': 'ğŸ“° ìƒíƒœ ë° ë¡œê·¸',
		'nav.eventfloweditor': 'ğŸª¤ ì´ë²¤íŠ¸ í”Œë¡œìš° í¸ì§‘ê¸°',
		'nav.vdoninja': 'ğŸ¦ ì›ê²© ì¹´ë©”ë¼ í”¼ë“œ',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ ì„¸ì…˜',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ ì†ŒìŠ¤ í™œì„±í™”',
		'btn.signin': 'ğŸ”‘ ë¡œê·¸ì¸',
		'btn.help': 'â“ ë„ì›€ë§!',
		'btn.stop': 'â¹ï¸ ì¤‘ì§€',
		'btn.reload': 'ğŸ”„ ìƒˆë¡œê³ ì¹¨',
		'btn.visible': 'ğŸ‘ï¸ ë³´ì´ê¸°',
		'btn.hidden': 'ğŸ™ˆ ìˆ¨ê¸°ê¸°',
		'btn.muted': 'ğŸ”‡ ìŒì†Œê±°',
		'btn.unmuted': 'ğŸ”Š ì†Œë¦¬',
		
		// Settings menu
		'settings.title': 'ì´ ì†ŒìŠ¤ì˜ ì¶”ê°€ ì„¤ì •',
		'settings.header': 'ì¶”ê°€ ì»¨íŠ¸ë¡¤',
		'settings.clear': 'ğŸ§¹ ìºì‹œ ë° ì €ì¥ì†Œ ì§€ìš°ê¸°',
		'settings.remove': 'ğŸ—‘ï¸ ì†ŒìŠ¤ ì œê±°',
		
		// Sessions
		'sessions.title': 'ì‚¬ìš©ì ì„¸ì…˜',
		'sessions.info': 'ë³„ë„ì˜ ì„¤ì •ê³¼ ì†ŒìŠ¤ë¡œ ì—¬ëŸ¬ ì‚¬ìš©ì í”„ë¡œí•„ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.',
		'sessions.current': 'í˜„ì¬ ì„¸ì…˜',
		'sessions.available': 'ì‚¬ìš© ê°€ëŠ¥í•œ ì„¸ì…˜',
		'sessions.create': 'â• ìƒˆ ì„¸ì…˜ ë§Œë“¤ê¸°',
		'sessions.switch': 'ì „í™˜',
		'sessions.active': 'í™œì„±',
		
		// Sources
		'source.add': 'ìƒˆ ì†ŒìŠ¤ ì¶”ê°€',
		'source.mode.standard': 'ğŸ“„ í‘œì¤€',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'ìë™ í™œì„±í™”',
		'source.youtube.username': 'YouTube ì‚¬ìš©ìëª…',
		'source.youtube.videoid': 'YouTube ë™ì˜ìƒ ID',
		'source.twitch': 'Twitch ì‚¬ìš©ìëª…',
		'source.kick': 'Kick ì‚¬ìš©ìëª…',
		'source.instagram': 'Instagram ì‚¬ìš©ìëª…',
		'source.facebook': 'Facebook ì‚¬ìš©ìëª…',
		'source.tiktok': 'TikTok ì‚¬ìš©ìëª…',
		'source.other': 'ê¸°íƒ€ ì±„íŒ… ì‚¬ì´íŠ¸',
		
		// App info
		'app.title': 'Social Stream Ninja ë…ë¦½í˜•',
		'app.newversion': 'ìƒˆ ë²„ì „ ì‚¬ìš© ê°€ëŠ¥',
		'app.download': 'ì—¬ê¸°ì„œ ìƒˆ ë²„ì „ ë‹¤ìš´ë¡œë“œ',
		
		// Groups
		'group.togglevisibility': 'ëª¨ë“  ìŠ¤íŠ¸ë¦¼ í‘œì‹œ ì „í™˜',
		'group.togglemute': 'ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ìŒì†Œê±° ì „í™˜',
		'group.stopall': 'ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ì¤‘ì§€',
		'group.reloadall': 'ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ìƒˆë¡œê³ ì¹¨',
		'group.remove': 'ğŸ—‘ï¸ ê·¸ë£¹ ë° ì†ŒìŠ¤ ì œê±°',
	},
	
	'ru': {
		// Navigation
		'nav.streams': 'ğŸ­ Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸',
		'nav.linkoverlay': 'ğŸ”— Ğ¡ÑÑ‹Ğ»ĞºĞ¸ Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸',
		'nav.dashboard': 'ğŸ“° Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¸ Ğ¶ÑƒÑ€Ğ½Ğ°Ğ»Ñ‹',
		'nav.eventfloweditor': 'ğŸª¤ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹',
		'nav.vdoninja': 'ğŸ¦ Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ğ°Ñ Ñ‚Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ ĞºĞ°Ğ¼ĞµÑ€Ñ‹',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Ğ¡ĞµÑÑĞ¸Ğ¸',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ ĞĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº',
		'btn.signin': 'ğŸ”‘ Ğ’Ğ¾Ğ¹Ñ‚Ğ¸',
		'btn.help': 'â“ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ!',
		'btn.stop': 'â¹ï¸ ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ',
		'btn.reload': 'ğŸ”„ ĞŸĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ',
		'btn.visible': 'ğŸ‘ï¸ Ğ’Ğ¸Ğ´Ğ¸Ğ¼Ñ‹Ğ¹',
		'btn.hidden': 'ğŸ™ˆ Ğ¡ĞºÑ€Ñ‹Ñ‚Ñ‹Ğ¹',
		'btn.muted': 'ğŸ”‡ Ğ‘ĞµĞ· Ğ·Ğ²ÑƒĞºĞ°',
		'btn.unmuted': 'ğŸ”Š Ğ—Ğ²ÑƒĞº',
		
		// Settings menu
		'settings.title': 'Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ°',
		'settings.header': 'Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ',
		'settings.clear': 'ğŸ§¹ ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ ĞºÑÑˆ Ğ¸ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ',
		'settings.remove': 'ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº',
		
		// Sessions
		'sessions.title': 'ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğµ ÑĞµÑÑĞ¸Ğ¸',
		'sessions.info': 'Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞ¹Ñ‚Ğµ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑĞ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ñ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼Ğ¸ Ğ¸ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸.',
		'sessions.current': 'Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ ÑĞµÑÑĞ¸Ñ',
		'sessions.available': 'Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ÑĞµÑÑĞ¸Ğ¸',
		'sessions.create': 'â• Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ ÑĞµÑÑĞ¸Ñ',
		'sessions.switch': 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ',
		'sessions.active': 'ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ°Ñ',
		
		// Sources
		'source.add': 'Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº',
		'source.mode.standard': 'ğŸ“„ Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'ĞĞ²Ñ‚Ğ¾Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ',
		'source.youtube.username': 'Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ YouTube',
		'source.youtube.videoid': 'ID Ğ²Ğ¸Ğ´ĞµĞ¾ YouTube',
		'source.twitch': 'Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Twitch',
		'source.kick': 'Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Kick',
		'source.instagram': 'Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Instagram',
		'source.facebook': 'Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Facebook',
		'source.tiktok': 'Ğ˜Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ TikTok',
		'source.other': 'Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ Ñ‡Ğ°Ñ‚-ÑĞ°Ğ¹Ñ‚Ñ‹',
		
		// App info
		'app.title': 'Social Stream Ninja ĞĞ²Ñ‚Ğ¾Ğ½Ğ¾Ğ¼Ğ½Ñ‹Ğ¹',
		'app.newversion': 'Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ ĞĞĞ’ĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯',
		'app.download': 'Ğ¡ĞºĞ°Ñ‡Ğ°Ğ¹Ñ‚Ğµ Ğ½Ğ¾Ğ²ÑƒÑ Ğ²ĞµÑ€ÑĞ¸Ñ Ğ·Ğ´ĞµÑÑŒ',
		
		// Groups
		'group.togglevisibility': 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²',
		'group.togglemute': 'ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ²ÑƒĞº Ğ²ÑĞµÑ… Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ²',
		'group.stopall': 'ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸',
		'group.reloadall': 'ĞŸĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸',
		'group.remove': 'ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ Ğ¸ ĞµÑ‘ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸',
	},
	
	'tr': {
		// Navigation
		'nav.streams': 'ğŸ­ Kaynaklar',
		'nav.linkoverlay': 'ğŸ”— BaÄŸlantÄ±lar ve Ayarlar',
		'nav.dashboard': 'ğŸ“° Durum ve GÃ¼nlÃ¼kler',
		'nav.eventfloweditor': 'ğŸª¤ Olay AkÄ±ÅŸ DÃ¼zenleyici',
		'nav.vdoninja': 'ğŸ¦ Uzak Kamera YayÄ±nÄ±',
		'nav.sessions': 'ğŸ§‘â€ğŸ¤â€ğŸ§‘ Oturumlar',
		
		// Buttons
		'btn.activate': 'â–¶ï¸ KaynaÄŸÄ± etkinleÅŸtir',
		'btn.signin': 'ğŸ”‘ GiriÅŸ yap',
		'btn.help': 'â“ YardÄ±m!',
		'btn.stop': 'â¹ï¸ Durdur',
		'btn.reload': 'ğŸ”„ Yenile',
		'btn.visible': 'ğŸ‘ï¸ GÃ¶rÃ¼nÃ¼r',
		'btn.hidden': 'ğŸ™ˆ Gizli',
		'btn.muted': 'ğŸ”‡ Sessiz',
		'btn.unmuted': 'ğŸ”Š Ses',
		
		// Settings menu
		'settings.title': 'Bu kaynak iÃ§in ek ayarlar',
		'settings.header': 'Ek Kontroller',
		'settings.clear': 'ğŸ§¹ Ã–nbelleÄŸi ve depolamayÄ± temizle',
		'settings.remove': 'ğŸ—‘ï¸ KaynaÄŸÄ± kaldÄ±r',
		
		// Sessions
		'sessions.title': 'KullanÄ±cÄ± OturumlarÄ±',
		'sessions.info': 'AyrÄ± ayarlar ve kaynaklarla birden fazla kullanÄ±cÄ± profilini yÃ¶netin.',
		'sessions.current': 'Mevcut Oturum',
		'sessions.available': 'KullanÄ±labilir Oturumlar',
		'sessions.create': 'â• Yeni Oturum OluÅŸtur',
		'sessions.export': 'ğŸ’¾ Mevcut Oturumu DÄ±ÅŸa Aktar',
		'sessions.import': 'ğŸ“‚ Oturum Ä°Ã§e Aktar',
		'sessions.switch': 'DeÄŸiÅŸtir',
		'sessions.active': 'Aktif',
		
		// Sources
		'source.add': 'Yeni kaynak ekle:',
		'source.mode.standard': 'ğŸ“„ Standart',
		'source.mode.websocket': 'ğŸŒ WebSocket',
		'source.autoactivate': 'Otomatik etkinleÅŸtir',
		'source.youtube.username': 'YouTube KullanÄ±cÄ± AdÄ±',
		'source.youtube.videoid': 'YouTube Video ID',
		'source.twitch': 'Twitch KullanÄ±cÄ± AdÄ±',
		'source.kick': 'Kick KullanÄ±cÄ± AdÄ±',
		'source.instagram': 'Instagram KullanÄ±cÄ± AdÄ±',
		'source.facebook': 'Facebook KullanÄ±cÄ± AdÄ±',
		'source.tiktok': 'TikTok KullanÄ±cÄ± AdÄ±',
		'source.other': 'DiÄŸer sohbet siteleri',
		
		// App info
		'app.title': 'Social Stream Ninja BaÄŸÄ±msÄ±z',
		'app.newversion': 'YENÄ° SÃœRÃœM MEVCUT',
		'app.download': 'Yeni sÃ¼rÃ¼mÃ¼ buradan indirin',
		
		// Groups
		'group.togglevisibility': 'TÃ¼m YayÄ±nlarÄ±n GÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼nÃ¼ DeÄŸiÅŸtir',
		'group.togglemute': 'TÃ¼m YayÄ±nlarÄ±n Sesini DeÄŸiÅŸtir',
		'group.stopall': 'TÃ¼m YayÄ±nlarÄ± Durdur',
		'group.reloadall': 'TÃ¼m YayÄ±nlarÄ± Yenile',
		'group.remove': 'ğŸ—‘ï¸ Grubu ve kaynaklarÄ±nÄ± kaldÄ±r',
	}
};

let currentLanguage = localStorage.getItem('language') || 'en';

function translate(key) {
	return translations[currentLanguage]?.[key] || translations['en'][key] || key;
}

function changeLanguage(lang) {
	currentLanguage = lang;
	localStorage.setItem('language', lang);
	
	// Update navigation links
	document.querySelectorAll('#main-navigation a').forEach(link => {
		const page = link.getAttribute('data-page');
		if (page) {
			const translationKey = `nav.${page.replace(/-/g, '')}`;
			link.textContent = translate(translationKey);
		}
	});
	
	// Update all translatable elements
	document.querySelectorAll('[data-i18n]').forEach(element => {
		const key = element.getAttribute('data-i18n');
		if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
			if (element.hasAttribute('placeholder')) {
				element.placeholder = translate(key);
			} else {
				element.textContent = translate(key);
			}
		} else {
			element.textContent = translate(key);
		}
	});
	
	// Update dynamically created content
	updateDynamicTranslations();
	
	// Refresh all iframes with new language parameter
	refreshIframesWithLanguage();
}

function refreshIframesWithLanguage() {
	// Get the language code (convert pt-BR to pt for URL parameter)
	const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
	
	// Map our language codes to popup.html language codes
	const languageMap = {
		'en': '',  // Default
		'de': 'de',
		'es': 'es',
		'pt-BR': 'pt-br',
		'fr': 'fr',  // Add if supported
		'it': 'it',  // Add if supported
		'ja': 'ja',  // Add if supported
		'zh': 'zh',  // Add if supported
		'ko': 'ko',  // Add if supported
		'ru': 'ru',  // Add if supported
		'tr': 'tr',
		'uk': 'uk'
	};
	
	const popupLangCode = languageMap[currentLanguage] || '';
	
	// Find all iframes in the content pane
	document.querySelectorAll('#content-pane iframe').forEach(iframe => {
		if (iframe.src && iframe.src !== 'about:blank') {
			try {
				// Send a message to the iframe to change language
				iframe.contentWindow.postMessage({
					type: 'changeLanguage',
					language: popupLangCode
				}, '*');
			} catch (e) {
				console.error('Error sending language message to iframe:', e);
			}
		}
	});
	
	// Also update any webviews that might be in sources
	document.querySelectorAll('webview').forEach(webview => {
		if (webview.src && webview.src !== 'about:blank') {
			try {
				const url = new URL(webview.src);
				url.searchParams.set('ln', langCode);
				webview.src = url.toString();
			} catch (e) {
				console.error('Error updating webview language:', e, webview.src);
			}
		}
	});
}

function updateDynamicTranslations() {
	// Update button texts in sources
	document.querySelectorAll('[data-activatehtml]').forEach(btn => {
		if (!btn.classList.contains('hidden')) {
			btn.textContent = translate('btn.activate');
		}
	});
	
	document.querySelectorAll('[data-signin]').forEach(btn => {
		btn.textContent = translate('btn.signin');
	});
	
	document.querySelectorAll('[data-showtips]').forEach(btn => {
		btn.textContent = translate('btn.help');
	});
	
	// Update mode selector options
	document.querySelectorAll('.mode-option').forEach(option => {
		if (option.dataset.mode === 'classic') {
			option.textContent = translate('source.mode.standard');
		} else if (option.dataset.mode === 'websocket' || option.dataset.mode === 'tiktok-websocket') {
			option.textContent = translate('source.mode.websocket');
		}
	});
	
	// Update toggle labels
	document.querySelectorAll('.toggle-label').forEach(label => {
		if (label.textContent.includes('Auto-activate')) {
			label.textContent = translate('source.autoactivate');
		}
	});
	
	// Update source buttons
	const sourceTypeMap = {
		'youtube-username': 'source.youtube.username',
		'youtube-videoid': 'source.youtube.videoid',
		'twitch': 'source.twitch',
		'kick': 'source.kick',
		'instagram': 'source.instagram',
		'facebook': 'source.facebook',
		'tiktok': 'source.tiktok',
		'other': 'source.other'
	};
	
	document.querySelectorAll('.addnew button[data-source-type]').forEach(btn => {
		const sourceType = btn.getAttribute('data-source-type');
		if (sourceTypeMap[sourceType]) {
			const img = btn.querySelector('img');
			if (img) {
				btn.innerHTML = img.outerHTML + translate(sourceTypeMap[sourceType]);
			}
		}
	});
}

// Toggle mobile menu
function toggleMenu() {
	const navList = document.querySelector('#main-navigation ul');
	navList.classList.toggle('active');
}

// Close mobile menu when clicking outside
document.addEventListener('click', (e) => {
	const nav = document.getElementById('main-navigation');
	const menuToggle = document.querySelector('.menu-toggle');
	const navList = document.querySelector('#main-navigation ul');
	
	if (!nav.contains(e.target) && navList.classList.contains('active')) {
		navList.classList.remove('active');
	}
});

// Set up navigation
document.addEventListener('DOMContentLoaded', () => {
	// Initialize language
	const savedLanguage = localStorage.getItem('language') || 'en';
	document.getElementById('language-select').value = savedLanguage;
	changeLanguage(savedLanguage);
	
	const navLinks = document.querySelectorAll('#main-navigation a');
	navLinks.forEach(link => {
		link.addEventListener('click', (e) => {
			e.preventDefault();
			const page = e.target.getAttribute('data-page');
			if (page) {
				showPage(page);
				// Close mobile menu after navigation
				const navList = document.querySelector('#main-navigation ul');
				navList.classList.remove('active');
			}
		});
	});
	
	// Restore last active page or show streams by default
	const savedPage = localStorage.getItem('currentPage') || 'streams';
	
	// If the saved page is event-flow-editor, we need to ensure the iframe loads with the correct view
	if (savedPage === 'event-flow-editor') {
		// Add a marker so setupIframeSource knows to load the editor view
		window.initialEditorView = true;
	}
	
	// Small delay to ensure all elements are loaded
	setTimeout(() => {
		showPage(savedPage);
	}, 100);
});

async function toggleYouTubeType(button) {
    try {
        const sourceElement = button.closest('[data-source-id]');
        if (!sourceElement) {
            console.error('toggleYouTubeType: No source element found');
            return;
        }
        
        const sourceId = sourceElement.dataset.sourceId;
        const source = stateManager.getSource(sourceId);
        if (!source) {
            console.error('toggleYouTubeType: Source not found for ID:', sourceId);
            return;
        }
        
        // Only allow for YouTube sources
        if (source.target !== 'youtube' && source.target !== 'youtubeshorts') {
            console.error('toggleYouTubeType: Not a YouTube source:', source.target);
            return;
        }
        
        // Don't allow toggle if source is active
        if (source.status === 'active' || source.vid || source.wssId) {
            alert("Cannot change type while source is active. Please stop the source first.");
            return;
        }
        
        const currentType = source.target;
        const newType = currentType === 'youtube' ? 'youtubeshorts' : 'youtube';
    
    // Update the source in state manager
    let newUrl = source.url;
    if (currentType === 'youtube' && newType === 'youtubeshorts') {
        // Add &shorts if not already present
        if (!newUrl.includes('&shorts')) {
            newUrl += '&shorts';
        }
    } else if (currentType === 'youtubeshorts' && newType === 'youtube') {
        // Remove &shorts
        newUrl = newUrl.replace('&shorts', '');
    }
    
    const updates = {
        target: newType,
        url: newUrl
    };
    
    stateManager.updateSource(sourceId, updates);
    
    // Update the UI
    const updatedSource = stateManager.getSource(sourceId);
    updateSourceUI(sourceElement, updatedSource);
    
    // Update the group if needed
    if (source.groupId) {
        const oldGroupId = source.groupId; // Store old group ID before it changes
        const oldGroup = stateManager.getGroup(oldGroupId);
        if (oldGroup && oldGroup.target !== newType) {
            // Find or create the appropriate group
            let newGroup = stateManager.getGroups().find(g => 
                g.username === oldGroup.username && g.target === newType
            );
            
            if (!newGroup) {
                // Create new group
                const newGroupId = stateManager.addGroup({
                    target: newType,
                    username: oldGroup.username,
                    isChannel: oldGroup.isChannel,
                    autoActivate: oldGroup.autoActivate,
                    groupVisible: oldGroup.groupVisible,
                    groupMuted: oldGroup.groupMuted
                });
                newGroup = stateManager.getGroup(newGroupId);
            }
            
            // Move source to new group
            stateManager.moveSourceToGroup(sourceId, newGroup.id);
            
            // Refresh UI - move element to new group
            const newGroupElement = document.querySelector(`[data-group-id="${newGroup.id}"]`);
            if (newGroupElement) {
                const streamsContainer = newGroupElement.querySelector('.stream-group');
                if (streamsContainer) {
                    streamsContainer.appendChild(sourceElement);
                }
            } else if (!newGroupElement && newGroup) {
                // If the group element doesn't exist yet, create it
                const groupElement = createGroupElement(newGroup.id);
                if (groupElement) {
                    document.getElementById("sources").appendChild(groupElement);
                    const streamsContainer = groupElement.querySelector('.stream-group');
                    if (streamsContainer) {
                        streamsContainer.appendChild(sourceElement);
                    }
                }
            }
            
            // Clean up old group if empty
            const remainingSourcesInOldGroup = stateManager.getSources({ groupId: oldGroupId });
            if (remainingSourcesInOldGroup.length === 0) {
                const oldGroupElement = document.querySelector(`[data-group-id="${oldGroupId}"]`);
                if (oldGroupElement) {
                    oldGroupElement.remove();
                }
                stateManager.removeGroup(oldGroupId);
            }
        }
    }
    
    console.log(`Toggled YouTube type from ${currentType} to ${newType} for source ${sourceId}`);
    } catch (error) {
        console.error('Error in toggleYouTubeType:', error);
        alert('An error occurred while changing the YouTube type. Please try again.');
    }
}

// User Agent Management Functions
const defaultUserAgents = [
  {
    "name": "Chrome - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  },
  {
    "name": "Firefox - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Firefox - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Safari - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
  },
  {
    "name": "Edge - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0"
  },
  {
    "name": "Opera - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 OPR/124.0.0.0"
  },
  {
    "name": "Chrome - Android",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Firefox - Android",
    "value": "Mozilla/5.0 (Android 15; Mobile; rv:136.0) Gecko/136.0 Firefox/136.0"
  },
  {
    "name": "Samsung Internet - Android",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/23.0 Chrome/134.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Safari - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Mobile/15E148 Safari/605.1.15"
  },
  {
    "name": "Chrome - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/134.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Edge - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) EdgiOS/134.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Generic Chrome - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari/537.36"
  },
  {
    "name": "Generic Firefox - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv) Gecko/20100101 Firefox"
  },
  {
    "name": "Generic Safari - Mac (No Version)",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version Safari/605.1.15"
  },
  {
    "name": "Generic Edge - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari/537.36 Edg"
  },
  {
    "name": "Generic Chrome - Android (No Version)",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Mobile Safari/537.36"
  },
  {
    "name": "Generic Safari - iPhone (No Version)",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version Mobile Safari/605.1.15"
  }
];


let currentSourceId = null;

function openUserAgentSettings(button) {
    const sourceElement = button.closest('[data-source-id]');
    if (!sourceElement) {
        console.error('openUserAgentSettings: No source element found');
        return;
    }
    
    currentSourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(currentSourceId);
    if (!source) {
        console.error('openUserAgentSettings: Source not found for ID:', currentSourceId);
        return;
    }
    
    // Close the settings menu
    const settingsMenu = button.closest('.settings-menu');
    if (settingsMenu) {
        settingsMenu.classList.remove('active');
    }
    
    // Load saved user agents
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    const select = document.getElementById('userAgentSelect');
    
    // Clear existing options
    select.innerHTML = '<option value="AUTO">AUTO (Use config file)</option>';
    
    // Add default user agents
    defaultUserAgents.forEach(ua => {
        const option = document.createElement('option');
        option.value = ua.value;
        option.textContent = ua.name;
        select.appendChild(option);
    });
    
    // Add custom user agents
    savedUserAgents.forEach((ua, index) => {
        const option = document.createElement('option');
        option.value = ua.value;
        option.textContent = `Custom: ${ua.name}`;
        option.dataset.customIndex = index;
        select.appendChild(option);
    });
    
    // Set current selection
    const currentUserAgent = source.userAgent || 'AUTO';
    select.value = currentUserAgent;
    
    // Update custom user agents list
    updateCustomUserAgentsList();
    
    // Show modal
    document.getElementById('userAgentModal').classList.remove('hidden');
}

function closeUserAgentModal() {
    document.getElementById('userAgentModal').classList.add('hidden');
    currentSourceId = null;
}

function addCustomUserAgent() {
    const input = document.getElementById('customUserAgentInput');
    const userAgent = input.value.trim();
    
    if (!userAgent) {
        Toast.error('Input Required', 'Please enter a user agent string');
        return;
    }
    
    // Get saved user agents
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    
    // Auto-generate a name based on the user agent string
    let name = 'Custom User Agent';
    if (userAgent.includes('Chrome')) name = 'Custom Chrome';
    else if (userAgent.includes('Firefox')) name = 'Custom Firefox';
    else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) name = 'Custom Safari';
    else if (userAgent.includes('Edge')) name = 'Custom Edge';
    
    // Add a number if this name already exists
    const existingNames = savedUserAgents.map(ua => ua.name);
    let finalName = name;
    let counter = 1;
    while (existingNames.includes(finalName)) {
        finalName = `${name} ${counter}`;
        counter++;
    }
    
    // Add new user agent
    savedUserAgents.push({ name: finalName, value: userAgent });
    localStorage.setItem('customUserAgents', JSON.stringify(savedUserAgents));
    
    // Clear input
    input.value = '';
    
    // Update the select dropdown immediately
    const select = document.getElementById('userAgentSelect');
    const option = document.createElement('option');
    option.value = userAgent;
    option.textContent = `Custom: ${finalName}`;
    option.dataset.customIndex = savedUserAgents.length - 1;
    select.appendChild(option);
    
    // Update the list display
    updateCustomUserAgentsList();
    
    Toast.success('User Agent Added', `Added "${finalName}" to your custom user agents`);
}

function updateCustomUserAgentsList() {
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    const listContainer = document.getElementById('customUserAgentsList');
    
    listContainer.innerHTML = '';
    
    if (savedUserAgents.length === 0) {
        listContainer.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-style: italic;">No custom user agents added yet.</p>';
        return;
    }
    
    savedUserAgents.forEach((ua, index) => {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 8px;';
        item.innerHTML = `
            <div style="flex: 1;">
                <strong style="color: #63a4d8;">${ua.name}</strong><br>
                <span style="font-size: 12px; color: rgba(255,255,255,0.7); word-break: break-all;">${ua.value}</span>
            </div>
            <button onclick="removeCustomUserAgent(${index})" style="margin-left: 10px; padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
        `;
        listContainer.appendChild(item);
    });
}

function removeCustomUserAgent(index) {
    if (!confirm('Are you sure you want to remove this custom user agent?')) return;
    
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    savedUserAgents.splice(index, 1);
    localStorage.setItem('customUserAgents', JSON.stringify(savedUserAgents));
    
}

function saveUserAgentSelection() {
    if (!currentSourceId) {
        console.error('No source ID set');
        return;
    }
    
    const select = document.getElementById('userAgentSelect');
    const selectedValue = select.value;
    
    // Update the source
    const source = stateManager.getSource(currentSourceId);
    if (!source) {
        console.error('Source not found:', currentSourceId);
        return;
    }
    
    // Save the user agent preference
    source.userAgent = selectedValue;
    stateManager.updateSource(currentSourceId, { userAgent: selectedValue });
    
    // Show success message
    Toast.success('User Agent Updated', `User agent preference saved for ${source.username || source.target}`);
    
    // Close modal
    closeUserAgentModal();
}

// User agent handling is now done directly in the window creation functions

// Session Management Functions
let currentSessionSourceId = null;

function openSessionSettings(button) {
    const sourceElement = button.closest('[data-source-id]');
    if (!sourceElement) {
        console.error('openSessionSettings: No source element found');
        return;
    }
    
    currentSessionSourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) {
        console.error('openSessionSettings: Source not found:', currentSessionSourceId);
        return;
    }
    
    // Close settings menu
    const settingsMenu = button.closest('.settings-menu');
    if (settingsMenu) {
        settingsMenu.classList.remove('active');
    }
    
    // Store the current session value
    // If no custom session or AUTO, default to platform default
    if (!source.customSession || source.customSession === 'AUTO') {
        window.currentSelectedSession = `default-${source.target}`;
    } else {
        window.currentSelectedSession = source.customSession;
    }
    
    // Update sessions list
    updateSessionsList();
    
    // Show modal
    document.getElementById('sessionModal').classList.remove('hidden');
}

function closeSessionModal() {
    document.getElementById('sessionModal').classList.add('hidden');
    currentSessionSourceId = null;
}

function addCustomSession() {
    const input = document.getElementById('customSessionName');
    const sessionName = input.value.trim();
    
    if (!sessionName) {
        Toast.error('Input Required', 'Please enter a session name');
        return;
    }
    
    // Validate session name (alphanumeric, hyphens, underscores only)
    if (!/^[a-zA-Z0-9-_]+$/.test(sessionName)) {
        Toast.error('Invalid Name', 'Session names can only contain letters, numbers, hyphens, and underscores');
        return;
    }
    
    // Get saved sessions
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    
    // Check if name already exists
    if (customSessions.some(s => s.name === sessionName)) {
        Toast.error('Name Exists', 'A session with this name already exists');
        return;
    }
    
    // Add new session
    customSessions.push({
        name: sessionName,
        created: Date.now(),
        description: `Custom session for ${sessionName}`
    });
    
    localStorage.setItem('customSessions', JSON.stringify(customSessions));
    
    // Clear input
    input.value = '';
    
    // Auto-select the newly created session
    window.currentSelectedSession = sessionName;
    
    // Update the list display immediately
    updateSessionsList();
    
    Toast.success('Session Created', `Created custom session "${sessionName}" and selected it`);
}

function updateSessionsList() {
    const container = document.getElementById('sessionsList');
    if (!container) return;
    
    // Clear container
    container.innerHTML = '';
    
    // Get current source info
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) return;
    
    // Platform defaults
    const platformDefaults = {
        'youtube': 'YouTube Default',
        'youtubeshorts': 'YouTube Default',
        'twitch': 'Twitch Default',
        'kick': 'Kick Default',
        'tiktok': 'TikTok Default',
        'facebook': 'Facebook Default',
        'instagramlive': 'Instagram Default',
        'x': 'X.com Default',
        'rumble': 'Rumble Default'
    };
    
    // Add platform-specific default if available
    if (platformDefaults[source.target]) {
        const platformDiv = document.createElement('div');
        platformDiv.className = 'session-item';
        platformDiv.dataset.sessionValue = `default-${source.target}`;
        if (window.currentSelectedSession === `default-${source.target}`) {
            platformDiv.classList.add('selected');
        }
        platformDiv.innerHTML = `
            <span class="session-item-name">${platformDefaults[source.target]}</span>
            <span class="session-item-actions">
                <span style="color: #aaa; font-size: 12px;">Platform default</span>
            </span>
        `;
        platformDiv.onclick = () => selectSession(`default-${source.target}`);
        container.appendChild(platformDiv);
    }
    
    // Add custom sessions
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    customSessions.forEach(session => {
        const sessionDiv = document.createElement('div');
        sessionDiv.className = 'session-item';
        sessionDiv.dataset.sessionValue = session.name;
        if (window.currentSelectedSession === session.name) {
            sessionDiv.classList.add('selected');
        }
        sessionDiv.innerHTML = `
            <span class="session-item-name">${session.name}</span>
            <span class="session-item-actions">
                <span style="color: #aaa; font-size: 12px;">Custom</span>
                <button class="session-remove-btn" onclick="event.stopPropagation(); removeCustomSession('${session.name}')" title="Remove session">Ã—</button>
            </span>
        `;
        sessionDiv.onclick = () => selectSession(session.name);
        container.appendChild(sessionDiv);
    });
}

function selectSession(sessionValue) {
    console.log(`[SESSION DEBUG] Selected session: ${sessionValue}`);
    window.currentSelectedSession = sessionValue;
    
    // Update visual selection
    document.querySelectorAll('.session-item').forEach(item => {
        item.classList.remove('selected');
        if (item.dataset.sessionValue === sessionValue) {
            item.classList.add('selected');
        }
    });
}

function removeCustomSession(sessionName) {
    if (!confirm('Are you sure you want to remove this custom session? Any sources using this session will revert to default.')) return;
    
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    const sessionIndex = customSessions.findIndex(s => s.name === sessionName);
    
    if (sessionIndex === -1) return;
    
    customSessions.splice(sessionIndex, 1);
    localStorage.setItem('customSessions', JSON.stringify(customSessions));
    
    // Update any sources using this session
    const allSources = stateManager.getSources();
    allSources.forEach(source => {
        if (source.customSession === sessionName) {
            stateManager.updateSource(source.id, { customSession: 'default' });
        }
    });
    
    // If this was the selected session, select platform default
    if (window.currentSelectedSession === sessionName) {
        const source = stateManager.getSource(currentSessionSourceId);
        window.currentSelectedSession = source ? `default-${source.target}` : 'AUTO';
    }
    
    // Update the list
    updateSessionsList();
    
    Toast.success('Session Removed', `Removed session "${sessionName}"`);
}

function saveSessionSelection() {
    if (!currentSessionSourceId) {
        console.error('No source ID set');
        return;
    }
    
    // Update the source
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) {
        console.error('Source not found:', currentSessionSourceId);
        return;
    }
    
    // Save the session preference
    console.log(`[SESSION DEBUG] Saving customSession: ${window.currentSelectedSession} for source: ${currentSessionSourceId}`);
    stateManager.updateSource(currentSessionSourceId, { customSession: window.currentSelectedSession });
    
    // Verify it was saved
    const updatedSource = stateManager.getSource(currentSessionSourceId);
    console.log(`[SESSION DEBUG] Source after update:`, updatedSource.customSession);
    
    // Show success message
    const sessionName = window.currentSelectedSession === 'AUTO' ? 'default' : window.currentSelectedSession;
    Toast.success('Session Updated', `Session preference set to "${sessionName}" for ${source.username || source.target}`);
    
    // Close modal
    closeSessionModal();
}

</script>
</body>
</html>
