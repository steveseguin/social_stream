<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giveaway Wheel - OBS Widget</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: white;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .wheel-container {
            position: relative;
            width: 400px;
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wheel-canvas {
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s ease-out;
        }

        .wheel-pointer {
            position: absolute;
            top: 50%;
            right: -15px;
            width: 0;
            height: 0;
            border-left: 20px solid #ff4444;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            z-index: 10;
            transform: translateY(-50%);
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
        }

        .wheel-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        .winner-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            font-size: 2em;
            font-weight: bold;
            border: 3px solid #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            z-index: 100;
            display: none;
            animation: winnerPop 0.5s ease-out;
        }

        @keyframes winnerPop {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .winner-text {
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .winner-name {
            font-size: 1.2em;
            color: #FFD700;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            z-index: 1000;
            pointer-events: none;
        }

        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
            z-index: 50;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        .keyword-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            font-size: 16px;
            z-index: 50;
        }

        .keyword-label {
            color: #ccc;
            font-size: 12px;
        }

        .keyword-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
        }

        /* Hide everything when no participants */
        .no-participants {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #888;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div class="status-indicator"></div>
    
    <div class="keyword-display">
        <div class="keyword-label">Entry Keyword:</div>
        <div class="keyword-value" id="current-keyword">ENTER</div>
    </div>

    <div class="wheel-container" id="wheel-container">
        <div class="wheel-pointer"></div>
        <canvas id="wheel-canvas" class="wheel-canvas" width="400" height="400"></canvas>
        <div class="wheel-center"></div>
        
        <div class="winner-display" id="winner-display">
            <div class="winner-text">ðŸŽ‰ WINNER! ðŸŽ‰</div>
            <div class="winner-name" id="winner-name"></div>
        </div>
        
        <div class="no-participants" id="no-participants">
            Waiting for participants...
        </div>
    </div>

    <script>
        // Get session parameters from URL (same as other Social Stream files)
        const urlParams = new URLSearchParams(window.location.search);
        let roomID = "test";
        let password = "false";
        
        if (urlParams.has("session")) {
            roomID = urlParams.get("session");
        } else if (urlParams.has("s")) {
            roomID = urlParams.get("s");
        } else if (urlParams.has("id")) {
            roomID = urlParams.get("id");
        }
        
        if (urlParams.has("password")) {
            password = urlParams.get("password") || "false";
        }

        class OBSWheelWidget {
            constructor() {
                this.entrants = {};
                this.currentKeyword = 'ENTER';
                this.isSpinning = false;
                this.currentRotation = 0;
                this.platformIconCache = {};
                this.iframe = null;
                this.socketserver = null;
                
                this.canvas = document.getElementById('wheel-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.init();
            }

            init() {
                this.loadState();
                this.loadKeyword();
                this.drawWheel();
                this.setupLocalCommunication();
                this.setupWebRTCConnection();
                this.setupWebSocketConnection();
            }

            loadState() {
                try {
                    // Load from localStorage for backward compatibility
                    const wheelState = localStorage.getItem('giveawayWheelState');
                    if (wheelState) {
                        const state = JSON.parse(wheelState);
                        if (state.entrants) {
                            this.entrants = state.entrants;
                        }
                    }
                } catch (error) {
                    console.error('Error loading state:', error);
                }
            }

            loadKeyword() {
                const savedKeyword = localStorage.getItem('giveaway_keyword');
                if (savedKeyword) {
                    this.currentKeyword = savedKeyword;
                    document.getElementById('current-keyword').textContent = this.currentKeyword;
                }
            }

            setupLocalCommunication() {
                // Use BroadcastChannel API for local communication between tabs
                if (typeof BroadcastChannel !== 'undefined') {
                    this.channel = new BroadcastChannel('giveaway_' + roomID);
                    
                    const self = this;
                    this.channel.addEventListener('message', function(event) {
                        console.log('ðŸ“¥ OBS Widget received local broadcast:', event.data);
                        self.handleWebRTCMessage(event.data);
                    });
                    
                    console.log('ðŸ“¡ OBS Widget local communication channel established');
                } else {
                    // Fallback to localStorage for older browsers
                    console.log('ðŸ“¡ OBS Widget using localStorage fallback for local communication');
                    const self = this;
                    window.addEventListener('storage', function(e) {
                        if (e.key === 'giveaway_broadcast_' + roomID) {
                            try {
                                const data = JSON.parse(e.newValue);
                                self.handleWebRTCMessage(data);
                            } catch (error) {
                                console.error('Error processing localStorage message:', error);
                            }
                        }
                    });
                }
            }

            setupWebRTCConnection() {
                console.log('ðŸš€ Setting up WebRTC connection for OBS widget...');
                
                if (!roomID || roomID === "test") {
                    console.log("âš ï¸ Using test session - OBS widget will use local communication only");
                    return;
                }
                
                // Create hidden iframe for WebRTC connection (same pattern as other files)
                this.iframe = document.createElement('iframe');
                this.iframe.style.width = "0px";
                this.iframe.style.height = "0px";
                this.iframe.style.position = "fixed";
                this.iframe.style.left = "-100px";
                this.iframe.style.top = "-100px";
                this.iframe.id = "obs-frame";
                this.iframe.allow = "midi;geolocation;microphone;";
                
                // Connect to receive giveaway updates (use same parameters as main page for sync)
                this.iframe.src = "https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password="+password+"&push&label=dock&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput&room="+roomID;
                
                document.body.appendChild(this.iframe);
                
                // Set up message listener for WebRTC data
                const self = this;
                window.addEventListener('message', function(e) {
                    console.log('ðŸ”¥ðŸ”¥ðŸ”¥ OBS WIDGET: RAW MESSAGE RECEIVED ðŸ”¥ðŸ”¥ðŸ”¥');
                    console.log('ðŸ“¨ Full event object:', e);
                    console.log('ðŸ“¦ Event data:', e.data);
                    console.log('ðŸŒ Event origin:', e.origin);
                    console.log('ðŸ“ Event source:', e.source);
                    console.log('ðŸ–¼ï¸ Iframe source check:', e.source === self.iframe.contentWindow);
                    console.log('â° Timestamp:', new Date().toISOString());
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    
                    if (e.source != self.iframe.contentWindow) {
                        console.log('âŒ OBS WIDGET: REJECTED - Message not from our iframe');
                        return;
                    }
                    
                    console.log('âœ… OBS WIDGET: MESSAGE SOURCE VERIFIED - Processing...');
                    
                    if ("dataReceived" in e.data) {
                        console.log('ðŸŽ¯ OBS WIDGET: WEBRTC DATA RECEIVED STRUCTURE DETECTED!');
                        console.log('ðŸ“‹ Full dataReceived:', e.data.dataReceived);
                        
                        if ("overlayNinja" in e.data.dataReceived) {
                            console.log('ðŸŽ‰ OBS WIDGET: FOUND CHAT MESSAGE via WebRTC!');
                            console.log('ðŸ’¬ Chat data:', e.data.dataReceived.overlayNinja);
                            self.handleWebRTCMessage(e.data.dataReceived.overlayNinja);
                        } else {
                            console.log('â“ OBS WIDGET: dataReceived exists but no overlayNinja property');
                            console.log('ðŸ” dataReceived keys:', Object.keys(e.data.dataReceived));
                        }
                    } else if (e.data.overlayNinja) {
                        console.log('ðŸŽ‰ OBS WIDGET: FOUND DIRECT OVERLAY MESSAGE!');
                        console.log('ðŸ’¬ Overlay data:', e.data.overlayNinja);
                        self.handleWebRTCMessage(e.data.overlayNinja);
                    } else {
                        console.log('â“ OBS WIDGET: UNKNOWN MESSAGE FORMAT - NOT PROCESSING');
                        console.log('ðŸ” Data type:', typeof e.data);
                        console.log('ðŸ” Data keys:', e.data ? Object.keys(e.data) : 'No data object');
                        console.log('ðŸ” Raw data:', JSON.stringify(e.data, null, 2));
                    }
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
                });
                
                console.log('ðŸŽ¯ OBS Widget connected to Social Stream WebRTC');
            }

            setupWebSocketConnection() {
                if (!urlParams.has("server")) return;
                
                const serverURL = urlParams.get("server") || "wss://io.socialstream.ninja/api";
                this.socketserver = new WebSocket(serverURL);
                
                const self = this;
                this.socketserver.onopen = function() {
                    // Listen on channel 6 for giveaway updates
                    self.socketserver.send(JSON.stringify({ join: roomID.split(",")[0], out: 6, in: 5 }));
                    console.log("OBS Widget WebSocket: listening on channel 6");
                };
                
                this.socketserver.addEventListener('message', function(event) {
                    if (event.data) {
                        try {
                            const data = JSON.parse(event.data);
                            self.handleWebRTCMessage(data);
                        } catch (e) {
                            console.error("Error processing WebSocket message:", e);
                        }
                    }
                });
            }



            handleWebRTCMessage(data) {
                console.log('ðŸŽ¯ðŸŽ¯ðŸŽ¯ OBS WIDGET: HANDLE WEBRTC MESSAGE CALLED ðŸŽ¯ðŸŽ¯ðŸŽ¯');
                console.log('ðŸ“¦ Input data:', data);
                console.log('ðŸ” Data type:', typeof data);
                console.log('ðŸ” Data keys:', data ? Object.keys(data) : 'No data object');
                console.log('â° Timestamp:', new Date().toISOString());
                
                if (data.action === 'giveaway_update') {
                    console.log('ðŸŽ‰ OBS WIDGET: Processing giveaway_update');
                    console.log('ðŸ“‹ Update data:', data.data);
                    this.handleGiveawayUpdate(data.data);
                } else if (data.action === 'keyword_update') {
                    console.log('ðŸŽ‰ OBS WIDGET: Processing keyword_update');
                    console.log('ðŸ”‘ New keyword:', data.keyword);
                    this.handleKeywordUpdate(data.keyword);
                } else if (data.action === 'spin_update') {
                    console.log('ðŸŽ‰ OBS WIDGET: Processing spin_update');
                    console.log('ðŸŽ¡ Spin data:', data.data);
                    this.handleSpinState(data.data);
                } else if (data.action === 'winner_update') {
                    console.log('ðŸŽ‰ OBS WIDGET: Processing winner_update');
                    console.log('ðŸ† Winner data:', data.data);
                    this.handleWinnerUpdate(data.data);
                } else {
                    console.log('â“ OBS WIDGET: Unknown action type:', data.action);
                    console.log('ðŸ” Full data:', JSON.stringify(data, null, 2));
                }
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
            }

            handleGiveawayUpdate(data) {
                if (data && data.entrants) {
                    console.log('ðŸ“¥ OBS Widget received giveaway update');
                    this.entrants = data.entrants;
                    this.drawWheel();
                }
            }

            handleKeywordUpdate(keyword) {
                if (keyword) {
                    console.log('ðŸ“¥ OBS Widget received keyword update:', keyword);
                    this.currentKeyword = keyword;
                    document.getElementById('current-keyword').textContent = this.currentKeyword;
                }
            }

            handleWinnerUpdate(winnerData) {
                if (winnerData && winnerData.name) {
                    console.log('ðŸ“¥ OBS Widget received winner update:', winnerData.name);
                    this.showWinner(JSON.stringify(winnerData));
                }
            }

            handleSpinState(spinState) {
                if (!spinState) return;
                
                try {
                    if (spinState.isSpinning) {
                        console.log('ðŸŽ¡ Starting synchronized spin with:', spinState);
                        this.startSpin(
                            spinState.targetRotation, 
                            spinState.duration, 
                            spinState.startTime, 
                            spinState.targetRotationDegrees,
                            spinState.initialRotation || 0
                        );
                    }
                } catch (error) {
                    console.error('Error handling spin state:', error);
                }
            }

            showWinner(winner) {
                if (!winner) return;
                
                try {
                    // Handle both JSON string (backward compatibility) and object
                    if (typeof winner === 'string') {
                        winner = JSON.parse(winner);
                    }
                    
                    const winnerDisplay = document.getElementById('winner-display');
                    const winnerName = document.getElementById('winner-name');
                    
                    winnerName.textContent = winner.name;
                    winnerDisplay.style.display = 'block';
                    
                    // Create confetti
                    this.createConfetti();
                    
                    // Hide winner after 5 seconds
                    setTimeout(() => {
                        winnerDisplay.style.display = 'none';
                    }, 5000);
                } catch (error) {
                    console.error('Error showing winner:', error);
                }
            }

            getPlatformColor(platform, index) {
                const platformColors = {
                    'twitch': '#9146ff',
                    'youtube': '#ff0000',
                    'facebook': '#1877f2',
                    'instagram': '#e4405f',
                    'tiktok': '#000000',
                    'discord': '#5865f2',
                    'kick': '#53fc18'
                };
                return platformColors[platform?.toLowerCase()] || `hsl(${index * 137.5 % 360}, 70%, 60%)`;
            }

            preloadPlatformIcons(entrants, callback) {
                const entrantsList = Object.values(entrants);
                const uniquePlatforms = [...new Set(entrantsList.map(e => e.platform).filter(p => p))];
                let loadedCount = 0;
                const totalCount = uniquePlatforms.length;
                
                if (totalCount === 0) {
                    callback();
                    return;
                }
                
                uniquePlatforms.forEach(platform => {
                    if (this.platformIconCache[platform]) {
                        loadedCount++;
                        if (loadedCount === totalCount) callback();
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = () => {
                        this.platformIconCache[platform] = img;
                        loadedCount++;
                        if (loadedCount === totalCount) callback();
                    };
                    img.onerror = () => {
                        this.platformIconCache[platform] = null;
                        loadedCount++;
                        if (loadedCount === totalCount) callback();
                    };
                    img.src = `./sources/images/${platform.toLowerCase()}.png`;
                });
            }

            drawWheel() {
                const entrantsList = Object.values(this.entrants);
                const noParticipants = document.getElementById('no-participants');
                
                if (entrantsList.length === 0) {
                    noParticipants.style.display = 'block';
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    return;
                }
                
                noParticipants.style.display = 'none';
                
                // Preload platform icons first, then draw
                this.preloadPlatformIcons(this.entrants, () => {
                    this.drawWheelWithIcons();
                });
            }

            drawWheelWithIcons() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 20;
                
                const entrantsList = Object.values(this.entrants);
                const segmentAngle = (2 * Math.PI) / entrantsList.length;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw outer shadow for depth
                this.ctx.save();
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 8;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fill();
                this.ctx.restore();
                
                // Apply current rotation
                this.ctx.save();
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(this.currentRotation);
                this.ctx.translate(-centerX, -centerY);
                
                // Draw wheel segments with modern material design
                entrantsList.forEach((entrant, index) => {
                    const startAngle = index * segmentAngle;
                    const endAngle = (index + 1) * segmentAngle;
                    
                    // Get modern platform-specific color
                    const segmentColor = this.getModernPlatformColor(entrant.platform, index);
                    
                    // Draw segment with gradient
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    this.ctx.closePath();
                    
                    // Create radial gradient for depth
                    const midAngle = startAngle + segmentAngle / 2;
                    const gradientX = centerX + Math.cos(midAngle) * radius * 0.3;
                    const gradientY = centerY + Math.sin(midAngle) * radius * 0.3;
                    const gradient = this.ctx.createRadialGradient(gradientX, gradientY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, segmentColor.light);
                    gradient.addColorStop(0.7, segmentColor.main);
                    gradient.addColorStop(1, segmentColor.dark);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();
                    
                    // Modern border with subtle shadow
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                    
                    // Add inner shadow for depth
                    this.ctx.save();
                    this.ctx.clip();
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.arc(centerX, centerY, radius - 2, startAngle, endAngle);
                    this.ctx.closePath();
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                    this.ctx.restore();
                    
                    // Draw modern text and platform badge
                    this.ctx.save();
                    this.ctx.translate(centerX, centerY);
                    this.ctx.rotate(startAngle + segmentAngle / 2);
                    
                    // Position elements with modern spacing
                    const textRadius = radius - 60; // More space for modern design
                    const textX = textRadius;
                    const maxTextWidth = radius * 0.5;
                    
                    // Modern typography with better contrast
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '600 20px "Segoe UI", system-ui, -apple-system, sans-serif';
                    
                    // Modern text shadow for depth
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.shadowBlur = 6;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 2;
                    
                    const userName = entrant.name || 'Anonymous';
                    
                    // Smart text truncation
                    let displayText = userName;
                    if (this.ctx.measureText(displayText).width > maxTextWidth) {
                        while (this.ctx.measureText(displayText + '...').width > maxTextWidth && displayText.length > 1) {
                            displayText = displayText.slice(0, -1);
                        }
                        displayText += '...';
                    }
                    
                    // Draw username with modern styling
                    this.ctx.fillText(displayText, textX, -15);
                    
                    // Draw platform icon at the edge
                    if (entrant.platform) {
                        const platformIcon = this.platformIconCache[entrant.platform];
                        
                        if (platformIcon) {
                            // Draw platform icon at the edge below text
                            const iconSize = 24; // Larger icon for edge visibility
                            const iconX = textX - iconSize/2; // Center the icon
                            const iconY = 8; // Position below text
                            
                            // Draw icon background circle with stronger contrast
                            this.ctx.beginPath();
                            this.ctx.arc(textX, iconY + iconSize/2, iconSize/2 + 4, 0, 2 * Math.PI);
                            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                            this.ctx.fill();
                            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                            this.ctx.lineWidth = 3;
                            this.ctx.stroke();
                            
                            // Draw platform icon
                            this.ctx.drawImage(platformIcon, iconX, iconY, iconSize, iconSize);
                        } else {
                            // Fallback to text badge at the edge
                            const platformText = entrant.platform.substring(0, 3).toUpperCase();
                            this.ctx.font = 'bold 14px Arial';
                            
                            // Draw badge background with stronger contrast for edge visibility
                            const badgeWidth = 36;
                            const badgeHeight = 20;
                            const badgeX = textX - badgeWidth/2;
                            const badgeY = 8;
                            
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                            this.ctx.fillRect(badgeX, badgeY, badgeWidth, badgeHeight);
                            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(badgeX, badgeY, badgeWidth, badgeHeight);
                            
                            // Draw badge text
                            this.ctx.fillStyle = '#fff';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(platformText, textX, badgeY + badgeHeight/2);
                        }
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore();
                
                // Draw modern center hub
                this.drawModernCenterHub(centerX, centerY);
                
                // Draw modern pointer
                this.drawModernPointer(centerX, centerY, radius);
            }

            // Modern color palette function (identical to main page)
            getModernPlatformColor(platform, index) {
                const modernColors = {
                    'twitch': { main: '#9146ff', light: '#b794ff', dark: '#6b2db8' },
                    'youtube': { main: '#ff0000', light: '#ff4444', dark: '#cc0000' },
                    'discord': { main: '#5865f2', light: '#7983f5', dark: '#4752c4' },
                    'facebook': { main: '#1877f2', light: '#4b9cff', dark: '#0d5dbf' },
                    'instagram': { main: '#e4405f', light: '#ff6b8a', dark: '#c13584' },
                    'tiktok': { main: '#000000', light: '#333333', dark: '#000000' },
                    'kick': { main: '#53fc18', light: '#7dff4d', dark: '#3eb813' },
                    'default': [
                        { main: '#667eea', light: '#8fa5ff', dark: '#4c63d2' },
                        { main: '#764ba2', light: '#9d7bc7', dark: '#5a3780' },
                        { main: '#f093fb', light: '#ffb3ff', dark: '#e066f0' },
                        { main: '#4facfe', light: '#7cc8ff', dark: '#2196f3' },
                        { main: '#43e97b', light: '#6eff9f', dark: '#00e676' },
                        { main: '#fa709a', light: '#ff9dc6', dark: '#f06292' },
                        { main: '#fee140', light: '#ffeb70', dark: '#fbc02d' },
                        { main: '#a8edea', light: '#c8f7f5', dark: '#80cbc4' }
                    ]
                };
                
                if (platform && modernColors[platform.toLowerCase()]) {
                    return modernColors[platform.toLowerCase()];
                }
                
                return modernColors.default[index % modernColors.default.length];
            }

            // Draw modern center hub with material design (identical to main page)
            drawModernCenterHub(centerX, centerY) {
                const hubRadius = 25;
                
                // Hub shadow
                this.ctx.save();
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                this.ctx.shadowBlur = 15;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 6;
                
                // Hub gradient
                const hubGradient = this.ctx.createRadialGradient(centerX, centerY - 5, 0, centerX, centerY, hubRadius);
                hubGradient.addColorStop(0, '#ffffff');
                hubGradient.addColorStop(0.7, '#f8f9fa');
                hubGradient.addColorStop(1, '#e9ecef');
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, hubRadius, 0, 2 * Math.PI);
                this.ctx.fillStyle = hubGradient;
                this.ctx.fill();
                this.ctx.restore();
                
                // Hub border
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, hubRadius, 0, 2 * Math.PI);
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Inner hub detail
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, hubRadius - 8, 0, 2 * Math.PI);
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }

            // Draw modern pointer with material design (identical to main page)
            drawModernPointer(centerX, centerY, radius) {
                const pointerLength = 40;
                const pointerWidth = 20;
                
                // Pointer shadow
                this.ctx.save();
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                this.ctx.shadowBlur = 12;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 6;
                
                // Draw pointer triangle
                this.ctx.beginPath();
                this.ctx.moveTo(centerX + radius - 5, centerY); // Point at edge
                this.ctx.lineTo(centerX + radius - pointerLength, centerY - pointerWidth/2); // Top
                this.ctx.lineTo(centerX + radius - pointerLength, centerY + pointerWidth/2); // Bottom
                this.ctx.closePath();
                
                // Pointer gradient
                const pointerGradient = this.ctx.createLinearGradient(
                    centerX + radius - pointerLength, centerY - pointerWidth/2,
                    centerX + radius - 5, centerY
                );
                pointerGradient.addColorStop(0, '#ff6b6b');
                pointerGradient.addColorStop(0.5, '#ff5252');
                pointerGradient.addColorStop(1, '#f44336');
                
                this.ctx.fillStyle = pointerGradient;
                this.ctx.fill();
                this.ctx.restore();
                
                // Pointer border
                this.ctx.beginPath();
                this.ctx.moveTo(centerX + radius - 5, centerY);
                this.ctx.lineTo(centerX + radius - pointerLength, centerY - pointerWidth/2);
                this.ctx.lineTo(centerX + radius - pointerLength, centerY + pointerWidth/2);
                this.ctx.closePath();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Pointer highlight
                this.ctx.beginPath();
                this.ctx.moveTo(centerX + radius - 5, centerY);
                this.ctx.lineTo(centerX + radius - pointerLength, centerY - pointerWidth/2);
                this.ctx.lineTo(centerX + radius - pointerLength + 8, centerY);
                this.ctx.closePath();
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.fill();
            }

            startSpin(targetRotation, duration, startTime = null, targetDegrees = null, initialRotation = 0) {
                if (this.isSpinning) return;
                
                this.isSpinning = true;
                
                // Reset to synchronized initial rotation
                this.currentRotation = (initialRotation * Math.PI) / 180; // Convert to radians
                this.drawWheel(); // Immediately show reset position
                
                const syncStartTime = startTime || Date.now();
                
                // Use degrees if provided for consistency with main page
                const finalRotation = targetDegrees !== null ? targetDegrees : (targetRotation * 180 / Math.PI);
                
                // Wait until sync start time to ensure both wheels start together
                const delay = Math.max(0, syncStartTime - Date.now());
                setTimeout(() => {
                    const animate = () => {
                        const elapsed = Date.now() - syncStartTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Easing function (identical to main page)
                        const easeOut = 1 - Math.pow(1 - progress, 3);
                        
                        // Calculate rotation in degrees for consistency, starting from initialRotation
                        const currentRotationDegrees = initialRotation + (finalRotation - initialRotation) * easeOut;
                        this.currentRotation = (currentRotationDegrees * Math.PI) / 180; // Convert to radians for canvas
                        this.drawWheel();
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            this.isSpinning = false;
                            this.currentRotation = (finalRotation * Math.PI) / 180; // Final position in radians
                        }
                    };
                    
                    animate();
                }, delay);
            }

            createConfetti() {
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.left = Math.random() * window.innerWidth + 'px';
                        confetti.style.top = '-10px';
                        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                        
                        document.body.appendChild(confetti);
                        
                        // Animate confetti falling
                        let pos = -10;
                        const fall = setInterval(() => {
                            pos += 5;
                            confetti.style.top = pos + 'px';
                            confetti.style.transform += ` translateX(${Math.sin(pos * 0.01) * 100}px)`;
                            
                            if (pos > window.innerHeight) {
                                clearInterval(fall);
                                confetti.remove();
                            }
                        }, 50);
                    }, i * 100);
                }
            }
        }

        // Initialize the OBS wheel widget
        const obsWidget = new OBSWheelWidget();
    </script>
</body>
</html>