<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giveaway Wheel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'spin-slow': 'spin 3s linear infinite',
                        'spin-fast': 'spin 0.5s linear infinite',
                        'bounce-gentle': 'bounce 2s infinite',
                        'pulse-slow': 'pulse 3s infinite',
                        'wheel-spin': 'wheel-spin 4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards',
                    },
                    keyframes: {
                        'wheel-spin': {
                            '0%': { transform: 'rotate(0deg)' },
                            '100%': { transform: 'rotate(1800deg)' }
                        }
                    },
                    colors: {
                        'wheel-primary': '#667eea',
                        'wheel-secondary': '#764ba2',
                    }
                }
            }
        }
    </script>
    <style>
        /* Modern wheel styles with material design */
        #wheel-canvas {
            border: none;
            border-radius: 50%;
            background: transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 8px 32px rgba(0, 0, 0, 0.15));
        }
        
        #wheel-canvas:hover {
            filter: drop-shadow(0 12px 40px rgba(0, 0, 0, 0.2));
            transform: scale(1.02);
        }
        
        .wheel-container {
            position: relative;
            display: inline-block;
        }
        
        .wheel-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(103, 126, 234, 0.1) 0%, transparent 70%);
            animation: pulse 3s ease-in-out infinite;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        .spinning {
            animation: none !important;
        }
        
        .winner-announcement {
            animation: winnerPop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes winnerPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Legacy pointer and center (hidden since we draw them on canvas now) */
        .wheel-pointer {
            display: none;
        }

        .wheel-center {
            display: none;
        }

        /* Minimal custom styles for elements that can't be easily replicated with Tailwind */

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f94144;
            z-index: 1000;
            pointer-events: none;
        }

        /* OBS Mode Styles */
        .obs-mode {
            background: transparent !important;
            padding: 0 !important;
        }

        .obs-mode .container {
            background: transparent;
            box-shadow: none;
        }

        .obs-mode h1 {
            display: none;
        }

        .obs-mode .controls {
            display: none;
        }

        .obs-mode .entrants-list {
            display: none;
        }

        @media (max-width: 768px) {
            .wheel-container {
                width: 300px;
                height: 300px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            input[type="text"] {
                min-width: 250px;
            }
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-wheel-primary via-purple-600 to-wheel-secondary flex flex-col items-center justify-center text-white font-sans">
    <div class="text-center max-w-4xl w-full px-6 py-8">
        <h1 class="text-5xl md:text-6xl font-bold mb-8 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-pink-500 to-purple-600 drop-shadow-lg animate-pulse-slow">
            üéØ Giveaway Wheel
        </h1>
        
        <div class="wheel-container relative w-96 h-96 md:w-[400px] md:h-[400px] mx-auto my-8 flex items-center justify-center group">
            <div class="wheel-glow"></div>
            <canvas id="wheel-canvas" class="rounded-full transition-transform duration-100 ease-out" width="400" height="400"></canvas>
        </div>

        <div class="hidden bg-gradient-to-r from-yellow-400 via-yellow-500 to-amber-500 text-gray-900 p-6 rounded-2xl my-6 text-2xl font-bold shadow-2xl border-4 border-yellow-300 animate-bounce-gentle" id="winner-display"></div>

        <div class="space-y-6 mt-8">
            <div class="bg-white/10 backdrop-blur-md p-6 rounded-2xl border border-white/20 shadow-xl">
                <h3 class="text-2xl font-bold mb-4 text-center">üîë Entry Keyword</h3>
                <div class="text-2xl text-yellow-400 font-bold text-center my-4">
                    Current Keyword: <span class="bg-yellow-400 text-gray-900 px-3 py-1 rounded-lg" id="current-keyword">ENTER</span>
                </div>
                <div class="text-sm text-gray-300 text-center mb-4">
                    Viewers type this keyword in chat to enter the giveaway
                </div>
                <div class="flex flex-col sm:flex-row gap-3 items-center justify-center mb-4">
                    <input type="text" id="keyword-input" placeholder="Enter new keyword..." 
                           class="px-4 py-3 rounded-lg border-2 border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 text-gray-900 font-medium min-w-0 flex-1">
                    <button onclick="setKeyword()" 
                            class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                        Set Keyword
                    </button>
                </div>
                <button onclick="openOBSWidget()" 
                        class="w-full px-6 py-3 bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    üì∫ Open OBS Widget
                </button>
            </div>

            <div class="flex flex-col sm:flex-row gap-3 items-center justify-center">
                <input type="text" id="entrant-name" placeholder="Enter participant name" 
                       class="px-4 py-3 rounded-lg border-2 border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 text-gray-900 font-medium min-w-0 flex-1">
                <select id="platform-select" 
                        class="px-4 py-3 rounded-lg border-2 border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 text-gray-900 font-medium">
                    <option value="twitch">Twitch</option>
                    <option value="youtube">YouTube</option>
                    <option value="facebook">Facebook</option>
                    <option value="instagram">Instagram</option>
                    <option value="tiktok">TikTok</option>
                    <option value="discord">Discord</option>
                    <option value="kick">Kick</option>
                </select>
                <button onclick="addEntrant()" 
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    Add Participant
                </button>
            </div>
            
            <div class="flex flex-wrap gap-3 items-center justify-center">
                <button onclick="spinWheel()" id="spin-btn" 
                        class="px-8 py-4 bg-gradient-to-r from-red-500 via-pink-500 to-red-600 hover:from-red-600 hover:via-pink-600 hover:to-red-700 text-white font-bold rounded-xl transition-all duration-200 transform hover:scale-110 hover:shadow-2xl text-lg motion-safe:hover:animate-pulse">
                    üéØ Spin the Wheel!
                </button>
                <button onclick="clearEntrants()" 
                        class="px-6 py-3 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    Clear All
                </button>
                <button onclick="addTestData()" 
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    Add Test Data
                </button>
                <button onclick="clearAllEntries()" 
                        class="px-6 py-3 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    üóëÔ∏è Clear All Entries
                </button>
            </div>
        </div>

        <div class="bg-white/10 backdrop-blur-md p-6 rounded-2xl border border-white/20 shadow-xl mt-8">
            <h3 class="text-2xl font-bold mb-4 text-center">
                Participants (<span class="text-yellow-400" id="entrant-count">0</span>)
            </h3>
            <div id="entrants-container" class="space-y-2 max-h-64 overflow-y-auto scrollbar-thin scrollbar-thumb-white/20 scrollbar-track-transparent"></div>
        </div>
    </div>

    <script>
        // üêõ DEBUGGING VARIABLES
        let messageCount = 0;
        let debugStartTime = new Date();
        
        console.log('üéØ GIVEAWAY PAGE LOADED');
        console.log('‚è∞ Load time:', debugStartTime.toISOString());
        console.log('üåê Page URL:', window.location.href);
        console.log('üì± User Agent:', navigator.userAgent);
        console.log('üîß Console debugging enabled');
        
        // Global state
        let entrants = {};
        let isSpinning = false;
        let isOBSMode = false;
        let currentKeyword = 'ENTER';
        let currentRotation = 0; // Track wheel rotation in radians (same as OBS widget)
        
        // Social Stream WebRTC integration
        let iframe = null;
        let roomID = "test";
        let password = "false";
        
        // Get session ID and password from URL parameters
        console.log('üîç PARSING URL PARAMETERS...');
        const urlParams = new URLSearchParams(window.location.search);
        console.log('üìã All URL params:', Array.from(urlParams.entries()));
        
        if (urlParams.has("session")) {
            roomID = urlParams.get("session");
            console.log('‚úÖ Found session parameter:', roomID);
        } else if (urlParams.has("s")) {
            roomID = urlParams.get("s");
            console.log('‚úÖ Found s parameter:', roomID);
        } else if (urlParams.has("id")) {
            roomID = urlParams.get("id");
            console.log('‚úÖ Found id parameter:', roomID);
        } else {
            console.log('‚ùå No session parameter found! Using default:', roomID);
            console.log('üí° Add ?session=YOUR_SESSION_ID to the URL to connect');
        }
        
        if (urlParams.has("password")) {
            password = urlParams.get("password") || "false";
            console.log('üîë Found password parameter:', password);
        } else {
            console.log('üîì No password parameter found, using default:', password);
        }
        
        console.log('üéØ Final connection parameters:');
        console.log('  üìã Room ID:', roomID);
        console.log('  üîë Password:', password);

        // Platform icon cache
        let platformIconCache = {};
        
        // WebRTC iframe setup for Social Stream integration
        function setupWebRTCConnection() {
            console.log('üöÄ Setting up WebRTC connection for giveaway...');
            console.log('üìã Session ID:', roomID);
            console.log('üîë Password:', password);
            
            // Always set up local communication channel first
            setupLocalCommunication();
            
            if (!roomID || roomID === "test") {
                console.log("‚ö†Ô∏è Using test session - WebRTC will use local communication only");
                return;
            }
            
            console.log('üîßüîßüîß CREATING WEBRTC IFRAME üîßüîßüîß');
            console.log('üìã Session ID (roomID):', roomID);
            console.log('üîê Password:', password);
            
            // Create hidden iframe for WebRTC connection (same pattern as dock.html)
            iframe = document.createElement('iframe');
            iframe.style.width = "0px";
            iframe.style.height = "0px";
            iframe.style.position = "fixed";
            iframe.style.left = "-100px";
            iframe.style.top = "-100px";
            iframe.id = "frame1";
            iframe.allow = "midi;geolocation;microphone;"; // microphone needed for Safari WebRTC P2P connections
            
            console.log('üñºÔ∏è Iframe element created with ID:', iframe.id);
            
            // Connect as a view-only client to receive chat messages (same as sampleoverlay.html pattern)
            iframe.src = "https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password="+password+"&push&label=dock&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput&room="+roomID;
            
            console.log('üîóüîóüîó IFRAME CONNECTION URL üîóüîóüîó');
            console.log('üìç Full URL:', iframe.src);
            console.log('üè† Base URL: https://vdo.socialstream.ninja/');
            console.log('üéØ Room parameter: room=' + roomID);
            console.log('üîê Password parameter: password=' + password);
            console.log('üè∑Ô∏è Label parameter: label=giveaway');
            console.log('‚öôÔ∏è Other parameters: ln&salt=vdo.ninja&push&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput');
            
            document.body.appendChild(iframe);
            console.log('‚úÖ Iframe added to document body');
            
            // Add iframe load event listener
            iframe.onload = function() {
                console.log('üéâ IFRAME LOADED SUCCESSFULLY!');
                console.log('üìç Iframe contentWindow:', iframe.contentWindow);
            };
            
            iframe.onerror = function(error) {
                console.log('‚ùå IFRAME LOAD ERROR:', error);
            };
            
            // Set up message listener for WebRTC data (same simple pattern as sampleoverlay.html)
            window.addEventListener("message", function (e) {
                console.log('üî•üî•üî• RAW MESSAGE RECEIVED FROM IFRAME üî•üî•üî•');
                console.log('üì® Full event object:', e);
                console.log('üì¶ Event data:', e.data);
                console.log('üåê Event origin:', e.origin);
                console.log('üìç Event source:', e.source);
                console.log('üñºÔ∏è Iframe source check:', e.source === iframe.contentWindow);
                console.log('‚è∞ Timestamp:', new Date().toISOString());
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                
                if (e.source != iframe.contentWindow) {
                    console.log('‚ùå REJECTED: Message not from our iframe');
                    return;
                } // reject messages send from other iframes
                
                console.log('‚úÖ MESSAGE SOURCE VERIFIED - Processing...');
                
                if (e.data.dataReceived && e.data.dataReceived.overlayNinja) {
                    console.log('üéâ FOUND CHAT MESSAGE via WebRTC! (sampleoverlay pattern)');
                    console.log('üí¨ Chat data:', e.data.dataReceived.overlayNinja);
                    processGiveawayMessage(e.data.dataReceived.overlayNinja);
                } else {
                    console.log('‚ùì UNKNOWN MESSAGE FORMAT - NOT PROCESSING');
                    console.log('üîç Data type:', typeof e.data);
                    console.log('üîç Data keys:', e.data ? Object.keys(e.data) : 'No data object');
                    console.log('üîç Raw data:', JSON.stringify(e.data, null, 2));
                }
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
            });
            
            console.log(`üéØ Giveaway connected to Social Stream WebRTC with session: ${roomID}`);
        }

        // Local communication setup for when WebRTC session is not available
        function setupLocalCommunication() {
            // Use BroadcastChannel API for local communication between tabs
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('giveaway_' + roomID);
                
                channel.addEventListener('message', function(event) {
                    console.log('üì• Received local broadcast:', event.data);
                    handleLocalMessage(event.data);
                });
                
                // Store channel for broadcasting
                window.giveawayChannel = channel;
                console.log('üì° Local communication channel established');
            } else {
                // Fallback to localStorage for older browsers
                console.log('üì° Using localStorage fallback for local communication');
                window.addEventListener('storage', function(e) {
                    if (e.key === 'giveaway_broadcast_' + roomID) {
                        try {
                            const data = JSON.parse(e.newValue);
                            handleLocalMessage(data);
                        } catch (error) {
                            console.error('Error processing localStorage message:', error);
                        }
                    }
                });
            }
        }

        // Handle messages from local communication
        function handleLocalMessage(data) {
            if (data.action === 'giveaway_update') {
                handleGiveawayUpdate(data.data);
            } else if (data.action === 'keyword_update') {
                handleKeywordUpdate(data.keyword);
            } else if (data.action === 'spin_update') {
                handleSpinUpdate(data.data);
            } else if (data.action === 'winner_update') {
                handleWinnerUpdate(data.data);
            }
        }
        
        // WebSocket fallback implementation (same pattern as dock.html)
        var conCon = 1;
        var socketserver = false;
        var serverURL = urlParams.has("localserver") ? "ws://127.0.0.1:3000" : "wss://io.socialstream.ninja/api";
        var reconnectionTimeout = null;
        
        function setupSocket() {
            // Clear any existing reconnection timeout
            if (reconnectionTimeout) {
                clearTimeout(reconnectionTimeout);
                reconnectionTimeout = null;
            }

            if (socketserver) {
                socketserver.onclose = null;
                socketserver.close();
                socketserver = null;
            }
            socketserver = new WebSocket(serverURL);

            socketserver.onclose = function () {
                reconnectionTimeout = setTimeout(function () {
                    conCon += 1;
                    setupSocket();
                }, 100 * conCon);
            };
            socketserver.onopen = function () {
                conCon = 1;
                // Use channel 5 for giveaway communication (out: 5, in: 6)
                socketserver.send(JSON.stringify({ join: roomID.split(",")[0], out: 5, in: 6 }));
                console.log("Giveaway WebSocket: output channel: 5, input channel: 6");
            };

            socketserver.onerror = function (error) {
                console.error("WebSocket error:", error);
                socketserver.close();
            };

            socketserver.addEventListener("message", function (event) {
                if (event.data) {
                    try {
                        var data = JSON.parse(event.data);
                        // Handle giveaway-specific messages
                        if (data.action === 'giveaway_update') {
                            handleGiveawayUpdate(data.data);
                        } else if (data.action === 'keyword_update') {
                            handleKeywordUpdate(data.keyword);
                        } else if (data.action === 'spin_update') {
                            handleSpinUpdate(data.data);
                        } else if (data.action === 'winner_update') {
                            handleWinnerUpdate(data.data);
                        } else if (data.chatname || data.chatmessage) {
                            processGiveawayMessage(data);
                        }
                    } catch (e) {
                        console.error("Error processing WebSocket message:", e);
                    }
                }
            });
        }
        
        // Enable WebSocket if server parameter is provided
        if (urlParams.has("server")) {
            serverURL = urlParams.get("server") || serverURL;
            setupSocket();
        }
        
        // WebSocket fallback debugging function
        function testWebSocketConnection() {
            console.log('üîÑ TESTING WEBSOCKET FALLBACK...');
            const wsUrl = `wss://api.socialstream.ninja/ws?session=${roomID}&password=${password}`;
            console.log('üîó WebSocket URL:', wsUrl);
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('‚úÖ WebSocket connection opened successfully!');
                    console.log('üì° This means the session ID is valid');
                };
                
                ws.onmessage = function(event) {
                    console.log('üì® WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üìä Parsed WebSocket data:', data);
                        if (data.chatname && data.chatmessage) {
                            console.log('üéØ FOUND CHAT DATA VIA WEBSOCKET:');
                            console.log('  - chatname:', data.chatname);
                            console.log('  - chatmessage:', data.chatmessage);
                        }
                    } catch (e) {
                        console.log('‚ùå Failed to parse WebSocket data:', e);
                    }
                };
                
                ws.onerror = function(error) {
                    console.log('‚ùå WebSocket error:', error);
                };
                
                ws.onclose = function(event) {
                    console.log('üîå WebSocket closed:', event.code, event.reason);
                };
                
                // Close after 30 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        console.log('üîå Closing WebSocket test connection');
                        ws.close();
                    }
                }, 30000);
                
            } catch (error) {
                console.log('‚ùå Failed to create WebSocket:', error);
            }
        }
        
        // Add WebSocket test button to page for manual testing
        function addWebSocketTestButton() {
            const button = document.createElement('button');
            button.textContent = 'üîÑ Test WebSocket';
            button.style.position = 'fixed';
            button.style.top = '10px';
            button.style.left = '10px';
            button.style.zIndex = '9999';
            button.style.padding = '10px';
            button.style.backgroundColor = '#2196F3';
            button.style.color = 'white';
            button.style.border = 'none';
            button.style.borderRadius = '5px';
            button.style.cursor = 'pointer';
            button.onclick = testWebSocketConnection;
            document.body.appendChild(button);
            console.log('üîò Added WebSocket test button to page');
        }
        
        // Process incoming chat messages for giveaway entries
        function processGiveawayMessage(data) {
            console.log("üöÄüöÄüöÄ PROCESS GIVEAWAY MESSAGE CALLED üöÄüöÄüöÄ");
            console.log("‚è∞ Timestamp:", new Date().toISOString());
            console.log("üì¶ Input data:", data);
            console.log("üîç RAW DATA TYPE:", typeof data);
            console.log("üîç RAW DATA STRUCTURE:", JSON.stringify(data, null, 2));
            
            // Comprehensive data analysis
            console.log("üîç DETAILED DATA BREAKDOWN:");
            console.log("  - chatname:", data.chatname || "‚ùå NOT FOUND");
            console.log("  - chatmessage:", data.chatmessage || "‚ùå NOT FOUND");
            console.log("  - type:", data.type || "‚ùå NOT FOUND");
            console.log("  - All data keys:", Object.keys(data));
            console.log("  - Data length:", Object.keys(data).length);
            
            // Check for nested structures
            if (data.data) {
                console.log("üîç NESTED DATA FOUND:");
                console.log("  - data.data:", data.data);
                console.log("  - data.data keys:", Object.keys(data.data || {}));
            }
            
            // Check for alternative field names
            console.log("üîç ALTERNATIVE FIELD CHECK:");
            console.log("  - username:", data.username || "‚ùå NOT FOUND");
            console.log("  - user:", data.user || "‚ùå NOT FOUND");
            console.log("  - name:", data.name || "‚ùå NOT FOUND");
            console.log("  - message:", data.message || "‚ùå NOT FOUND");
            console.log("  - text:", data.text || "‚ùå NOT FOUND");
            console.log("  - content:", data.content || "‚ùå NOT FOUND");
            
            // Show a visual indicator that a message was received
            const indicator = document.createElement('div');
            indicator.textContent = 'üì® Message received';
            indicator.style.position = 'fixed';
            indicator.style.top = '10px';
            indicator.style.right = '10px';
            indicator.style.backgroundColor = '#4CAF50';
            indicator.style.color = 'white';
            indicator.style.padding = '10px';
            indicator.style.borderRadius = '5px';
            indicator.style.zIndex = '9999';
            document.body.appendChild(indicator);
            
            // Remove the indicator after 2 seconds
            setTimeout(() => {
                indicator.style.opacity = '0';
                indicator.style.transition = 'opacity 0.5s';
                setTimeout(() => indicator.remove(), 500);
            }, 2000);
            
            // Use same validation logic as sampleoverlay.html - more permissive
            if (!data.chatname && !data.chatmessage && !data.hasDonation && !data.donation && !data.contentimg) {
                console.log("No valid message data found:", data);
                return;
            }
            
            // Show warning if missing expected fields but continue processing
            if (!data.chatname || !data.chatmessage) {
                console.log("‚ö†Ô∏è Warning - missing some fields:", {
                    chatname: data.chatname,
                    chatmessage: data.chatmessage,
                    type: data.type
                });
                
                // Show warning indicator but don't return
                const warningIndicator = document.createElement('div');
                warningIndicator.textContent = '‚ö†Ô∏è Partial data: ' + 
                    (!data.chatname ? 'no chatname ' : '') + 
                    (!data.chatmessage ? 'no chatmessage ' : '');
                warningIndicator.style.position = 'fixed';
                warningIndicator.style.top = '60px';
                warningIndicator.style.right = '10px';
                warningIndicator.style.backgroundColor = '#FF9800';
                warningIndicator.style.color = 'white';
                warningIndicator.style.padding = '10px';
                warningIndicator.style.borderRadius = '5px';
                warningIndicator.style.zIndex = '9999';
                document.body.appendChild(warningIndicator);
                
                // Remove the warning indicator after 2 seconds
                setTimeout(() => {
                    warningIndicator.style.opacity = '0';
                    warningIndicator.style.transition = 'opacity 0.5s';
                    setTimeout(() => warningIndicator.remove(), 500);
                }, 2000);
            }
            
            // Handle missing chatname or chatmessage gracefully
            const chatname = data.chatname || 'Unknown User';
            const chatmessage = data.chatmessage || '';
            const platform = data.type || 'unknown';
            
            console.log(`Processing message from ${chatname} (${platform}): "${chatmessage}"`);
            
            // Only check keyword if we have a message
            if (chatmessage) {
                // Check if message contains the current keyword
                const message = chatmessage.toLowerCase().trim();
                const keyword = currentKeyword.toLowerCase();
                
                console.log(`Checking if "${message}" contains keyword "${keyword}"`);
                
                if (message.includes(keyword)) {
                    console.log("Keyword match found!");
                    
                    // Add user to giveaway
                    const entrantId = `${chatname}_${platform}`;
                    
                    // Prevent duplicate entries
                    if (!entrants[entrantId]) {
                        entrants[entrantId] = {
                            name: chatname,
                            platform: platform,
                            timestamp: Date.now(),
                            originalMessage: chatmessage
                        };
                    
                    console.log(`‚úÖ New giveaway entry added: ${chatname} from ${platform}`);
                    updateDisplay();
                    saveState();
                    
                    // Show success indicator
                    const successIndicator = document.createElement('div');
                    successIndicator.textContent = '‚úÖ Added entry: ' + chatname;
                    successIndicator.style.position = 'fixed';
                    successIndicator.style.top = '160px';
                    successIndicator.style.right = '10px';
                    successIndicator.style.backgroundColor = '#2196F3';
                    successIndicator.style.color = 'white';
                    successIndicator.style.padding = '10px';
                    successIndicator.style.borderRadius = '5px';
                    successIndicator.style.zIndex = '9999';
                    document.body.appendChild(successIndicator);
                    
                    // Remove the success indicator after 3 seconds
                    setTimeout(() => {
                        successIndicator.style.opacity = '0';
                        successIndicator.style.transition = 'opacity 0.5s';
                        setTimeout(() => successIndicator.remove(), 500);
                    }, 3000);
                } else {
                    console.log(`‚ùå Duplicate entry prevented: ${data.chatname} from ${data.type}`);
                    
                    // Show duplicate entry indicator
                    const dupIndicator = document.createElement('div');
                    dupIndicator.textContent = 'üîÑ Duplicate entry: ' + data.chatname;
                    dupIndicator.style.position = 'fixed';
                    dupIndicator.style.top = '110px';
                    dupIndicator.style.right = '10px';
                    dupIndicator.style.backgroundColor = '#FF9800';
                    dupIndicator.style.color = 'white';
                    dupIndicator.style.padding = '10px';
                    dupIndicator.style.borderRadius = '5px';
                    dupIndicator.style.zIndex = '9999';
                    document.body.appendChild(dupIndicator);
                    
                    // Remove the duplicate indicator after 2 seconds
                    setTimeout(() => {
                        dupIndicator.style.opacity = '0';
                        dupIndicator.style.transition = 'opacity 0.5s';
                        setTimeout(() => dupIndicator.remove(), 500);
                    }, 2000);
                }
            } else {
                console.log(`‚ùå No keyword match: "${message}" does not contain "${keyword}"`);
            }
        } else {
            console.log("No message content to check for keyword");
        }
    }

        // Check for OBS mode
        if (urlParams.get('obs') === 'true') {
            isOBSMode = true;
            document.body.classList.add('obs-mode');
        }

        // Platform colors
        function getPlatformColor(platform, index) {
            const platformColors = {
                'twitch': '#9146ff',
                'youtube': '#ff0000',
                'facebook': '#1877f2',
                'instagram': '#e4405f',
                'tiktok': '#000000',
                'discord': '#5865f2',
                'kick': '#53fc18'
            };
            return platformColors[platform?.toLowerCase()] || `hsl(${index * 137.5 % 360}, 70%, 60%)`;
        }

        // Preload platform icons
        function preloadPlatformIcons(entrants, callback) {
            const entrantsList = Object.values(entrants);
            const uniquePlatforms = [...new Set(entrantsList.map(e => e.platform).filter(p => p))];
            let loadedCount = 0;
            const totalCount = uniquePlatforms.length;
            
            if (totalCount === 0) {
                callback();
                return;
            }
            
            uniquePlatforms.forEach(platform => {
                if (platformIconCache[platform]) {
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    platformIconCache[platform] = img;
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                };
                img.onerror = function() {
                    platformIconCache[platform] = null;
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                };
                img.src = `./sources/images/${platform.toLowerCase()}.png`;
            });
        }

        // Draw wheel function
        function drawWheel(canvas, entrants) {
            if (!canvas || !entrants) {
                return;
            }
            
            // Ensure canvas size matches its container
            const container = canvas.parentElement;
            if (container) {
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width > 0 && containerRect.height > 0) {
                    canvas.width = Math.min(containerRect.width, containerRect.height);
                    canvas.height = canvas.width;
                }
            }
            
            // Preload platform icons first, then draw
            preloadPlatformIcons(entrants, function() {
                drawWheelWithIcons(canvas, entrants);
            });
        }

        function drawWheelWithIcons(canvas, entrants) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 20;
            
            const entrantsList = Object.values(entrants);
            const segmentAngle = (2 * Math.PI) / entrantsList.length;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw outer shadow for depth
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.restore();
            
            if (entrantsList.length === 0) {
                // Draw modern empty wheel
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                
                // Modern gradient background
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, '#f8f9fa');
                gradient.addColorStop(1, '#e9ecef');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Modern border
                ctx.strokeStyle = '#dee2e6';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Modern typography
                ctx.fillStyle = '#6c757d';
                ctx.font = '600 24px "Segoe UI", system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Add participants to spin!', centerX, centerY);
                return;
            }
            
            // Apply current rotation to wheel content (same as OBS widget)
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentRotation);
            ctx.translate(-centerX, -centerY);
            
            // Draw wheel segments with modern material design
            entrantsList.forEach((entrant, index) => {
                const startAngle = index * segmentAngle;
                const endAngle = (index + 1) * segmentAngle;
                
                // Get modern platform-specific color
                const segmentColor = getModernPlatformColor(entrant.platform, index);
                
                // Draw segment with gradient
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                
                // Create radial gradient for depth
                const midAngle = startAngle + segmentAngle / 2;
                const gradientX = centerX + Math.cos(midAngle) * radius * 0.3;
                const gradientY = centerY + Math.sin(midAngle) * radius * 0.3;
                const gradient = ctx.createRadialGradient(gradientX, gradientY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, segmentColor.light);
                gradient.addColorStop(0.7, segmentColor.main);
                gradient.addColorStop(1, segmentColor.dark);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Modern border with subtle shadow
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add inner shadow for depth
                ctx.save();
                ctx.clip();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius - 2, startAngle, endAngle);
                ctx.closePath();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
                
                // Draw modern text and platform badge
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);
                
                // Position elements with modern spacing
                const textRadius = radius - 60; // More space for modern design
                const textX = textRadius;
                const maxTextWidth = radius * 0.5;
                
                // Modern typography with better contrast
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#ffffff';
                ctx.font = '600 20px "Segoe UI", system-ui, -apple-system, sans-serif';
                
                // Modern text shadow for depth
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
                
                const userName = entrant.name || 'Anonymous';
                
                // Smart text truncation
                let displayText = userName;
                if (ctx.measureText(displayText).width > maxTextWidth) {
                    while (ctx.measureText(displayText + '...').width > maxTextWidth && displayText.length > 1) {
                        displayText = displayText.slice(0, -1);
                    }
                    displayText += '...';
                }
                
                // Draw username with modern styling
                ctx.fillText(displayText, textX, -15);
                
                // Draw modern platform icon
                if (entrant.platform) {
                    const platformIcon = platformIconCache[entrant.platform];
                    
                    if (platformIcon) {
                        // Modern icon design with material elevation
                        const iconSize = 28;
                        const iconX = textX - iconSize/2;
                        const iconY = 10;
                        
                        // Draw modern icon background with elevation
                        ctx.save();
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 8;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 4;
                        
                        ctx.beginPath();
                        ctx.arc(textX, iconY + iconSize/2, iconSize/2 + 6, 0, 2 * Math.PI);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                        ctx.restore();
                        
                        // Draw subtle border
                        ctx.beginPath();
                        ctx.arc(textX, iconY + iconSize/2, iconSize/2 + 6, 0, 2 * Math.PI);
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Draw platform icon
                        ctx.drawImage(platformIcon, iconX, iconY, iconSize, iconSize);
                    } else {
                        // Modern text badge design
                        const platformText = entrant.platform.substring(0, 3).toUpperCase();
                        ctx.font = '600 12px "Segoe UI", system-ui, sans-serif';
                        
                        // Modern badge with material design
                        const badgeWidth = 40;
                        const badgeHeight = 24;
                        const badgeX = textX - badgeWidth/2;
                        const badgeY = 8;
                        
                        // Badge shadow
                        ctx.save();
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 3;
                        
                        // Badge background with rounded corners effect
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(badgeX, badgeY, badgeWidth, badgeHeight);
                        ctx.restore();
                        
                        // Badge border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(badgeX, badgeY, badgeWidth, badgeHeight);
                        
                        // Badge text
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(platformText, textX, badgeY + badgeHeight/2);
                    }
                }
                
                ctx.restore();
            });
            
            // Restore canvas context after wheel rotation
            ctx.restore();
            
            // Draw modern center hub (not rotated)
            drawModernCenterHub(ctx, centerX, centerY);
            
            // Draw modern pointer (not rotated)
            drawModernPointer(ctx, centerX, centerY, radius);
        }

        // Modern color palette function
        function getModernPlatformColor(platform, index) {
            const modernColors = {
                'twitch': { main: '#9146ff', light: '#b794ff', dark: '#6b2db8' },
                'youtube': { main: '#ff0000', light: '#ff4444', dark: '#cc0000' },
                'discord': { main: '#5865f2', light: '#7983f5', dark: '#4752c4' },
                'facebook': { main: '#1877f2', light: '#4b9cff', dark: '#0d5dbf' },
                'instagram': { main: '#e4405f', light: '#ff6b8a', dark: '#c13584' },
                'tiktok': { main: '#000000', light: '#333333', dark: '#000000' },
                'kick': { main: '#53fc18', light: '#7dff4d', dark: '#3eb813' },
                'default': [
                    { main: '#667eea', light: '#8fa5ff', dark: '#4c63d2' },
                    { main: '#764ba2', light: '#9d7bc7', dark: '#5a3780' },
                    { main: '#f093fb', light: '#ffb3ff', dark: '#e066f0' },
                    { main: '#4facfe', light: '#7cc8ff', dark: '#2196f3' },
                    { main: '#43e97b', light: '#6eff9f', dark: '#00e676' },
                    { main: '#fa709a', light: '#ff9dc6', dark: '#f06292' },
                    { main: '#fee140', light: '#ffeb70', dark: '#fbc02d' },
                    { main: '#a8edea', light: '#c8f7f5', dark: '#80cbc4' }
                ]
            };
            
            if (platform && modernColors[platform.toLowerCase()]) {
                return modernColors[platform.toLowerCase()];
            }
            
            return modernColors.default[index % modernColors.default.length];
        }

        // Draw modern center hub with material design
        function drawModernCenterHub(ctx, centerX, centerY) {
            const hubRadius = 25;
            
            // Hub shadow
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 6;
            
            // Hub gradient
            const hubGradient = ctx.createRadialGradient(centerX, centerY - 5, 0, centerX, centerY, hubRadius);
            hubGradient.addColorStop(0, '#ffffff');
            hubGradient.addColorStop(0.7, '#f8f9fa');
            hubGradient.addColorStop(1, '#e9ecef');
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, hubRadius, 0, 2 * Math.PI);
            ctx.fillStyle = hubGradient;
            ctx.fill();
            ctx.restore();
            
            // Hub border
            ctx.beginPath();
            ctx.arc(centerX, centerY, hubRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Inner hub detail
             ctx.beginPath();
             ctx.arc(centerX, centerY, hubRadius - 8, 0, 2 * Math.PI);
             ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
             ctx.lineWidth = 1;
             ctx.stroke();
         }

         // Draw modern pointer with material design
         function drawModernPointer(ctx, centerX, centerY, radius) {
             const pointerLength = 40;
             const pointerWidth = 20;
             
             // Pointer shadow
             ctx.save();
             ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
             ctx.shadowBlur = 12;
             ctx.shadowOffsetX = 2;
             ctx.shadowOffsetY = 6;
             
             // Draw pointer triangle
             ctx.beginPath();
             ctx.moveTo(centerX + radius - 5, centerY); // Point at edge
             ctx.lineTo(centerX + radius - pointerLength, centerY - pointerWidth/2); // Top
             ctx.lineTo(centerX + radius - pointerLength, centerY + pointerWidth/2); // Bottom
             ctx.closePath();
             
             // Pointer gradient
             const pointerGradient = ctx.createLinearGradient(
                 centerX + radius - pointerLength, centerY - pointerWidth/2,
                 centerX + radius - 5, centerY
             );
             pointerGradient.addColorStop(0, '#ff6b6b');
             pointerGradient.addColorStop(0.5, '#ff5252');
             pointerGradient.addColorStop(1, '#f44336');
             
             ctx.fillStyle = pointerGradient;
             ctx.fill();
             ctx.restore();
             
             // Pointer border
             ctx.beginPath();
             ctx.moveTo(centerX + radius - 5, centerY);
             ctx.lineTo(centerX + radius - pointerLength, centerY - pointerWidth/2);
             ctx.lineTo(centerX + radius - pointerLength, centerY + pointerWidth/2);
             ctx.closePath();
             ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
             ctx.lineWidth = 2;
             ctx.stroke();
             
             // Pointer highlight
             ctx.beginPath();
             ctx.moveTo(centerX + radius - 5, centerY);
             ctx.lineTo(centerX + radius - pointerLength, centerY - pointerWidth/2);
             ctx.lineTo(centerX + radius - pointerLength + 8, centerY);
             ctx.closePath();
             ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
             ctx.fill();
         }

        // Spin wheel function
        function spinWheel() {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsList = Object.values(entrants);
            
            if (isSpinning) return;
            if (entrantsList.length === 0) {
                alert('Please add some participants first!');
                return;
            }
            
            isSpinning = true;
            const spinBtn = document.getElementById('spin-btn');
            const winnerDisplay = document.getElementById('winner-display');
            
            // Add spinning class to disable hover effects
            canvas.classList.add('spinning');
            
            // Add loading state to button
            spinBtn.disabled = true;
            spinBtn.innerHTML = `
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Spinning...
            `;
            spinBtn.classList.add('opacity-75', 'cursor-not-allowed');
            
            // Hide winner display
            winnerDisplay.classList.add('hidden');
            winnerDisplay.classList.remove('block');
            
            const segmentAngle = 360 / entrantsList.length;
            const winnerIndex = Math.floor(Math.random() * entrantsList.length);
            
            // Calculate target angle to align winner segment with pointer (at 0 degrees / 3 o'clock position)
            // The pointer is at 0 degrees, so we need to rotate the wheel so the winner segment center aligns with it
            const winnerSegmentCenter = (winnerIndex * segmentAngle) + (segmentAngle / 2);
            // We want the winner segment center to be at 0 degrees (where the pointer is)
            // So we need to rotate by negative of the winner segment center angle
            const targetAngle = 360 - winnerSegmentCenter;
            const totalRotation = 360 * 5 + targetAngle; // 5 full rotations plus target
            
            // Convert to radians for OBS widget
            const targetRotationRadians = (totalRotation * Math.PI) / 180;
            
            // Reset both wheels to 0 rotation before spinning
            currentRotation = 0;
            drawWheel(canvas, entrants); // Redraw wheel at 0 rotation
            
            // Broadcast spin state to OBS widget via WebRTC
            const spinState = {
                isSpinning: true,
                targetRotation: targetRotationRadians,
                targetRotationDegrees: totalRotation, // Also send degrees for consistency
                duration: 4000,
                winnerIndex: winnerIndex,
                startTime: Date.now() + 200, // Start 200ms in future for sync
                initialRotation: 0, // Both wheels start from 0
                timestamp: Date.now()
            };
            broadcastSpinState(spinState);
            
            // Reset global currentRotation to 0 (don't redeclare)
            currentRotation = 0;
            const duration = 4000; // 4 seconds
            const syncStartTime = spinState.startTime; // Use synchronized start time
            
            // Wait until sync start time to ensure both wheels start together
            const delay = Math.max(0, syncStartTime - Date.now());
            setTimeout(() => {
                function animate() {
                    const elapsed = Date.now() - syncStartTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function for smooth deceleration (identical to OBS widget)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    const rotationDegrees = totalRotation * easeOut;
                    currentRotation = (rotationDegrees * Math.PI) / 180; // Convert to radians
                    
                    // Redraw wheel with new rotation
                    drawWheel(canvas, entrants);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Animation complete, show winner
                        const winner = entrantsList[winnerIndex];
                        showWinner(winner);
                        isSpinning = false;
                        
                        // Restore button state
                        const spinBtn = document.getElementById('spin-btn');
                        const canvas = document.getElementById('wheel-canvas');
                        spinBtn.disabled = false;
                        spinBtn.innerHTML = 'üéØ Spin the Wheel!';
                        spinBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                        canvas.classList.remove('spinning');
                        
                        // Clear spin state via WebRTC
                        broadcastSpinState({ isSpinning: false, timestamp: Date.now() });
                    }
                }
                
                requestAnimationFrame(animate);
            }, delay);
        }

        // Show winner
        function showWinner(winner) {
            const winnerDisplay = document.getElementById('winner-display');
            const platformBadge = winner.platform ? 
                `<span class="inline-block px-2 py-1 ml-2 text-xs font-bold rounded-full bg-gradient-to-r from-purple-500 to-pink-500 text-white">${winner.platform.toUpperCase()}</span>` : '';
            
            winnerDisplay.innerHTML = `
                üéâ Winner: <strong class="text-gray-900">${winner.name}</strong> ${platformBadge}
            `;
            winnerDisplay.classList.remove('hidden');
            winnerDisplay.classList.add('block', 'winner-announcement');
            
            // Broadcast winner to OBS widget via WebRTC
            const winnerData = {
                name: winner.name,
                platform: winner.platform,
                timestamp: Date.now()
            };
            broadcastWinner(winnerData);
            
            // Create confetti effect
            createConfetti();
            
            // Save state and broadcast updates
            saveState();
        }

        // Create confetti effect
        function createConfetti() {
            const confettiCount = 100;
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '0';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.opacity = '1';
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                
                const shapes = ['circle', 'square', 'triangle'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                if (shape === 'circle') {
                    confetti.style.borderRadius = '50%';
                } else if (shape === 'triangle') {
                    confetti.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                }
                
                document.body.appendChild(confetti);
                
                const animation = confetti.animate([
                    { transform: `translate(0, 0) rotate(0)`, opacity: 1 },
                    { transform: `translate(${Math.random() * 100 - 50}px, ${Math.random() * 500 + 200}px) rotate(${Math.random() * 360}deg)`, top: '100vh', opacity: 0 }
                ], {
                    duration: Math.random() * 3000 + 2000,
                    easing: 'cubic-bezier(0.1, 0.4, 0.3, 1)'
                });
                
                animation.onfinish = () => confetti.remove();
            }
        }

        // Add entrant
        function addEntrant() {
            const nameInput = document.getElementById('entrant-name');
            const platformSelect = document.getElementById('platform-select');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a participant name');
                return;
            }
            
            const id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            entrants[id] = {
                name: name,
                platform: platformSelect.value
            };
            
            nameInput.value = '';
            updateDisplay();
            saveState();
        }

        // Clear all entrants
        function clearEntrants() {
            if (Object.keys(entrants).length === 0) return;
            
            if (confirm('Are you sure you want to clear all participants?')) {
                entrants = {};
                updateDisplay();
                saveState();
            }
        }

        // Add test data
        function addTestData() {
            const testEntrants = [
                { name: 'Alice', platform: 'twitch' },
                { name: 'Bob', platform: 'youtube' },
                { name: 'Charlie', platform: 'facebook' },
                { name: 'Diana', platform: 'instagram' },
                { name: 'Eve', platform: 'tiktok' },
                { name: 'Frank', platform: 'discord' },
                { name: 'Grace', platform: 'kick' }
            ];
            
            testEntrants.forEach((entrant, index) => {
                const id = 'test_' + Date.now() + '_' + index;
                entrants[id] = entrant;
            });
            
            updateDisplay();
            saveState();
        }

        // Remove entrant
        function removeEntrant(id) {
            delete entrants[id];
            updateDisplay();
            saveState();
        }

        // Update display
        function updateDisplay() {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsContainer = document.getElementById('entrants-container');
            const entrantCount = document.getElementById('entrant-count');
            
            // Update wheel
            drawWheel(canvas, entrants);
            
            // Update entrants list
            entrantCount.textContent = Object.keys(entrants).length;
            entrantsContainer.innerHTML = '';
            
            Object.entries(entrants).forEach(([id, entrant]) => {
                const entrantDiv = document.createElement('div');
                entrantDiv.className = 'flex justify-between items-center p-3 bg-white/5 hover:bg-white/10 rounded-lg border border-white/10 hover:border-white/20 transition-all duration-200 group';
                entrantDiv.innerHTML = `
                    <span class="flex items-center gap-2">
                        <span class="font-medium text-white">${entrant.name}</span>
                        <span class="inline-block px-2 py-1 text-xs font-bold rounded-full bg-gradient-to-r from-blue-500 to-purple-500 text-white">${entrant.platform.toUpperCase()}</span>
                    </span>
                    <button onclick="removeEntrant('${id}')" 
                            class="px-3 py-1 bg-red-500 hover:bg-red-600 text-white text-sm font-medium rounded-md transition-all duration-200 transform hover:scale-105 opacity-0 group-hover:opacity-100">
                        Remove
                    </button>
                `;
                entrantsContainer.appendChild(entrantDiv);
            });
        }

        // Save state and broadcast via WebRTC
        function saveState() {
            const state = {
                entrants: entrants,
                timestamp: Date.now()
            };
            
            // Broadcast to other giveaway instances via WebRTC
            broadcastGiveawayUpdate(state);
        }

        // Broadcast giveaway updates via WebRTC and local communication
        function broadcastGiveawayUpdate(data) {
            const message = {
                action: 'giveaway_update',
                data: data,
                timestamp: Date.now()
            };
            
            // Send via local communication (BroadcastChannel or localStorage)
            broadcastLocal(message);
            
            // Send via WebSocket if available
            if (socketserver && socketserver.readyState === WebSocket.OPEN) {
                socketserver.send(JSON.stringify(message));
                console.log('üì§ Broadcasted giveaway update via WebSocket');
            }
            
            // Send via WebRTC iframe if available
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        dataToSend: message,
                        target: 'giveaway'
                    }, '*');
                    console.log('üì§ Broadcasted giveaway update via WebRTC');
                } catch (e) {
                    console.error('‚ùå Failed to broadcast via WebRTC:', e);
                }
            }
        }

        // Local broadcast function
        function broadcastLocal(message) {
            // Use BroadcastChannel if available
            if (window.giveawayChannel) {
                window.giveawayChannel.postMessage(message);
                console.log('üì§ Broadcasted via BroadcastChannel:', message.action);
            } else {
                // Fallback to localStorage
                const key = 'giveaway_broadcast_' + roomID;
                localStorage.setItem(key, JSON.stringify(message));
                console.log('üì§ Broadcasted via localStorage:', message.action);
                // Clear after a short delay to trigger storage event
                setTimeout(() => {
                    localStorage.removeItem(key);
                }, 100);
            }
        }

        // Handle incoming giveaway updates from other instances
        function handleGiveawayUpdate(data) {
            if (data && data.entrants) {
                console.log('üì• Received giveaway update from other instance');
                entrants = data.entrants;
                updateDisplay();
            }
        }

        // Handle keyword updates from other instances
        function handleKeywordUpdate(keyword) {
            if (keyword) {
                console.log('üì• Received keyword update from other instance:', keyword);
                currentKeyword = keyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
            }
        }

        // Handle spin updates from other instances
        function handleSpinUpdate(spinData) {
            if (spinData && spinData.isSpinning) {
                console.log('üì• Received spin update from other instance');
                // Trigger spin animation if not already spinning
                if (!isSpinning && spinData.targetRotation && spinData.duration) {
                    startSpinFromRemote(spinData);
                }
            }
        }

        // Handle winner updates from other instances
        function handleWinnerUpdate(winnerData) {
            if (winnerData && winnerData.name) {
                console.log('üì• Received winner update from other instance:', winnerData.name);
                showWinnerFromRemote(winnerData);
            }
        }

        // Start spin animation from remote trigger
        function startSpinFromRemote(spinData) {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsList = Object.values(entrants);
            
            if (isSpinning || entrantsList.length === 0) return;
            
            isSpinning = true;
            
            // Reset to initial rotation
            currentRotation = (spinData.initialRotation || 0) * Math.PI / 180;
            drawWheel(canvas, entrants); // Redraw at initial position
            
            const syncStartTime = spinData.startTime || Date.now();
            const duration = spinData.duration || 4000;
            const finalRotationDegrees = spinData.targetRotationDegrees || (spinData.targetRotation * 180 / Math.PI);
            const finalRotationRadians = (finalRotationDegrees * Math.PI) / 180;
            
            // Wait until sync start time to ensure perfect synchronization
            const delay = Math.max(0, syncStartTime - Date.now());
            setTimeout(() => {
                function animate() {
                    const elapsed = Date.now() - syncStartTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function for smooth deceleration (identical to main spin)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    const rotationDegrees = finalRotationDegrees * easeOut;
                    currentRotation = (rotationDegrees * Math.PI) / 180;
                    
                    // Redraw wheel with new rotation
                    drawWheel(canvas, entrants);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        isSpinning = false;
                        currentRotation = finalRotationRadians; // Final position
                    }
                }
                
                animate();
            }, delay);
        }

        // Show winner from remote trigger
        function showWinnerFromRemote(winnerData) {
            const winnerDisplay = document.getElementById('winner-display');
            const platformBadge = winnerData.platform ? 
                `<span class="inline-block px-2 py-1 ml-2 text-xs font-bold rounded-full bg-gradient-to-r from-purple-500 to-pink-500 text-white">${winnerData.platform.toUpperCase()}</span>` : '';
            
            winnerDisplay.innerHTML = `
                üéâ Winner: <strong class="text-gray-900">${winnerData.name}</strong> ${platformBadge}
            `;
            winnerDisplay.classList.remove('hidden');
            winnerDisplay.classList.add('block');
            
            // Create confetti effect
            createConfetti();
        }

        // Broadcast spin state via WebRTC and local communication
        function broadcastSpinState(spinData) {
            const message = {
                action: 'spin_update',
                data: spinData,
                timestamp: Date.now()
            };
            
            // Send via local communication first
            broadcastLocal(message);
            
            // Send via WebSocket if available
            if (socketserver && socketserver.readyState === WebSocket.OPEN) {
                socketserver.send(JSON.stringify(message));
                console.log('üì§ Broadcasted spin state via WebSocket');
            }
            
            // Send via WebRTC iframe if available
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        dataToSend: message,
                        target: 'giveaway'
                    }, '*');
                    console.log('üì§ Broadcasted spin state via WebRTC');
                } catch (e) {
                    console.error('‚ùå Failed to broadcast spin state via WebRTC:', e);
                }
            }
        }

        // Broadcast winner via WebRTC and local communication
        function broadcastWinner(winnerData) {
            const message = {
                action: 'winner_update',
                data: winnerData,
                timestamp: Date.now()
            };
            
            // Send via local communication first
            broadcastLocal(message);
            
            // Send via WebSocket if available
            if (socketserver && socketserver.readyState === WebSocket.OPEN) {
                socketserver.send(JSON.stringify(message));
                console.log('üì§ Broadcasted winner via WebSocket');
            }
            
            // Send via WebRTC iframe if available
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        dataToSend: message,
                        target: 'giveaway'
                    }, '*');
                    console.log('üì§ Broadcasted winner via WebRTC');
                } catch (e) {
                    console.error('‚ùå Failed to broadcast winner via WebRTC:', e);
                }
            }
        }

        // Load state from localStorage (for backward compatibility)
        function loadState() {
            try {
                const savedState = localStorage.getItem('giveawayWheelState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (state.entrants) {
                        entrants = state.entrants;
                        updateDisplay();
                    }
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        // User-controlled keyword system
        function setKeyword() {
            const keywordInput = document.getElementById('keyword-input');
            const newKeyword = keywordInput.value.trim().toUpperCase();
            
            if (newKeyword && newKeyword.length > 0) {
                currentKeyword = newKeyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
                
                // Broadcast keyword change via WebRTC
                broadcastKeywordUpdate(currentKeyword);
                
                // Clear input
                keywordInput.value = '';
                
                console.log(`Keyword set to: ${currentKeyword}`);
            }
        }

        function broadcastKeywordUpdate(keyword) {
            const message = {
                action: 'keyword_update',
                keyword: keyword,
                timestamp: Date.now()
            };
            
            // Send via local communication first
            broadcastLocal(message);
            
            // Send via WebSocket if available
            if (socketserver && socketserver.readyState === WebSocket.OPEN) {
                socketserver.send(JSON.stringify(message));
                console.log('üì§ Broadcasted keyword update via WebSocket');
            }
            
            // Send via WebRTC iframe if available
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        dataToSend: message,
                        target: 'giveaway'
                    }, '*');
                    console.log('üì§ Broadcasted keyword update via WebRTC');
                } catch (e) {
                    console.error('‚ùå Failed to broadcast keyword via WebRTC:', e);
                }
            }
        }

        function loadKeyword() {
            const savedKeyword = localStorage.getItem('giveaway_keyword');
            if (savedKeyword) {
                currentKeyword = savedKeyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
            }
        }



        function openOBSWidget() {
            const obsUrl = window.location.origin + window.location.pathname.replace('giveaway.html', 'giveaway-obs-entries.html') + `?session=${roomID}&password=${password}`;
            window.open(obsUrl, '_blank', 'width=800,height=600');
            
            // Broadcast existing entries and keyword to the OBS widget after a short delay
            // This ensures the OBS widget has time to set up its listeners
            setTimeout(() => {
                console.log('üì§ Broadcasting existing entries to OBS widget...');
                
                // Broadcast current entries
                if (Object.keys(entrants).length > 0) {
                    const state = {
                        entrants: entrants,
                        timestamp: Date.now()
                    };
                    broadcastGiveawayUpdate(state);
                    console.log('üì§ Sent existing entries to OBS widget:', Object.keys(entrants).length, 'entries');
                }
                
                // Broadcast current keyword
                if (currentKeyword) {
                    broadcastKeywordUpdate(currentKeyword);
                    console.log('üì§ Sent current keyword to OBS widget:', currentKeyword);
                }
            }, 1000); // 1 second delay to allow OBS widget to initialize
        }

        // Simulate chat message processing for keyword entries
        // Clear all entries function
        function clearAllEntries() {
            entrants = {};
            updateDisplay();
            saveState();
            console.log('All entries cleared');
        }

        // Manual test function to simulate Social Stream messages
        function testSocialStreamMessage() {
            const testPlatforms = ['twitch', 'youtube', 'discord', 'kick', 'facebook'];
            const testUsers = ['TestUser1', 'TestUser2', 'StreamViewer', 'ChatFan', 'GiveawayLover'];
            
            const randomUser = testUsers[Math.floor(Math.random() * testUsers.length)] + Date.now();
            const randomPlatform = testPlatforms[Math.floor(Math.random() * testPlatforms.length)];
            
            // Simulate a Social Stream message structure
            const testMessage = {
                chatname: randomUser,
                chatmessage: `${currentKeyword} please! I want to win!`,
                type: randomPlatform,
                id: Date.now(),
                timestamp: Date.now()
            };
            
            console.log("Simulating Social Stream message:", testMessage);
            processGiveawayMessage(testMessage);
        }
        
        // Test WebRTC connection
        function testWebRTCConnection() {
            console.log('=== WEBRTC CONNECTION TEST ===');
            console.log('Iframe exists:', !!iframe);
            if (iframe) {
                console.log('Iframe src:', iframe.src);
                console.log('Iframe loaded:', iframe.contentDocument !== null);
                console.log('Iframe ready state:', iframe.readyState);
                
                // Try to send a test message to the iframe
                try {
                    iframe.contentWindow.postMessage({test: 'ping'}, '*');
                    console.log('Test message sent to iframe');
                } catch (error) {
                    console.error('Failed to send test message:', error);
                }
            } else {
                console.log('No iframe found!');
            }
            console.log('==============================');
        }
        
        // Add keyboard shortcuts for testing
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 't') {
                e.preventDefault();
                testSocialStreamMessage();
                console.log('Simulated Social Stream message (Ctrl+T)');
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                clearAllEntries();
                console.log('Cleared all entries (Ctrl+C)');
            } else if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                testWebRTCConnection();
            }
        });

        // Handle Enter key in name input
        document.getElementById('entrant-name').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addEntrant();
            }
        });
        
        // Handle Enter key in keyword input
        document.getElementById('keyword-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                setKeyword();
            }
        });



        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadState();
            loadKeyword();
            updateDisplay();
            
            // Connect to Social Stream WebRTC (always, for communication with other giveaway instances)
            setupWebRTCConnection();
        });
    </script>
</body>
</html>
