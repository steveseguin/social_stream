<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spiritveil Overlay</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&display=swap">
    <script src="https://socialstream.ninja/libs/colours.js" type="text/javascript"></script>
    <link rel="canonical" href="https://socialstream.ninja/">
    <meta name="generator" content="Social Stream Ninja - https://github.com/steveseguin/social_stream">
<style>
*,
*::before,
*::after {
    box-sizing: border-box;
}

html,
body {
    margin: 0;
    height: 100%;
    width: 100%;
    font-family: 'Cinzel', 'Courier New', monospace;
    color: #c0d1c7;
    background: radial-gradient(circle at 25% 20%, #05160d, #010302 55%, #000000 100%);
    background-attachment: fixed;
    overflow: hidden;
}

body::before {
    content: "";
    position: fixed;
    inset: 0;
    background: linear-gradient(160deg, #03150b, #010302 50%, #03150b 82%, #000000);
    opacity: 0.68;
    pointer-events: none;
    z-index: 0;
}

body::after {
    content: "";
    position: fixed;
    inset: -20%;
    background: radial-gradient(circle at center, #0623140f 0%, #04160d55 45%, #01040399 72%, #000000ee 100%);
    mix-blend-mode: screen;
    opacity: 0.65;
    transform: scale(1.08);
    pointer-events: none;
    z-index: 0;
    animation: chasmBreathe 42s ease-in-out infinite;
}

#spirit-canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
}

#overlay {
    position: relative;
    z-index: 2;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding: 0;
    isolation: isolate;
}


#chat-container {
    position: relative;
    width: 100%;
    max-width: 100%;
    height: 100%;
    padding: 32px;
    border-radius: 0;
    border: none;
    background: transparent;
    box-shadow: none;
    backdrop-filter: none;
    overflow: hidden;
}


#message-viewport {
    position: relative;
    width: 100%;
    height: 100%;
    overflow-y: scroll;
    overflow-x: hidden;
    scrollbar-width: none;
}

#message-viewport::-webkit-scrollbar {
    width: 0;
    height: 0;
}

#message-list {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    gap: 24px;
    padding-bottom: 32px;
    min-height: 100%;
    max-width: 600px;
    margin: 0 auto;
    width: 100%;
}

.message,
.message-list-wrapper {
    position: relative;
    background: linear-gradient(132deg, #041b1199, #03140e88 56%, #020c0a99);
    border: 1px solid #29463222;
    border-left: 2px solid var(--edge-color, #2C544033);
    border-radius: 12px;
    padding: 18px 20px;
    color: #d3e2d7;
    box-shadow: 0 12px 32px #01050366, inset 0 1px 0 #21604011;
    opacity: 0;
    transform: translateY(24px);
    filter: blur(6px);
    overflow: visible;
    transition: max-height 0.7s cubic-bezier(0.22, 1, 0.36, 1), padding-top 0.48s ease-out, padding-bottom 0.48s ease-out, opacity 0.56s ease-out, filter 0.56s ease-out, transform 0.56s ease-out;
}

.message.entering,
.message-list-wrapper.entering {
    overflow: hidden;
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
}

.message.visible,
.message-list-wrapper.visible {
    opacity: 1;
    transform: translateY(0);
    filter: blur(0px);
    max-height: var(--message-height, 540px);
    padding-top: 18px;
    padding-bottom: 18px;
    animation: emberPulse 9.2s ease-in-out infinite;
    animation-delay: 1.1s;
    animation-fill-mode: forwards;
}

.message-inner {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 20px;
    align-items: start;
    max-width: 100%;
    overflow: hidden;
}

.avatar-ring {
    position: relative;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: conic-gradient(from 90deg, #1f3f2d, #0f2519, #2a533c 70%, #1f3f2d);
    padding: 3px;
    box-shadow: inset 0 0 12px #021208AA, 0 0 18px #06190E66;
}

.avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    filter: saturate(0.82);
}

.message-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 0;
    max-width: 100%;
    overflow-wrap: break-word;
}

.meta-line {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 6px;
}

.name {
    font-weight: 600;
    font-size: 1rem;
    letter-spacing: 0.06em;
    color: #e0ede3;
    text-transform: uppercase;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}

.source-icon {
    width: 18px;
    height: 18px;
}

.badge {
    display: inline-block;
    height: 18px;
}

.membership-status {
    font-size: 0.82rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #8ea598;
}

.text {
    font-size: 0.96rem;
    line-height: 1.58;
    color: #c7d7cc;
    word-wrap: break-word;
    word-break: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}

.text em {
    color: #9cb4a7;
}

.text img {
    max-width: 110px;
    max-height: 32px;
    vertical-align: middle;
}

.donation {
    font-size: 0.9rem;
    font-weight: 600;
    letter-spacing: 0.05em;
    color: #90c3a5;
}

.content-image-wrapper {
    margin-top: 18px;
    border-radius: 18px;
    padding: 6px;
    background: linear-gradient(135deg, #1a3c2a, #0c2417);
    box-shadow: inset 0 0 24px #010703AA;
}

.large-image {
    display: block;
    width: 100%;
    height: auto;
    border-radius: 14px;
}

.message::before {
    content: "";
    position: absolute;
    inset: -40% -60%;
    background: radial-gradient(circle at 20% 120%, #0f372411 0%, #0a1f1508 38%, #00000000 100%);
    animation: shadowSweep 28s ease-in-out infinite;
    pointer-events: none;
    mix-blend-mode: screen;
}

.message::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(120deg, #071a1244 0%, #020d0a00 40%, #020d0a33 72%, #04130f00 100%);
    opacity: 0.4;
    pointer-events: none;
}

@keyframes chasmBreathe {
    0% { transform: scale(1.06) translateY(0); opacity: 0.55; }
    38% { transform: scale(1.12) translateY(-3%); opacity: 0.7; }
    66% { transform: scale(1.08) translateY(2%); opacity: 0.62; }
    100% { transform: scale(1.06) translateY(0); opacity: 0.55; }
}


@keyframes shadowSweep {
    0% { transform: translate3d(-10%, 12%, 0) scale(1.05); opacity: 0.35; }
    50% { transform: translate3d(12%, -8%, 0) scale(1.2); opacity: 0.55; }
    100% { transform: translate3d(-10%, 12%, 0) scale(1.05); opacity: 0.35; }
}

@keyframes emberPulse {
    0% { box-shadow: 0 22px 64px #010503C6, inset 0 1px 0 #21604033; }
    48% { box-shadow: 0 30px 74px #021208CC, inset 0 1px 0 #2F704044; }
    100% { box-shadow: 0 22px 64px #010503C6, inset 0 1px 0 #21604033; }
}
</style>
</head>
<body>
<canvas id="spirit-canvas"></canvas>
<div id="overlay">
    <div id="chat-container">
        <div id="message-viewport">
            <div id="message-list"></div>
        </div>
    </div>
</div>
<script>
(function setupSpirits() {
    const canvas = document.getElementById('spirit-canvas');
    const ctx = canvas.getContext('2d');
    const particles = [];
    const flowLines = [];
    const palette = ['#0f2a18', '#143424', '#1a3f2e', '#11311f', '#193c2b'];
    const PARTICLE_COUNT = 62;
    const FLOW_COUNT = 14;
    let lastTime = 0;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function createParticle() {
        const depth = 0.45 + Math.random() * 0.75;
        const size = 90 + Math.random() * 160;
        return {
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            depth,
            baseSize: size,
            driftSpeedX: (Math.random() - 0.5) * (0.08 + depth * 0.12),
            driftSpeedY: (Math.random() - 0.5) * (0.06 + depth * 0.1),
            alphaBase: 0.12 + Math.random() * 0.16,
            alphaRange: 0.08 + Math.random() * 0.16,
            color: palette[Math.floor(Math.random() * palette.length)],
            offset: Math.random() * Math.PI * 2,
            scalePulse: 0.25 + Math.random() * 0.55,
            wander: 0.2 + Math.random() * 0.32
        };
    }

    function createFlowLine() {
        const width = 140 + Math.random() * 220;
        return {
            x: Math.random() * canvas.width,
            width,
            height: canvas.height * (0.5 + Math.random() * 0.9),
            speed: 0.009 + Math.random() * 0.02,
            sway: 30 + Math.random() * 120,
            offset: Math.random(),
            color: palette[Math.floor(Math.random() * palette.length)],
            alphaBase: 0.04 + Math.random() * 0.06,
            alphaRange: 0.03 + Math.random() * 0.05,
            tilt: (Math.random() - 0.5) * width * 0.8
        };
    }

    function initParticles() {
        particles.length = 0;
        flowLines.length = 0;
        for (let i = 0; i < PARTICLE_COUNT; i += 1) {
            particles.push(createParticle());
        }
        for (let i = 0; i < FLOW_COUNT; i += 1) {
            flowLines.push(createFlowLine());
        }
        lastTime = 0;
    }

    function wrapParticle(p) {
        if (p.x < -160) p.x = canvas.width + 140;
        if (p.x > canvas.width + 160) p.x = -140;
        if (p.y < -120) p.y = canvas.height + 100;
        if (p.y > canvas.height + 120) p.y = -100;
    }

    function drawParticle(p, timeSeconds) {
        const pulse = Math.sin(timeSeconds * (0.5 + p.depth * 0.35) + p.offset);
        const size = p.baseSize * (0.65 + p.scalePulse * (pulse * 0.5 + 0.5));
        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
        gradient.addColorStop(0, p.color + 'DD');
        gradient.addColorStop(0.55, p.color + '66');
        gradient.addColorStop(1, '#00000000');
        const alpha = Math.max(0.05, Math.min(0.85, p.alphaBase + p.alphaRange * (pulse * 0.5)));
        ctx.globalAlpha = alpha;
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }

    function drawFlowLine(flow, timeSeconds) {
        const progress = (timeSeconds * flow.speed + flow.offset) % 1;
        const y = progress * (canvas.height + flow.height) - flow.height;
        const x = flow.x + Math.sin((timeSeconds + flow.offset) * 0.7) * flow.sway;
        const gradient = ctx.createLinearGradient(
            x - flow.width * 0.35,
            y,
            x + flow.tilt,
            y + flow.height
        );
        gradient.addColorStop(0, '#00000000');
        gradient.addColorStop(0.18, flow.color + '22');
        gradient.addColorStop(0.5, flow.color + '55');
        gradient.addColorStop(0.82, flow.color + '11');
        gradient.addColorStop(1, '#00000000');
        const alpha = flow.alphaBase + flow.alphaRange * Math.sin((timeSeconds + flow.offset) * 0.8);
        ctx.save();
        ctx.globalAlpha = Math.max(0.02, Math.min(0.6, alpha));
        ctx.fillStyle = gradient;
        ctx.fillRect(x - flow.width * 0.5, y, flow.width, flow.height);
        ctx.restore();
    }

    function animate(time) {
        const timeSeconds = time * 0.001;
        const delta = lastTime ? timeSeconds - lastTime : 0.016;
        lastTime = timeSeconds;
        const deltaScale = Math.min(3, delta * 60);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#010805';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        flowLines.forEach((flow) => drawFlowLine(flow, timeSeconds));

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        particles.forEach((particle) => {
            const waveX = Math.cos(timeSeconds * particle.wander + particle.offset) * 0.22 * particle.depth;
            const waveY = Math.sin(timeSeconds * particle.wander + particle.offset) * 0.16 * particle.depth;
            particle.x += (waveX + particle.driftSpeedX) * deltaScale;
            particle.y += (waveY + particle.driftSpeedY) * deltaScale;
            wrapParticle(particle);
            drawParticle(particle, timeSeconds);
        });
        ctx.restore();

        requestAnimationFrame(animate);
    }

    resizeCanvas();
    initParticles();
    requestAnimationFrame(animate);
    window.addEventListener('resize', () => {
        resizeCanvas();
        initParticles();
    });
}());

(function setupOverlay() {
    const urlParams = new URLSearchParams(window.location.search);
    let roomID = 'iWWnKL28tQ';
    if (urlParams.has('session')) {
        roomID = urlParams.get('session');
    }
    const password = 'false';
    const featuredMode = false;

    const messageViewport = document.getElementById('message-viewport');
    const messageList = document.getElementById('message-list');
    const MAX_MESSAGES = urlParams.has('limit') ? parseInt(urlParams.get('limit'), 10) : 24;
    const messageTimestamps = new Map();
    const MESSAGE_FADE_OUT_MS = urlParams.has('fadeout') ? parseInt(urlParams.get('fadeout'), 10) : 46000;
    let trimMessageTimeout = null;
    let activeBottomPinEnd = 0;

    function isEmptyMessage(data) {
        return !data.chatname && !data.chatmessage && !data.hasDonation && !data.donation && !data.contentimg;
    }

    function buildBadges(chatbadges) {
        if (!chatbadges) return '';
        return chatbadges.map((badge) => {
            if (typeof badge === 'object') {
                if (badge.type === 'img' && badge.src) {
                    return `<img class="badge" src="${badge.src}" alt="badge">`;
                }
                if (badge.type === 'svg' && badge.html) {
                    return `<span class="badge svg">${badge.html}</span>`;
                }
                return '';
            }
            return `<img class="badge" src="${badge}" alt="badge">`;
        }).join('');
    }

    function createMessageElement(data) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', 'message-list-wrapper');

        const messageId = data.mid || `msg-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
        messageDiv.id = messageId;
        messageTimestamps.set(messageId, Date.now());

        if (typeof getColorFromType === 'function' && data.type) {
            try {
                const edgeColor = getColorFromType(data.type);
                if (edgeColor) {
                    messageDiv.style.setProperty('--edge-color', edgeColor);
                }
            } catch (error) {
                console.error('Error resolving edge color:', error);
            }
        }

        const sourceIconHtml = data.type ? `<img src="https://socialstream.ninja/sources/images/${data.type}.png" alt="source" class="source-icon">` : '';
        const avatarHtml = data.chatimg ? `
            <div class="avatar-ring">
                <div class="avatar" style="background-image: url('${data.chatimg}');"></div>
            </div>` : `
            <div class="avatar-ring">
                <div class="avatar" style="background-image: url('https://socialstream.ninja/unknown.png');"></div>
            </div>`;

        const membershipHtml = data.membership ? `<div class="membership-status">${data.membership}</div>` : '';
        const donationHtml = data.hasDonation ? `<div class="donation">${data.hasDonation}</div>` : '';
        const messageTextHtml = data.chatmessage ? `<div class="text"${data.event ? ' style="font-style: italic;"' : ''}>${data.chatmessage}</div>` : '';
        const contentImageHtml = data.contentimg ? `
            <div class="content-image-wrapper">
                <img src="${data.contentimg}" alt="content" class="large-image" onerror="this.closest('.content-image-wrapper').style.display='none';">
            </div>` : '';

        const badgesHtml = buildBadges(data.chatbadges);
        const nameHtml = data.chatname ? `<span class="name"${data.nameColor ? ` style="color: ${data.nameColor};"` : ''}>${data.chatname}</span>` : '';

        messageDiv.innerHTML = `
            <div class="message-inner">
                ${avatarHtml}
                <div class="message-content">
                    <div class="meta-line">
                        ${nameHtml}
                        ${sourceIconHtml}
                        ${badgesHtml}
                    </div>
                    ${membershipHtml}
                    ${messageTextHtml}
                    ${donationHtml}
                </div>
            </div>
            ${contentImageHtml}
        `;

        return messageDiv;
    }

    function scheduleTrim() {
        if (trimMessageTimeout) {
            clearTimeout(trimMessageTimeout);
        }
        trimMessageTimeout = setTimeout(() => {
            const removed = trimMessages();
            if (removed) {
                pinViewportToBottom(840);
            }
            trimMessageTimeout = null;
        }, 720);
    }

    function pinViewportToBottom(durationMs = 1200) {
        const now = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
        activeBottomPinEnd = Math.max(activeBottomPinEnd, now + durationMs);
        function step(time) {
            const target = Math.max(0, messageViewport.scrollHeight - messageViewport.clientHeight);
            messageViewport.scrollTop = target;
            const currentTime = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? time : Date.now();
            if (currentTime < activeBottomPinEnd) {
                requestAnimationFrame(step);
            }
        }
        requestAnimationFrame(step);
    }

    function animateMessageEntry(element) {
        const targetHeight = element.scrollHeight;
        element.style.setProperty('--message-height', `${Math.max(targetHeight, 1)}px`);
        element.classList.add('entering');
        // Force layout so the browser acknowledges the entering state before transition.
        void element.offsetHeight;
        element.classList.add('visible');
        const target = Math.max(0, messageViewport.scrollHeight - messageViewport.clientHeight);
        messageViewport.scrollTop = target;
        pinViewportToBottom();
        const handleTransitionEnd = (event) => {
            if (event.propertyName === 'max-height') {
                element.classList.remove('entering');
                element.style.maxHeight = 'none';
                element.style.removeProperty('--message-height');
                element.removeEventListener('transitionend', handleTransitionEnd);
            }
        };
        element.addEventListener('transitionend', handleTransitionEnd);
    }

    function trimMessages() {
        let removed = false;
        while (messageList.children.length > MAX_MESSAGES) {
            const oldest = messageList.firstElementChild;
            if (!oldest) break;
            messageTimestamps.delete(oldest.id);
            messageList.removeChild(oldest);
            removed = true;
        }
        return removed;
    }

    function addMessageToOverlay(data) {
        if (!data || isEmptyMessage(data)) return;
        const messageElement = createMessageElement(data);
        messageList.appendChild(messageElement);
        animateMessageEntry(messageElement);
        scheduleTrim();
    }

    function setupMessageAging() {
        if (!MESSAGE_FADE_OUT_MS || Number.isNaN(MESSAGE_FADE_OUT_MS)) return;
        setInterval(() => {
            const now = Date.now();
            Array.from(messageList.children).forEach((item) => {
                const created = messageTimestamps.get(item.id);
                if (!created) return;
                const age = now - created;
                if (age > MESSAGE_FADE_OUT_MS) {
                    item.style.transition = 'transform 3.5s ease-in, opacity 3.5s ease-in, filter 3.5s ease-in';
                    item.style.opacity = '0';
                    item.style.transform = 'translateY(-120vh)';
                    item.style.filter = 'blur(5px)';
                    setTimeout(() => {
                        if (item.parentElement === messageList) {
                            messageList.removeChild(item);
                        }
                    }, 3500);
                    messageTimestamps.delete(item.id);
                }
            });
        }, 2000);
    }

    setupMessageAging();

    const iframe = document.createElement('iframe');
    if (featuredMode) {
        iframe.src = `https://vdo.socialstream.ninja/?ln&password=${password}&salt=vdo.ninja&label=overlay&exclude=${roomID}&scene&novideo&noaudio&cleanoutput&room=${roomID}`;
    } else {
        iframe.src = `https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password=${password}&push&label=dock&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput&room=${roomID}`;
    }
    iframe.style.cssText = 'width: 0px; height: 0px; position: fixed; left: -100px; top: -100px;';
    document.body.appendChild(iframe);

    window.addEventListener('message', (event) => {
        if (event.source !== iframe.contentWindow) return;
        if (event.data && event.data.dataReceived && event.data.dataReceived.overlayNinja) {
            addMessageToOverlay(event.data.dataReceived.overlayNinja);
        }
    });

    let socketserver = null;
    let reconnectFactor = 1;
    let serverURL = urlParams.has('localserver') ? 'ws://127.0.0.1:3000' : 'wss://io.socialstream.ninja';

    function setupSocket() {
        if (!socketserver) return;
        socketserver.onclose = () => {
            setTimeout(() => {
                reconnectFactor += 1;
                socketserver = new WebSocket(serverURL);
                setupSocket();
            }, 120 * reconnectFactor);
        };
        socketserver.onopen = () => {
            reconnectFactor = 1;
            try {
                socketserver.send(JSON.stringify({ join: roomID, out: 3, in: 4 }));
            } catch (error) {
                console.error('Socket join failed:', error);
            }
        };
        socketserver.addEventListener('message', (event) => {
            if (!event.data) return;
            try {
                const payload = JSON.parse(event.data);
                if (payload) {
                    addMessageToOverlay(payload);
                }
            } catch (error) {
                console.error('Error processing WebSocket message:', error, event.data);
            }
        });
    }

    if (urlParams.has('server') || urlParams.has('server2')) {
        serverURL = urlParams.get('server') || urlParams.get('server2') || serverURL;
        socketserver = new WebSocket(serverURL);
        setupSocket();
    }
}());
</script>
</body>
</html>
