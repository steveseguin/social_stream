<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>From LuckyLootTube with Love</title>
<link rel="preload" href="./thirdparty/NotoColorEmoji.ttf" as="font" type="font/ttf" crossorigin="anonymous">

<style>
@import url('https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;600;700&display=swap');

:root {
/* Brand anchors (original colors) */
--primary: #6c89fd;
--accent: #fa6d47;
--success: #34C759;
--donation: #fa6d47;

/* Text colors - ultra crisp */
--text: #eed9c4;
--textSoft: #eed9c4;
--textSubtle: #eed9c4;

/* Glass materials */
--glassBg: rgba(20, 20, 22, 0.72);
--glassLight: rgba(255, 255, 255, 0.08);
--glassHighlight: rgba(255, 255, 255, 0.18);

/* Borders & strokes */
--border: rgba(255, 255, 255, 0.15);
--borderSubtle: rgba(255, 255, 255, 0.08);

/* Shadows - layered depth */
--shadowPrimary: 0 4px 24px rgba(0, 0, 0, 0.28);
--shadowSecondary: 0 12px 48px rgba(0, 0, 0, 0.20);
--shadowLift: 0 8px 32px rgba(0, 0, 0, 0.32);

/* Measurements */
--blur: 40px;
--blurStrong: 60px;
--radius: 20px;
--radiusLarge: 28px;
--gap: 16px;
--maxWidth: 740px;
--msgPad: 18px;
--avatar: 56px;

/* Typography */
--nameSize: 30px;
--msgSize: 21px;

/* Fade effects */
--topFadePx: 140px;
}

* {
box-sizing: border-box;
margin: 0;
padding: 0;
}

html,
body {
width: 100%;
height: 100%;
overflow: hidden;
font-family: 'Ubuntu', 'SF Pro Display', sans-serif;
background: transparent;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}

/* Bokeh canvas background */
#webgl-canvas {
display: block;
position: fixed;
inset: 0;
width: 100%;
height: 100%;
z-index: 0;
}

/* Ambient tint overlay with dark vignette mask */
.bokehTint {
position: fixed;
inset: 0;
z-index: 1;
pointer-events: none;
background:
radial-gradient(1200px 600px at 18% 10%, rgba(54, 55, 83, 0.12), transparent 55%),
radial-gradient(900px 520px at 85% 35%, rgba(54, 55, 83, 0.16), transparent 62%),
radial-gradient(ellipse 120% 100% at 50% 50%, transparent 20%, rgba(0, 0, 0, 0.35) 85%),
linear-gradient(180deg, rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0.45));
}

/* Main stage */
.stage {
position: relative;
width: 100%;
height: 100%;
display: flex;
align-items: stretch;
justify-content: center;
padding: 32px 28px;
z-index: 2;
background: transparent;
}

/* Viewport with gradient fade */
.chatViewport {
position: relative;
width: min(var(--maxWidth), 100%);
height: 100%;
display: flex;
align-items: flex-end;
justify-content: center;
margin: 0 auto;
z-index: 2;

/* Sophisticated gradient masks */
-webkit-mask-image:
linear-gradient(to bottom,
rgba(0, 0, 0, 0) 0px,
rgba(0, 0, 0, 0.4) calc(var(--topFadePx) * 0.5),
rgba(0, 0, 0, 1) var(--topFadePx),
rgba(0, 0, 0, 1) 100%),
radial-gradient(150% 130% at 50% 70%,
rgba(0, 0, 0, 1) 0%,
rgba(0, 0, 0, 1) 55%,
rgba(0, 0, 0, 0.7) 70%,
rgba(0, 0, 0, 0) 100%);
-webkit-mask-composite: source-in;

mask-image:
linear-gradient(to bottom,
rgba(0, 0, 0, 0) 0px,
rgba(0, 0, 0, 0.4) calc(var(--topFadePx) * 0.5),
rgba(0, 0, 0, 1) var(--topFadePx),
rgba(0, 0, 0, 1) 100%),
radial-gradient(150% 130% at 50% 70%,
rgba(0, 0, 0, 1) 0%,
rgba(0, 0, 0, 1) 55%,
rgba(0, 0, 0, 0.7) 70%,
rgba(0, 0, 0, 0) 100%);
mask-composite: intersect;
}

/* Chat container */
.chat {
position: relative;
width: 100%;
display: block;
overflow: visible;
isolation: isolate;
transform: translateZ(0);
}

/* Messages list */
.chatList {
position: relative;
z-index: 3;
display: flex;
flex-direction: column;
gap: var(--gap);
padding: 20px 0;
}

/* Message bubble - Apple's liquid glass effect */
.msg {
position: relative;
display: grid;
grid-template-columns: var(--avatar) 1fr;
align-items: start;
gap: 16px;
padding: var(--msgPad);
border-radius: var(--radius);

/* Layered glass background */
background:
radial-gradient(900px 220px at 12% 12%, rgba(255, 255, 255, 0.08), transparent 58%),
radial-gradient(700px 200px at 90% 28%, rgba(108, 137, 253, 0.10), transparent 60%),
linear-gradient(180deg, rgba(12, 12, 18, 0.52), rgba(12, 12, 18, 0.26));

/* Subtle border */
border: 1px solid rgba(255, 255, 255, 0.10);

/* Subtle depth - minimal shadows */
box-shadow:
0 4px 16px rgba(0, 0, 0, 0.15),
inset 0 1px 0 rgba(255, 255, 255, 0.08);

/* Glass blur effect */
backdrop-filter: blur(calc(var(--blur) - 4px)) saturate(110%);
-webkit-backdrop-filter: blur(calc(var(--blur) - 4px)) saturate(110%);

/* Animation */
transform: translateY(12px);
opacity: 0;
animation: msgAppear 420ms cubic-bezier(0.2, 0.9, 0.25, 1) forwards;
will-change: transform, opacity;
}

/* Specular highlight layer */
.msg::before {
content: "";
position: absolute;
inset: 0;
border-radius: inherit;
pointer-events: none;
background:
linear-gradient(115deg,
rgba(255, 255, 255, 0.10),
transparent 22%,
rgba(255, 255, 255, 0.05),
transparent 64%,
rgba(255, 255, 255, 0.10));
opacity: 0.55;
mix-blend-mode: screen;
filter: blur(0.3px);
}

/* Rainbow border effect - created with pseudo-element */
.msg::after {
content: "";
position: absolute;
inset: -2px;
border-radius: inherit;
padding: 2px;
background: linear-gradient(
90deg,
rgba(255, 100, 100, 0.6),
rgba(255, 200, 100, 0.6),
rgba(255, 255, 100, 0.6),
rgba(100, 255, 100, 0.6),
rgba(100, 200, 255, 0.6),
rgba(200, 100, 255, 0.6),
rgba(255, 100, 200, 0.6),
rgba(255, 100, 100, 0.6)
);
background-size: 300% 100%;
mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
mask-composite: exclude;
-webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
-webkit-mask-composite: xor;
opacity: 0;
filter: blur(5px);
transition: opacity 0.3s ease;
pointer-events: none;
z-index: -1;
}

.msg:hover {
transform: translateY(-2px);
border-color: rgba(255, 255, 255, 0.15);
border-width: 1px;
}

.msg:hover::after {
opacity: 1;
animation: rainbowFlow 8s linear infinite;
}

@keyframes rainbowFlow {
0% {
background-position: 0% 50%;
}
100% {
background-position: 300% 50%;
}
}

@keyframes msgAppear {
to {
transform: translateY(0);
opacity: 1;
}
}

.msg.fading {
opacity: 0;
transition: opacity 1s ease-out;
}

/* Inner glow frame on all four sides */
.msg .bar {
position: absolute;
inset: 6px;
/* Creates the frame spacing from edges */
border-radius: inherit;
pointer-events: none;

/* Multi-layered glow from all sides */
background:
/* Top glow */
radial-gradient(120px 20px at 50% 0%,
rgba(108, 137, 253, 0.45),
rgba(250, 109, 71, 0.18) 55%,
rgba(250, 109, 71, 0.00) 75%),

/* Right glow */
radial-gradient(20px 120px at 100% 50%,
rgba(108, 137, 253, 0.45),
rgba(250, 109, 71, 0.18) 55%,
rgba(250, 109, 71, 0.00) 75%),

/* Bottom glow */
radial-gradient(120px 20px at 50% 100%,
rgba(108, 137, 253, 0.45),
rgba(250, 109, 71, 0.18) 55%,
rgba(250, 109, 71, 0.00) 75%),

/* Left glow (your original) */
radial-gradient(20px 120px at 0% 50%,
rgba(108, 137, 253, 0.45),
rgba(250, 109, 71, 0.18) 55%,
rgba(250, 109, 71, 0.00) 75%);

filter: blur(6px);
opacity: 0.9;
}

/* Subtle inner edge sparks on all four sides */
.msg .bar::after {
content: "";
position: absolute;
inset: 10px;
border-radius: inherit;

background: linear-gradient(180deg,
rgba(255, 255, 255, 0.22),
rgba(255, 255, 255, 0.06));

/* Standard property first, then webkit prefix for older Safari */
mask:
linear-gradient(#fff 0 0) content-box,
linear-gradient(#fff 0 0);
mask-composite: exclude;
-webkit-mask:
linear-gradient(#fff 0 0) content-box,
linear-gradient(#fff 0 0);
-webkit-mask-composite: xor;

padding: 2px;
opacity: 0.55;
filter: blur(0.2px);
}

/* Avatar with premium treatment */
.avatar {
width: var(--avatar);
height: var(--avatar);
border-radius: 50%;
overflow: hidden;
position: relative;
isolation: isolate;

background: linear-gradient(135deg,
rgba(108, 137, 253, 0.15),
rgba(250, 109, 71, 0.10));

border: 1.5px solid rgba(255, 255, 255, 0.15);

box-shadow:
0 0 0 2px rgba(0, 0, 0, 0.15) inset,
0 8px 24px rgba(0, 0, 0, 0.30),
0 2px 8px rgba(0, 0, 0, 0.20);
}

.avatar img {
width: 100%;
height: 100%;
object-fit: cover;
display: block;
}

/* Animated ring glow */
.avatar::after {
content: "";
position: absolute;
inset: -2px;
border-radius: 50%;
background: conic-gradient(from 180deg,
rgba(108, 137, 253, 0),
rgba(108, 137, 253, 0.6),
rgba(250, 109, 71, 0.6),
rgba(108, 137, 253, 0.6),
rgba(108, 137, 253, 0));
filter: blur(8px);
opacity: 0.8;
animation: avatarRing 8s linear infinite;
pointer-events: none;
z-index: -1;
}

@keyframes avatarRing {
to {
transform: rotate(360deg);
}
}

/* Content area */
.content {
min-width: 0;
display: flex;
flex-direction: column;
gap: 8px;
}

.topline {
display: flex;
align-items: center;
gap: 10px;
min-width: 0;
}

.name {
font-weight: 600;
font-size: var(--nameSize);
color: rgba(108, 137, 253, 0.95);
text-shadow: 0 0 16px rgba(108, 137, 253, 0.22);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
max-width: 60%;
letter-spacing: -0.01em;
transition: color 0.35s ease, text-shadow 0.35s ease;
}

/* EVEN messages â†’ blue */
.msg:nth-child(even) .name {
color: rgba(108, 137, 253, 0.95);
text-shadow: 0 0 16px rgba(108, 137, 253, 0.22);
}

/* ODD messages â†’ orange */
.msg:nth-child(odd) .name {
color: rgba(250, 109, 71, 0.95);
text-shadow: 0 0 16px rgba(250, 109, 71, 0.22);
}

/* Meta pills */
.meta {
display: flex;
align-items: center;
gap: 6px;
min-width: 0;
}

.pill {
display: inline-flex;
align-items: center;
gap: 6px;
padding: 4px 10px;
border-radius: 8px;

background: rgba(255, 255, 255, 0.08);
border: 1px solid rgba(255, 255, 255, 0.12);

backdrop-filter: blur(20px) saturate(180%);
-webkit-backdrop-filter: blur(20px) saturate(180%);

box-shadow:
0 2px 8px rgba(0, 0, 0, 0.15),
inset 0 1px 0 rgba(255, 255, 255, 0.10);

color: var(--textSoft);
font-size: 11px;
font-weight: 600;
text-transform: uppercase;
letter-spacing: 0.05em;
}

.pill::before {
content: "";
position: absolute;
inset: 0;
border-radius: inherit;
background: linear-gradient(135deg,
rgba(255, 255, 255, 0.10),
transparent 50%);
pointer-events: none;
}

.donation {
background: rgba(250, 109, 71, 0.10);
border: 1px solid rgba(250, 109, 71, 0.22);
color: rgba(250, 109, 71, 0.92);
box-shadow:
0 2px 12px rgba(250, 109, 71, 0.12),
inset 0 1px 0 rgba(255, 255, 255, 0.15);
}


/* Message text */
.message {
color: var(--text);
font-size: var(--msgSize);
line-height: 1.5;
font-weight: 500;
letter-spacing: -0.01em;
text-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
word-wrap: break-word;
overflow-wrap: anywhere;

/* Emoji rendering consistency across platforms */
font-family: 'Ubuntu', 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
}

/* Emotes / emoji images (Twitch/SSN/BTTV/7TV/FFZ) */
.message img {
  height: 1.15em;         /* scales perfectly with font-size */
  width: auto;
  max-height: 1.35em;
  vertical-align: -0.18em; /* baseline alignment for most emotes */
  display: inline-block;
  margin: 0 0.06em;
  image-rendering: auto;
  transform: translateZ(0);
  filter: drop-shadow(0 0 0 rgba(0,0,0,0));
  transition: filter 140ms ease, transform 140ms ease;
}

/* Subtle emote glow on hover */
.message img:hover {
  filter:
    drop-shadow(0 0 6px rgba(108, 137, 253, 0.35))
    drop-shadow(0 0 10px rgba(250, 109, 71, 0.18));
  transform: scale(1.03);
}

/* Unicode emoji baseline correction (Apple vs Noto) */
.message .emojiChar{
  display: inline-block;
  font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji';
  position: relative;
  top: 0.06em; /* small nudge downward to match text baseline */
}


/* Media attachments */
.media {
margin-top: 10px;
border-radius: 14px;
overflow: hidden;
border: 1px solid rgba(255, 255, 255, 0.12);
box-shadow:
0 8px 32px rgba(0, 0, 0, 0.30),
0 2px 8px rgba(0, 0, 0, 0.20);
background: rgba(0, 0, 0, 0.20);
}

.media img,
.media video {
width: 100%;
display: block;
}

/* Donation message special treatment */
.msg.is-donation {
background:
linear-gradient(135deg,
rgba(250, 109, 71, 0.12) 0%,
rgba(250, 109, 71, 0.04) 50%,
rgba(250, 109, 71, 0.08) 100%),
var(--glassBg);

border: 1px solid rgba(250, 109, 71, 0.25);

box-shadow:
0 0 0 1px rgba(250, 109, 71, 0.20) inset,
0 4px 16px rgba(250, 109, 71, 0.18),
0 8px 32px rgba(0, 0, 0, 0.15);
}

@keyframes donationPulse {

0%,
100% {
box-shadow:
0 0 0 1px rgba(250, 109, 71, 0.20) inset,
0 4px 16px rgba(250, 109, 71, 0.18),
0 8px 32px rgba(0, 0, 0, 0.15);
}

50% {
box-shadow:
0 0 0 1px rgba(250, 109, 71, 0.30) inset,
0 6px 24px rgba(250, 109, 71, 0.28),
0 12px 48px rgba(0, 0, 0, 0.20);
}
}

.msg.is-donation {
animation: msgAppear 420ms cubic-bezier(0.2, 0.9, 0.25, 1) forwards,
donationPulse 2.5s ease-in-out infinite 420ms;
}

.msg.is-donation .bar {
background: linear-gradient(180deg,
rgba(250, 109, 71, 0.95),
rgba(250, 109, 71, 0.85));
box-shadow:
0 0 16px rgba(250, 109, 71, 0.5),
0 0 32px rgba(250, 109, 71, 0.3);
}

/* Responsive adjustments */
@media (max-width: 520px) {
:root {
--msgPad: 14px;
--avatar: 44px;
--nameSize: 14px;
--msgSize: 15px;
--topFadePx: 100px;
}

.stage {
padding: 20px 16px;
}

.name {
max-width: 55%;
}
}
</style>
</head>

<body>
<!-- BOKEH BACKGROUND -->
<canvas id="webgl-canvas"></canvas>
<div class="bokehTint"></div>

<!-- CHAT UI -->
<div class="stage">
<div class="chatViewport">
<div class="chat" id="chat">
<div class="chatList" id="chatList"></div>
</div>
</div>
</div>

<script>
const urlParams = new URLSearchParams(window.location.search);

// showtime: if set, messages will fade out and be removed after this many milliseconds (default: 0 = no auto-removal)
const showtime = urlParams.has("showtime") ? parseInt(urlParams.get("showtime")) : 0;

const SHOW_PLATFORM_PILL = true;
const SHOW_DONATION_PILL = true;

function safeText(str) {
if (str === undefined || str === null) return "";
return String(str);
}
function escapeHTML(str) {
return safeText(str)
.replace(/&/g, "&amp;")
.replace(/</g, "&lt;")
.replace(/>/g, "&gt;")
.replace(/"/g, "&quot;")
.replace(/'/g, "&#039;");
}

/**
 * Escapes only what is needed for safely injecting plain text into an element's innerHTML.
 * Note: We intentionally DO NOT escape apostrophes/quotes so words like "don't" render normally.
 * Apostrophes/quotes are only required to be escaped inside HTML attributes.
 */
function escapeTextHTML(str) {
  return safeText(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}


/**
 * Decode HTML entities coming from upstream (SSN often sends already-escaped text like &amp; / &lt; / &#039;).
 * We decode up to 2 passes to handle double-escaped sequences like &amp;#039;.
 * This is safe here because we still run the allowlist sanitizer before rendering any HTML tags.
 */
function decodeEntitiesDeep(input) {
  const s0 = safeText(input);
  if (!s0) return "";
  const ta = document.createElement("textarea");
  let s = s0;
  for (let i = 0; i < 2; i++) {
    ta.innerHTML = s;
    const decoded = ta.value;
    if (decoded === s) break;
    s = decoded;
  }
  return s;
}
function sanitizeChatHTML(input) {
  if (input === undefined || input === null) return "";

  // Decode upstream HTML entities (SSN may pre-escape text)
  const decoded = decodeEntitiesDeep(String(input));

  // If it doesn't contain any tag openers, render as plain text safely.
  if (!decoded.includes("<")) return escapeTextHTML(decoded);

  // Only treat as HTML if it looks like tags we intentionally allow.
  // This prevents plain text like "<3" from being interpreted as an HTML tag.
  const looksLikeAllowedHTML = /<(img|span|br)\b|<\/\s*(span)\s*>/i.test(decoded);
  if (!looksLikeAllowedHTML) return escapeTextHTML(decoded);

  try {
    const template = document.createElement("template");
    template.innerHTML = decoded;

    const allowedImgAttrs = new Set(["src", "srcset", "alt", "title", "class"]);
    const isSafeUrl = (u) => {
      if (!u) return false;
      const raw = String(u).trim();

      // Block javascript: and other executable schemes
      if (/^\s*javascript:/i.test(raw)) return false;

      // Allow data: (some emoji/emotes may be inlined)
      if (/^\s*data:/i.test(raw)) return true;

      // Support protocol-relative URLs ("//cdn...")
      const normalized = raw.startsWith("//") ? ("https:" + raw) : raw;

      // Must be http(s)
      if (!/^\s*https?:/i.test(normalized)) return false;

      // srcset may contain multiple entries: "url 1x, url 2x"
      const candidates = normalized.split(",").map(s => s.trim()).filter(Boolean);

      const hostAllowed = (host) => {
        const h = (host || "").toLowerCase();
        // Twitch default emotes
        if (h === "static-cdn.jtvnw.net" || h.endsWith(".jtvnw.net")) return true;
        // BTTV
        if (h === "cdn.betterttv.net" || h.endsWith(".betterttv.net")) return true;
        // 7TV
        if (h === "cdn.7tv.app" || h.endsWith(".7tv.app")) return true;
        // FFZ
        if (h === "cdn.frankerfacez.com" || h.endsWith(".frankerfacez.com")) return true;
        return false;
      };

      for (const c of candidates) {
        const urlPart = c.split(/\s+/)[0];
        try {
          const url = new URL(urlPart);
          if (!hostAllowed(url.hostname)) return false;
        } catch (e) {
          return false;
        }
      }
      return true;
    };

    const cleanNode = (node) => {
      // Text
      if (node.nodeType === Node.TEXT_NODE) {
        // Decode entities inside text nodes too (handles cases like "&amp;" inside spans)
        return document.createTextNode(decodeEntitiesDeep(node.nodeValue || ""));
      }

      // Element
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tag = (node.tagName || "").toLowerCase();

        // Allow emote <img> (Twitch/BTTV/7TV/FFZ)
        if (tag === "img") {
          const img = document.createElement("img");
          for (const attr of allowedImgAttrs) {
            if (!node.hasAttribute(attr)) continue;
            const val = node.getAttribute(attr) || "";
            if ((attr === "src" || attr === "srcset") && !isSafeUrl(val)) continue;
            img.setAttribute(attr, val);
          }
          // Hard block any event handlers (extra safety)
          [...img.attributes].forEach((a) => {
            if (/^on/i.test(a.name)) img.removeAttribute(a.name);
          });
          return img;
        }

        // Allow line breaks
        if (tag === "br") return document.createElement("br");

        // Allow <span> but preserve only class
        if (tag === "span") {
          const span = document.createElement("span");
          if (node.hasAttribute("class")) span.setAttribute("class", node.getAttribute("class"));
          node.childNodes.forEach((c) => span.appendChild(cleanNode(c)));
          return span;
        }

        // Drop all other tags but keep their text/emote children
        const frag = document.createDocumentFragment();
        node.childNodes.forEach((c) => frag.appendChild(cleanNode(c)));
        return frag;
      }

      // Comments/others â†’ drop
      return document.createTextNode("");
    };

    const out = document.createElement("div");
    template.content.childNodes.forEach((n) => out.appendChild(cleanNode(n)));
    return out.innerHTML;
  } catch (e) {
    return escapeTextHTML(decoded);
  }
}

function normalizePlatform(type) {
const t = safeText(type).toLowerCase().trim();
if (!t) return "";
if (t.includes("twitch")) return "Twitch";
if (t.includes("youtube")) return "YouTube";
if (t.includes("kick")) return "Kick";
if (t.includes("facebook")) return "Facebook";
if (t.includes("tiktok")) return "TikTok";
if (t.includes("discord")) return "Discord";
return t.charAt(0).toUpperCase() + t.slice(1);
}


/**
 * Emoji baseline correction: wraps unicode emoji sequences in <span class="emojiChar">â€¦</span>
 * so we can nudge baseline consistently across Apple Color Emoji vs Noto.
 */
function fixEmojiBaseline(el){
  if (!el) return;

  const emojiRe = /(\p{Extended_Pictographic}(?:\uFE0F|\uFE0E)?(?:\u200D\p{Extended_Pictographic}(?:\uFE0F|\uFE0E)?)*)/gu;

  const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
    acceptNode: (node) => {
      if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
      if (!node.nodeValue.match(/\S/)) return NodeFilter.FILTER_REJECT;
      emojiRe.lastIndex = 0;
      return emojiRe.test(node.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    }
  });

  const targets = [];
  while (walker.nextNode()) targets.push(walker.currentNode);

  for (const textNode of targets){
    const text = textNode.nodeValue || "";
    emojiRe.lastIndex = 0;

    const frag = document.createDocumentFragment();
    let last = 0;
    for (const m of text.matchAll(emojiRe)){
      const i = m.index ?? 0;
      const emoji = m[0];

      if (i > last) frag.appendChild(document.createTextNode(text.slice(last, i)));

      const span = document.createElement("span");
      span.className = "emojiChar";
      span.textContent = emoji;
      frag.appendChild(span);

      last = i + emoji.length;
    }
    if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));

    textNode.parentNode.replaceChild(frag, textNode);
  }
}

function createMessageNode(data) {
const wrap = document.createElement("div");
wrap.className = "msg";

const isDonation = !!data.hasDonation;
if (isDonation) wrap.classList.add("is-donation");

const avatarUrl = safeText(data.chatimg);
const name = safeText(data.chatname) || "Unknown";
const msg = safeText(data.chatmessage) || "";
const platform = normalizePlatform(data.type);
const donationValue = safeText(data.hasDonation);

wrap.innerHTML = `
       <div class="bar"></div>

       <div class="avatar">
         ${avatarUrl ? `<img alt="" src="${escapeHTML(avatarUrl)}" />` : ""}
       </div>

       <div class="content">
         <div class="topline">
           <div class="name" title="${escapeHTML(name)}">${escapeHTML(name)}</div>
           <div class="meta">
             ${SHOW_PLATFORM_PILL && platform ? `<span class="pill">${escapeHTML(platform)}</span>` : ""}
             ${SHOW_DONATION_PILL && donationValue ? `<span class="pill donation">ðŸ’– ${escapeHTML(donationValue)}</span>` : ""}
           </div>
         </div>

          <div class="message">${sanitizeChatHTML(msg)}</div>

         ${data.contentimg ? `
           <div class="media">
             ${String(data.contentimg).match(/\.(mp4|webm|ogg)(\?.*)?$/i)
           ? `<video src="${escapeHTML(data.contentimg)}" autoplay muted loop playsinline></video>`
           : `<img alt="" src="${escapeHTML(data.contentimg)}" />`
         }
           </div>
         ` : ""}
       </div>
     `;
return wrap;
}

function addMessage(data) {
const chat = document.getElementById("chatList");
const node = createMessageNode(data);
chat.appendChild(node);
// baseline-fix unicode emoji after sanitize/insert
fixEmojiBaseline(node.querySelector('.message'));

// If showtime is set, fade out and remove the message after the specified time
if (showtime > 0) {
setTimeout(() => {
node.classList.add('fading');
setTimeout(() => {
if (node.parentNode) {
node.parentNode.removeChild(node);
}
}, 1000); // Remove after fade animation completes
}, showtime);
}
}

function processData(data) {
if (!data) return;
if (data.content) data = data.content;
if (data.chatmessage) addMessage(data);
}

const iframe = document.createElement("iframe");
const filename = "dock";
const password = urlParams.get('password') || 'false';
const lanonly = urlParams.has('lanonly') ? '&lanonly' : '';
iframe.src =
"https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&notmobile&password=" +
encodeURIComponent(password) +
lanonly +
"&solo&view=" +
urlParams.get('session') +
"&novideo&noaudio&label=" +
filename +
"&cleanoutput&room=" +
urlParams.get('session');

iframe.style.width = "0px";
iframe.style.height = "0px";
iframe.style.position = "fixed";
iframe.style.left = "-100px";
iframe.style.top = "-100px";
iframe.id = "frame1";
document.body.appendChild(iframe);

const eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
const eventer = window[eventMethod];
const messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";

eventer(messageEvent, function (e) {
if (e.source !== iframe.contentWindow) return;
if ("dataReceived" in e.data) {
if ("overlayNinja" in e.data.dataReceived) {
processData(e.data.dataReceived.overlayNinja);
}
}
});
</script>

<!-- BOKEH SCRIPT -->
<script type="module">
function blockRealPointer(e) {
if (e._synthetic) return;
e.stopImmediatePropagation();
e.preventDefault();
}
window.addEventListener('mousemove', blockRealPointer, true);
window.addEventListener('pointermove', blockRealPointer, true);
document.addEventListener('mousemove', blockRealPointer, true);
document.addEventListener('pointermove', blockRealPointer, true);

(async () => {
const { Bokeh1Background } = await import(
'https://cdn.jsdelivr.net/npm/threejs-components@0.0.2/build/backgrounds/bokeh1.cdn.min.js'
);

const canvas = document.getElementById('webgl-canvas');
const bokeh1Background = Bokeh1Background(canvas);

bokeh1Background.loadMap(
'https://cdn.jsdelivr.net/npm/threejs-components@0.0.2/build/assets/bokeh-particles2.png'
);

bokeh1Background.setColors([0x6c89fd, 0xfa6d47, 0x363753]);

let t = 0;
function autoDrift() {
t += 0.0014;

const w = window.innerWidth || 1920;
const h = window.innerHeight || 1080;

const cx = w / 2;
const cy = h / 2;

const ampX = w * 0.32;
const ampY = h * 0.22;

const x = cx + Math.cos(t * 1.0) * ampX;
const y = cy + Math.sin(t * 1.2) * ampY;

const mouseEvent = new MouseEvent('mousemove', {
clientX: x, clientY: y, bubbles: true, cancelable: true, view: window
});
mouseEvent._synthetic = true;

const pointerEvent = new PointerEvent('pointermove', {
clientX: x, clientY: y, bubbles: true, cancelable: true, view: window, pointerType: 'mouse'
});
pointerEvent._synthetic = true;

window.dispatchEvent(mouseEvent);
window.dispatchEvent(pointerEvent);

requestAnimationFrame(autoDrift);
}
autoDrift();
})();
</script>
</body>
