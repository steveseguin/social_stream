<html>
<head>
	<title>Social Stream Ninja</title>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
	<meta content="utf-8" http-equiv="encoding" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes"/>
	<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:; worker-src 'self' 'unsafe-inline' 'unsafe-eval' blob:;"/>
	<link rel="stylesheet" href="https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="main.css" />
    <script>
        window.SSAPP_DEBUG_LOGS = Boolean(window.SSAPP_DEBUG_LOGS);
        (function() {
            const filterTokens = [
                'Potential permissions policy violation',
                'Unrecognized feature'
            ];

            function shouldSuppress(args) {
                try {
                    const message = args.map(part => {
                        if (typeof part === 'string') return part;
                        if (part instanceof Error && part.message) return part.message;
                        return JSON.stringify(part);
                    }).join(' ');
                    return filterTokens.some(token => message.includes(token));
                } catch (_) {
                    return false;
                }
            }

            ['warn', 'error', 'info', 'log'].forEach(method => {
                const original = console[method]?.bind(console);
                if (!original) return;
                console[method] = function(...args) {
                    if (shouldSuppress(args)) return;
                    return original(...args);
                };
            });
        })();
    </script>
	<style>
		.session-item {
			padding: 10px 15px;
			margin: 5px 0;
			border-radius: 6px;
			cursor: pointer;
			display: flex;
			justify-content: space-between;
			align-items: center;
			background: rgba(255, 255, 255, 0.05);
			transition: all 0.2s ease;
		}
		
		.session-item:hover {
			background: rgba(255, 255, 255, 0.1);
		}
		
		.session-item.selected {
			background: rgba(76, 175, 80, 0.3);
			border: 1px solid rgba(76, 175, 80, 0.6);
		}
		
		.session-item-name {
			font-weight: 500;
		}
		
		.session-item-actions {
			display: flex;
			gap: 10px;
			align-items: center;
		}
		
		.session-remove-btn {
			background: transparent;
			border: none;
			color: #e74c3c;
			cursor: pointer;
			padding: 5px;
			font-size: 16px;
			opacity: 0.7;
			transition: opacity 0.2s;
		}
		
		.session-remove-btn:hover {
			opacity: 1;
		}
		
		.session-remove-btn:disabled {
			opacity: 0.3;
			cursor: not-allowed;
		}
	</style>
</head>
<body>
    <nav id="main-navigation">
        <button class="menu-toggle" onclick="toggleMenu()">☰</button>
        <ul>
            <li><a href="#" data-page="streams">🎭 Sources and Settings</a></li>
			<li><a href="#" data-page="dashboard">📰 Status and Logs</a></li>
            <li><a href="#" data-page="event-flow-editor">🪤 Event Flow Editor</a></li>
			<li><a href="#" data-page="vdo-ninja">🎦 Remote Camera Feed</a></li>
			<li><a href="#" data-page="sessions">🧑‍🤝‍🧑 Sessions</a></li>
            </ul>
            <div class="language-selector">
                <select id="language-select" onchange="changeLanguage(this.value)">
                    <option value="en">🇺🇸 English</option>
                    <option value="pt-BR">🇧🇷 Português (Brasil)</option>
                    <option value="es">🇪🇸 Español</option>
                    <option value="fr">🇫🇷 Français</option>
                    <option value="de">🇩🇪 Deutsch</option>
                    <option value="cs">🇨🇿 Čeština</option>
                    <option value="it">🇮🇹 Italiano</option>
                    <option value="ja">🇯🇵 日本語</option>
                    <option value="zh">🇨🇳 中文</option>
                    <option value="ko">🇰🇷 한국어</option>
                    <option value="ru">🇷🇺 Русский</option>
                    <option value="tr">🇹🇷 Türkçe</option>
                </select>
            </div>
    </nav>

    <main id="content-pane">
        <div id="streams-page">
            <div class="addnew">
                <p data-i18n="source.add">Add a new source:</p>
                <span><button onclick="newSourcePrompt('youtube');" data-source-type="youtube-username"><img src="https://socialstream.ninja/sources/images/youtube.png" class="icon"/>YouTube Username</button></span>
                <span><button onclick="newSourceVideoIDPrompt('youtube');" data-source-type="youtube-videoid"><img src="https://socialstream.ninja/sources/images/youtube.png" class="icon"/>YouTube Video ID</button></span>
                <span><button onclick="newSourcePrompt('twitch');" data-source-type="twitch"><img src="https://socialstream.ninja/sources/images/twitch.png" class="icon"/>Twitch Username</button></span>
                <span><button onclick="newSourcePrompt('kick');" data-source-type="kick"><img src="https://socialstream.ninja/sources/images/kick.png" class="icon"/>Kick Username</button></span>
                <span><button onclick="newSourcePrompt('instagramlive');" data-source-type="instagram"><img src="https://socialstream.ninja/sources/images/instagramlive.png" class="icon"/>Instagramlive Username</button></span>
                <span><button onclick="newSourcePrompt('facebook');" data-source-type="facebook"><img src="https://socialstream.ninja/sources/images/facebook.png" class="icon"/>Facebook Username</button></span>
                <span><button onclick="newSourcePrompt('tiktok');" data-source-type="tiktok"><img src="https://socialstream.ninja/sources/images/tiktok.png" class="icon"/>tiktok Username</button></span>
                <span><button onclick="newSourcePrompt('trovo');"><img src="https://socialstream.ninja/sources/images/trovo.png" class="icon"/>trovo Username</button></span>
                <span><button onclick="newSourcePrompt('picarto');"><img src="https://socialstream.ninja/sources/images/picarto.png" class="icon"/>picarto Username</button></span>
                <span><button onclick="newSourcePrompt('dlive');"><img src="https://socialstream.ninja/sources/images/dlive.png" class="icon"/>dlive Username</button></span>
                <span><button onclick="newSourcePrompt('x');"><img src="https://socialstream.ninja/sources/images/x.png" class="icon"/>X.com Username</button></span>
                <span><button onclick="newSourcePrompt('rumble');"><img src="https://socialstream.ninja/sources/images/rumble.png" class="icon"/>Rumble Username</button></span>
                <span><button onclick="newSourceVideoIDPrompt('rumble');"><img src="https://socialstream.ninja/sources/images/rumble.png" class="icon"/>Rumble Video URL</button></span>
                <span><button onclick="newSourcePrompt('beamstream');"><img src="https://socialstream.ninja/sources/images/beamstream.png" class="icon"/>Beamstream Username</button></span>
                <span><button onclick="newSourcePrompt('parti');"><img src="https://socialstream.ninja/sources/images/parti.png" class="icon"/>Parti User ID</button></span>
				<span><button onclick="newSourcePrompt('arenasocial');"><img src="https://socialstream.ninja/sources/images/arenasocial.png" class="icon"/>Arena Social Username</button></span>
                <span class="hidden"><button onclick="newSourcePrompt('pilled');"><img src="https://socialstream.ninja/sources/images/pilled.png" class="icon"/>Pilled Username</button></span>
                <span><button onclick="newSourcePrompt('bilibili');"><img src="https://socialstream.ninja/sources/images/bilibili.png" class="icon"/>BiliBili Stream ID</button></span>
                <span><button onclick="newOtherSourcePrompt('peertube');"><img src="https://socialstream.ninja/sources/images/peertube.png" class="icon"/>Peertube URL</button></span>
                <span><button title="Add a chat source that isn't listed by providing the chat URL" onclick="newOtherSourcePrompt();" data-source-type="other"><img src="https://socialstream.ninja/sources/images/unknown.png" class="icon"/>Other chat sites</button></span>
            </div>

            <div id="sources" style="right:calc(max(35%, 400px))">
                <h2 style="margin: 10px;" data-i18n="app.title">Social Stream Ninja Standalone</h2>
                <span id='newver' class='hidden'>
                    <h1 data-i18n="app.newversion">NEW VERSION AVAILABLE</h1>
                    <a id="downloadlink" data-i18n="app.download">Download new version here</a>
                </span>
                <p style="margin: 0 0 15px 10px; color: #9d8c8c;">Added Sources:</p>
            </div>
			
			<div id="link-overlay-page" style="min-width:400px;right:0;position:absolute;height:100%;width:35%">
				<!-- Subtle edge handle to collapse/expand the popup sidebar -->
				<div id="popup-handle" class="overlay-handle" role="button" tabindex="0" aria-label="Toggle chat panel" title="Hide/Show chat panel">⯇</div>
				<iframe id="frame1" class="loading" style="height:100%;width:100%" allow="autoplay *; camera *; clipboard-write *; encrypted-media *; fullscreen *; geolocation *; microphone *; midi *; usb *"></iframe>
			</div>
        </div>

        <div id="dashboard-page" style="display:none;">
			<iframe id="frame2" class="loading" style="height:100%;width:100%" aria-hidden="true" allow="autoplay *; camera *; clipboard-write *; encrypted-media *; fullscreen *; geolocation *; microphone *; midi *; usb *" title="Background Service Loader"></iframe>
        </div>
			
		<div id="vdo-ninja-page" style="display:none;">
			<iframe id="frame3" class="loading" style="height:100%;width:100%" allow="autoplay *; camera *; clipboard-write *; encrypted-media *; fullscreen *; geolocation *; microphone *; midi *; usb *"></iframe>
        </div>
		
		<div id="sessions-page" style="display:none;">
			<div class="sessions-container">
				<h2 data-i18n="sessions.title">User Sessions</h2>
				<p class="sessions-info" data-i18n="sessions.info">Manage multiple user profiles with separate settings and sources.</p>
				
				<div class="current-session-info">
					<h3 data-i18n="sessions.current">Current Session</h3>
					<div class="session-display">
						<span class="session-name" id="current-session-name">Default Session</span>
						<span class="session-label" data-i18n="sessions.active">Active</span>
					</div>
				</div>
				
				<div class="sessions-list">
					<h3 data-i18n="sessions.available">Available Sessions</h3>
					<div id="sessions-list-container">
						<!-- Sessions will be populated here -->
					</div>
					<button class="new-session-btn" onclick="createNewSession()" data-i18n="sessions.create">
						➕ Create New Session
					</button>
					<div class="session-import-export">
						<button class="export-session-btn" onclick="exportCurrentSession()" data-i18n="sessions.export">
							💾 Export Current Session
						</button>
						<button class="import-session-btn" onclick="importSession()" data-i18n="sessions.import">
							📂 Import Session
						</button>
					</div>
				</div>
				
				<div class="session-warnings">
					<p>ℹ️ <strong>Note:</strong> The "Default Session (Original)" contains all your existing sources and settings.</p>
					<p>🔄 <strong>Switching:</strong> Changing sessions will restart the application.</p>
					<p>⚠️ <strong>Important:</strong> Each session has completely separate settings, sources, and stored data.</p>
				</div>
			</div>
		</div>
			
	</main>

    <div id="sourceTemplate" class="hidden entry">
        <img data-sourceicon />
        <span>
            <div class="title-row" style="display: flex; align-items: center; justify-content: space-between; gap: 10px; width: 100%;">
                <div class="title-left" style="display: flex; align-items: baseline; gap: 8px; min-width: 0;">
                    <span data-channelname></span>
                    <span data-sourcename></span>
                </div>
                <div class="badges" style="display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
                    <span data-replyonly-badge style="display: none; font-size: 11px; padding: 2px 6px; border-radius: 10px; background: rgba(255,255,255,0.12); color: #fff;">
                        📨 Reply only
                    </span>
                    <span data-session-badge style="font-size: 11px; padding: 2px 6px; border-radius: 10px; background: rgba(255,255,255,0.08); color: #ddd;">
                        Session: AUTO
                    </span>
                </div>
            </div>
            <input data-sourceurl disabled class="white hidden" />
        </span>

		<div class="control-panel">
			<div class="auto-activate-toggle">
				<div class="toggle-switch-container">
					<label class="toggle-switch">
						<input type="checkbox" data-state-key="autoActivate">
						<span class="slider"></span>
					</label>
					<span class="toggle-label">Auto-activate on startup</span>
				</div>
			</div>
		</div>

		<span class='ws-status hidden'>Websocket Activated</span>

		<div class="entry-actions-main">
			<button onclick="activateSource(this)" data-activatehtml>▶️ Activate source</button>
			<button onclick="signin(this)" title="Sign-in friendly compatible page" data-signin>🔑 Sign-in</button>
			<button onclick="showTips(this)" title="Show tips for this platform" class="hidden help-btn" data-showtips>❓ Help!</button>
		</div>

		<div class="entry-actions-live">
			<button onclick="refreshWindow(this)" title="Reload this source" data-reloadhtml class="hidden icon-button">🔄</button>
			<button onclick="toggleSourceVisibility(this)" title="Toggle the visibility of this source" data-togglehtml class="hidden icon-button">👁️</button>
			<button onclick="toggleSourceMute(this)" title="Pause/mute the video in this source" data-togglemute class="hidden icon-button">🔇</button>
			<button onclick="stopThis(this)" title="Stop and close this source" data-stophtml class="hidden icon-button">⏹️</button>
		</div>

		<button title="Additional settings for this source" class="settings-btn button">⚙️</button>
        <div class="settings-menu">
            <div class="settings-menu-section">
                <div class="settings-menu-header">Additional Controls</div>
                <div class="settings-menu-item" onclick="clearThis(this)" data-clearcache>
                    🧹 Clear cache & storage
                </div>
                <div class="settings-menu-item" onclick="toggleReplyOnly(this)" data-reply-only>
                    🤖 Bot reply-only (no capture)
                </div>
                <div class="settings-menu-item" onclick="toggleTikTokAutoFallback(this)" data-tiktok-fallback>
                    🔁 TikTok auto-fallback enabled
                </div>
                <div class="settings-menu-item youtube-type-toggle hidden" onclick="toggleYouTubeType(this)">
                    🔄 Switch to <span class="toggle-type-text">YouTube</span>
                </div>
                <div class="settings-menu-item" onclick="openUserAgentSettings(this)">
                    🌐 User Agent Settings
                </div>
                <div class="settings-menu-item" onclick="openSessionSettings(this)">
                    🔐 Browser Session Settings
                </div>
                </div>
            <div class="settings-menu-section">
                <div class="settings-menu-header">Source Management</div>
                <div class="settings-menu-item" data-move="up" onclick="moveSourceUp(this)">⬆️ Move up</div>
                <div class="settings-menu-item" data-move="down" onclick="moveSourceDown(this)">⬇️ Move down</div>
                <div class="settings-menu-item danger" onclick="deleteThis(this)">
                    🗑️ Remove source
                </div>
            </div>
        </div>
	</div>

    <div id="groupTemplate" class="hidden entry" data-is-group-header="true">
        <img data-sourceicon />
        <span>
            <div>
                <span data-channelname></span>
                <span data-targetname style="font-size: 0.8em; opacity: 0.7;"></span>
            </div>
        </span>
        <div class="control-panel">
             <div class="auto-activate-toggle">
				<div class="toggle-switch-container">
					<label class="toggle-switch">
						<input type="checkbox" data-state-key="autoActivate">
						<span class="slider"></span>
					</label>
					<span class="toggle-label">Auto-activate group</span>
				</div>
			</div>
        </div>
        <div class="button-group">
            <button onclick="handleYouTubeGroupActivationPrompt(this)">Select Live Sources</button>
            <button onclick="handleYouTubeGroupAutoActivation(this)">Auto-find & Activate</button>
            <button class="hidden" data-signin data-group-signin title="Open a sign-in window for this group's browser session." onclick="signin(this)">🔑 Sign-in</button>
        </div>
         <div class="group-actions">
            <button class="group-control" title="Toggle All Streams Visibility" onclick="toggleGroupVisibility(this)">👁️</button>
            <button class="group-control" title="Toggle All Streams Mute" onclick="toggleGroupMute(this)">🔊</button>
            <button class="group-control" title="Stop All Streams" onclick="stopAllStreamsInGroup(this)">⏹️</button>
            <button class="group-control" title="Reload All Streams" onclick="reloadAllStreamsInGroup(this)">🔄</button>
            <button title="Additional settings for this group" class="settings-btn button">⚙️</button>
            <div class="settings-menu">
                <div class="settings-menu-section">
                    <div class="settings-menu-header">Group Management</div>
                    <div class="settings-menu-item" data-group-move="up" onclick="moveGroupUp(this)">⬆️ Move group up</div>
                    <div class="settings-menu-item" data-group-move="down" onclick="moveGroupDown(this)">⬇️ Move group down</div>
                    <div class="settings-menu-item danger" onclick="deleteThis(this)">
                        🗑️ Remove group & its sources
                    </div>
                </div>
            </div>
        </div>
        <div class="stream-group">
            </div>
    </div>


    <div id="tipsModal" class="modal hidden">
        <div class="modal-content tips-modal-content">
            <h2 id="tipsModalTitle">Tips</h2>
            <div id="tipsModalContent"></div>
            <button class="btn-primary" onclick="closeTipsModal()">Close</button>
        </div>
    </div>

    <div class="modal hidden" id="modal">
        <div class="modal-content">
            <h2>Unknown site or site not supported</h2>
            If the URL provided is for a custom domain, please select which source type is to be used:
            <select data-type="dropdown">
                <option value="option1">Option 1</option>
                <option value="option2">Option 2</option>
                <option value="option3">Option 3</option>
                </select>
            <button data-type="submit">Select</button><button data-type="cancel">Cancel</button>
        </div>
    </div>

    <div class="yt-stream-modal" style="display:none;" id="ytStreamModal">
        <div class="yt-stream-modal-content"> 
            <span class="yt-stream-close">×</span>
            <h2>Available Live Streams</h2>
            <div class="yt-stream-list" id="ytStreamList"></div>
            <div class="yt-stream-buttons">
                <button class="yt-stream-button secondary" id="ytCancelButton">Cancel</button>
                <button class="yt-stream-button primary" id="ytActivateButton">Activate Selected</button>
            </div>
        </div>
    </div>
    
    <!-- User Agent Settings Modal -->
    <div class="modal hidden" id="userAgentModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>User Agent Settings</h2>
            <div style="margin-bottom: 20px;">
                <label for="userAgentSelect" style="display: block; margin-bottom: 8px; font-weight: bold;">Select User Agent:</label>
                <select id="userAgentSelect" style="width: 100%; padding: 8px; margin-bottom: 10px;">
                    <option value="AUTO">AUTO (Use config file)</option>
                </select>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <input type="text" id="customUserAgentInput" placeholder="Enter custom user agent..." style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                    <button onclick="addCustomUserAgent()">Add</button>
                </div>
                <div id="customUserAgentsList" style="max-height: 200px; overflow-y: auto; margin-top: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 10px;"></div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeUserAgentModal()" style="background: #95a5a6;">Cancel</button>
                <button onclick="saveUserAgentSelection()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="modal hidden" id="sessionModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>Browser Session Settings</h2>
            <div style="margin-bottom: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select Browser Session:</label>
                    <small style="color: #ddd; display: block; margin-bottom: 10px;">Sessions allow you to be logged into different accounts on the same platform</small>
                </div>
                <div id="sessionsList" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 10px;">
                    <!-- Sessions will be populated here -->
                </div>
                <div style="margin-top: 15px;">
                    <label style="display: block; margin-bottom: 8px; color: #9d8c8c;">Create New Session:</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="customSessionName" placeholder="Session name (e.g., 'work-account')" style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                        <button onclick="addCustomSession()">Create</button>
                    </div>
                </div>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeSessionModal()" style="background: #95a5a6;">Cancel</button>
                <button onclick="saveSessionSelection()">Save</button>
            </div>
        </div>
    </div>
    
    <div class="toast-container" id="toastContainer"></div>
	
<script type="text/javascript" src="state.js"></script>
<script type="text/javascript" src="libs.js"></script>
<script type="text/javascript" src="manifest.js"></script>
<script type="text/javascript" src="thumbnail.js"></script>
<script type="text/javascript" src="youtube.js"></script>
<!-- Temporarily disabled performance monitor to fix loading issue -->
<!-- <script type="text/javascript" src="performance-monitor.js"></script> -->
<script>
var config = getDefaultConfig();
const APP_ACCEPT_LANGUAGE = window.SSAPP_ACCEPT_LANGUAGE || (window.ssappLocale && window.ssappLocale.acceptLanguage) || 'en-US,en;q=0.9';
window.SSAPP_ACCEPT_LANGUAGE = APP_ACCEPT_LANGUAGE;
let configReady = false;
const storedConfig = localStorage.getItem('config');
if (storedConfig) {
	try {
		config = JSON.parse(storedConfig);
	} catch (e) {
		console.warn("Failed to parse stored config, using default.");
		config = getDefaultConfig();
	}
}

var urlParams = new URLSearchParams(window.location.search);
var devmode = urlParams.has("devmode");
var sourcemode = urlParams.get("sourcemode") || false;
// Ensure sourcemode has file:// protocol if it's a local path
if (sourcemode && !sourcemode.startsWith('http') && !sourcemode.startsWith('file://')) {
    if (sourcemode.match(/^[A-Za-z]:\//)) {
        // Windows path
        sourcemode = `file:///${sourcemode}`;
    } else if (sourcemode.startsWith('/')) {
        // Unix path
        sourcemode = `file://${sourcemode}`;
    }
}
var isBetaMode = false;
const pendingTikTokStatusQueue = new Map();
var session = {};
var ipcRenderer = null;
let autoActivateCaptureEnsured = false;
const envForcesTikTokClassic = typeof process !== 'undefined' && process?.env?.SSAPP_FORCE_TIKTOK_CLASSIC === '1';
const cliForcesTikTokClassic = envForcesTikTokClassic;
let preferTikTokClassic = cliForcesTikTokClassic;
let lastTikTokMode = 'tiktok-websocket';
let tikTokClassicSilentUpdate = false;

// Check if contextBridge exposed electron API (for windows with contextIsolation: true)
if (window.electron && window.electron.ipcRenderer) {
    console.log('[Electron] Found electron API via contextBridge');
    ipcRenderer = window.electron.ipcRenderer;
}
var localServer = "";

if (ipcRenderer) {
    ipcRenderer.on('app:clear-all-sources', () => {
        try {
            clearAllSources();
        } catch (e) {
            console.error('Error clearing sources from menu command:', e);
        }
    });
}

// Universal IPC Promise Handler
class UniversalIPCHandler {
    constructor(defaultTimeout = 15000) {
        this.callbacks = new Map();
        this.defaultTimeout = defaultTimeout;
        this.nextId = 1;
        this.maxCallbacks = 100; // Prevent unlimited growth
        this.metrics = {
            sent: 0,
            completed: 0,
            failed: 0,
            timedOut: 0
        };
        
        // Single listener for ALL IPC responses
        if (ipcRenderer) {
            ipcRenderer.on('ipc-response', (event, data) => {
                this.handleResponse(data);
            });
        }
        
        // Periodic cleanup - more aggressive
        this.cleanupInterval = setInterval(() => this.cleanup(), 10000); // Every 10 seconds
    }
    
    // Send any IPC message with optional custom timeout
    async send(channel, data, options = {}) {
        if (!ipcRenderer) {
            throw new Error('IPC not available');
        }
        
        const timeout = options.timeout || this.defaultTimeout;
        
        return new Promise((resolve, reject) => {
            // Check if we've hit the callback limit
            if (this.callbacks.size >= this.maxCallbacks) {
                // Force cleanup of oldest callbacks
                this.forceCleanup();
                
                // If still at limit, reject
                if (this.callbacks.size >= this.maxCallbacks) {
                    this.metrics.failed++;
                    reject(new Error(`IPC callback limit reached (${this.maxCallbacks}). Too many pending requests.`));
                    return;
                }
            }
            
            const callbackId = `${channel}-${this.nextId++}-${Date.now()}`;
            
            const timeoutId = setTimeout(() => {
                const callback = this.callbacks.get(callbackId);
                if (callback) {
                    this.callbacks.delete(callbackId);
                    this.metrics.timedOut++;
                    reject(new Error(`IPC timeout: ${channel} after ${timeout}ms`));
                }
            }, timeout);
            
            this.callbacks.set(callbackId, {
                resolve,
                reject,
                timeoutId,
                channel,
                timestamp: Date.now()
            });
            
            this.metrics.sent++;
            
            // Send with metadata
            ipcRenderer.send('ipc-request', {
                channel,
                callbackId,
                data,
                timestamp: Date.now()
            });
        });
    }
    
    handleResponse(response) {
        const { callbackId, error, result } = response;
        const callback = this.callbacks.get(callbackId);
        
        if (callback) {
            clearTimeout(callback.timeoutId);
            this.callbacks.delete(callbackId);
            
            if (error) {
                this.metrics.failed++;
                callback.reject(new Error(error));
            } else {
                this.metrics.completed++;
                callback.resolve(result);
            }
            
            // Log slow responses
            const duration = Date.now() - callback.timestamp;
            if (duration > 1000) {
                console.warn(`Slow IPC response for ${callback.channel}: ${duration}ms`);
            }
        }
    }
    
    // Cleanup old callbacks
    cleanup() {
        const now = Date.now();
        let cleaned = 0;
        
        this.callbacks.forEach((callback, id) => {
            if (now - callback.timestamp > 30000) { // 30 seconds (reduced from 60)
                clearTimeout(callback.timeoutId);
                callback.reject(new Error('Callback expired during cleanup'));
                this.callbacks.delete(id);
                cleaned++;
            }
        });
        
        if (cleaned > 0) {
            console.log(`IPC cleanup: removed ${cleaned} expired callbacks`);
        }
    }
    
    forceCleanup() {
        // Remove oldest callbacks until we're under 75% of limit
        const targetSize = Math.floor(this.maxCallbacks * 0.75);
        const sortedCallbacks = Array.from(this.callbacks.entries())
            .sort((a, b) => a[1].timestamp - b[1].timestamp);
        
        let cleaned = 0;
        while (this.callbacks.size > targetSize && sortedCallbacks.length > 0) {
            const [id, callback] = sortedCallbacks.shift();
            clearTimeout(callback.timeoutId);
            callback.reject(new Error('Callback forcefully cleaned due to limit'));
            this.callbacks.delete(id);
            cleaned++;
        }
        
        if (cleaned > 0) {
            console.warn(`IPC force cleanup: removed ${cleaned} callbacks to prevent memory overflow`);
        }
    }
    
    // Retry capability
    async sendWithRetry(channel, data, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await this.send(channel, data);
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                console.log(`Retry ${i + 1}/${maxRetries} for ${channel}`);
                await new Promise(r => setTimeout(r, 1000 * (i + 1)));
            }
        }
    }
    
    // Cleanup all resources
    destroy() {
        // Clear the interval
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        
        // Clear all pending callbacks
        this.callbacks.forEach((callback, id) => {
            clearTimeout(callback.timeoutId);
            callback.reject(new Error('IPC handler destroyed'));
        });
        this.callbacks.clear();
        
        console.log('IPC handler destroyed, metrics:', this.metrics);
    }
    
    // Get metrics
    getMetrics() {
        return {
            ...this.metrics,
            pending: this.callbacks.size,
            successRate: this.metrics.sent > 0 
                ? ((this.metrics.completed / this.metrics.sent) * 100).toFixed(1) + '%'
                : '0%'
        };
    }
}

// Create global instance
window.ipc = new UniversalIPCHandler();

// Function to rewrite old Kick URLs to new format
function rewriteKickUrl(url) {
    // Check if it's an old Kick chatroom URL
    const oldKickPattern = /^https:\/\/kick\.com\/([^\/]+)\/chatroom$/;
    const match = url.match(oldKickPattern);
    
    if (match) {
        // Rewrite to new format
        const username = match[1];
        const newUrl = `https://kick.com/popout/${username}/chat`;
        console.log(`Rewriting old Kick URL: ${url} -> ${newUrl}`);
        return newUrl;
    }
    
    // Return original URL if no rewriting needed
    return url;
}

// Helper: should sign-in be disabled for this source based on config?
function isSigninDisabledForSource(source) {
    try {
        if (!source || !config) return false;
        const platform = source.target;
        const pconf = config[platform];
        if (!pconf) return false;
        // Support both boolean and object forms
        if (pconf.signin === false) return true;
        if (typeof pconf.signin === 'object' && pconf.signin && pconf.signin.enabled === false) return true;
        return false;
    } catch (e) { return false; }
}

// Apply disabled state and tooltip to a sign-in button
function applySigninPolicy(signinButton, source) {
    if (!signinButton || !source) return;
    const disabled = isSigninDisabledForSource(source);
    if (disabled) {
        signinButton.disabled = true;
        signinButton.title = 'Disabled: use Activate source to sign in';
        signinButton.style.cursor = 'not-allowed';
        // Show a helpful toast when clicked, instead of attempting real sign-in
        signinButton.onclick = function() {
            Toast.info('Sign-in Disabled', 'Use the ▶️ Activate source button to sign in for this platform.');
        };
    } else {
        signinButton.disabled = false;
        signinButton.style.cursor = '';
        // Do not override existing onclick assignments here
    }
}

function getEffectiveConnectionMode(source) {
    if (!source) return null;
    if (source.activeConnectionMode) return source.activeConnectionMode;
    return source.connectionMode || null;
}

// --- Core UI Update Functions ---
function updateSourceUI(element, source) {
    if (!element || !source) return;

    // Update data-target attribute
    element.dataset.target = source.target;
    
    element.querySelector("[data-sourceicon]").src = `https://socialstream.ninja/sources/images/${source.target || "unknown"}.png`;
    element.querySelector("[data-sourceicon]").title = source.target || "unknown";
    element.querySelector("[data-channelname]").textContent = source.username || "";
    element.querySelector("[data-sourcename]").textContent = source.videoId || "";
    const sourceUrlInput = element.querySelector("[data-sourceurl]");
    if (sourceUrlInput) {
        sourceUrlInput.value = source.url || "";
        sourceUrlInput.classList.toggle("hidden", !source.url);
    }
    
    if (tipsContent[source.target]) {
        element.querySelector("[data-showtips]")?.classList.remove("hidden");
    } else {
        element.querySelector("[data-showtips]")?.classList.add("hidden");
    }

    // Update badges: reply-only + session
    try {
        const roBadge = element.querySelector('[data-replyonly-badge]');
        if (roBadge) {
            const enabled = !!source.replyOnly;
            roBadge.style.display = enabled ? 'inline-block' : 'none';
            roBadge.textContent = '📨 Reply only';
            roBadge.title = 'Reply-only: it will not capture messages, but will still let you send them.\nChange via ⚙️ → Bot reply-only (no capture).';
        }
        const sessionBadge = element.querySelector('[data-session-badge]');
        if (sessionBadge) {
            const label = getSessionDisplayNameForSource(source);
            sessionBadge.textContent = `Session: ${label}`;
            sessionBadge.title = `Current browser session: ${label}.\nChange via ⚙️ → Browser Session Settings.`;
        }
    } catch (_) {}
    
    // Hide sign-in button when in websocket mode
    const effectiveMode = getEffectiveConnectionMode(source);

    const signinButton = element.querySelector("[data-signin]");
    if (signinButton) {
        const isWebsocketMode = effectiveMode === 'websocket' || 
                               effectiveMode === 'tiktok-websocket' || 
                               effectiveMode === 'tiktok-legacy';
        signinButton.classList.toggle("hidden", isWebsocketMode);
        applySigninPolicy(signinButton, source);
    }

    const visibilityControl = element.querySelector('[data-togglehtml]');
    if (visibilityControl) {
        visibilityControl.textContent = source.isVisible ? '👁️' : '🙈';
        // Show for regular WSS once a window exists (even while connecting); keep hidden for TikTok special mode
        const isTikTokApiMode = source.target === 'tiktok' && (effectiveMode === 'tiktok-websocket' || effectiveMode === 'tiktok-legacy');
        const showDuringConnect = (effectiveMode === 'websocket' && !!source.vid);
        const showWhenActive = (source.status === 'active' && !!source.vid);
        const hide = isTikTokApiMode || (!showDuringConnect && !showWhenActive);
        visibilityControl.classList.toggle('hidden', hide);
    }

    const muteControl = element.querySelector('[data-togglemute]');
    if (muteControl) {
        muteControl.textContent = source.isMuted ? '🔇' : '🔊';
        muteControl.classList.toggle('active', source.isMuted);
        // Hide only for TikTok websocket mode (which doesn't support mute)
        const isTikTokApiMode = source.target === 'tiktok' && (effectiveMode === 'tiktok-websocket' || effectiveMode === 'tiktok-legacy');
        muteControl.classList.toggle('hidden', isTikTokApiMode);
    }
    
    const autoActivateCheckbox = element.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = source.autoActivate || false;
        
        // Set up the change handler if not already set
        if (!autoActivateCheckbox.hasAttribute('data-handler-set')) {
            autoActivateCheckbox.setAttribute('data-handler-set', 'true');
            autoActivateCheckbox.onchange = () => {
                stateManager.updateSource(source.id, { autoActivate: autoActivateCheckbox.checked });
                
                // Start or stop auto-checking for Rumble sources
                if (source.target === 'rumble') {
                    if (autoActivateCheckbox.checked) {
                        startRumbleAutoCheck(source.id);
                    } else {
                        stopRumbleAutoCheck(source.id);
                        // Clear video ID and chat ID when auto-activate is turned off for username-based sources
                        if (source.username && (source.videoId || source.chatId)) {
                            stateManager.updateSource(source.id, { videoId: null, chatId: null, url: null });
                        }
                    }
                }
                // If user disables auto-activate while TikTok WSS is connecting/reconnecting, stop it
                if (!autoActivateCheckbox.checked) {
                    const latest = stateManager.getSource(source.id);
                    const isTikTokWss = latest && latest.target === 'tiktok' && (latest.connectionMode === 'tiktok-websocket' || latest.connectionMode === 'tiktok-legacy');
                    const isConnecting = latest && (latest.status === 'activating' || !!(element && element._tiktokRetryTimer));
                    if (isTikTokWss && isConnecting) {
                        const stopBtn = element.querySelector('[data-activatehtml]');
                        if (stopBtn) {
                            stopThis(stopBtn);
                        }
                    }
                }
            };
        }
    }

    const wsStatusElement = element.querySelector('.ws-status');
    if (source.connectionMode === 'websocket' || source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy') {
        if (source.status === 'active' && source.wssId) {
            updateConnectionStatus(element, 'connected');
        } else if (source.status === 'activating') {
            // Show connecting for supported WSS (YouTube/TikTok)
            const t = (source.target || '').toLowerCase();
            const supports = t === 'tiktok' || t.startsWith('youtube') || t === 'twitch';
            if (supports) updateConnectionStatus(element, 'connecting');
        } else if (source.status === 'inactive' && wsStatusElement && !wsStatusElement.classList.contains('error')) {
            updateConnectionStatus(element, 'clear');
        }
    } else {
         updateConnectionStatus(element, 'clear');
    }
    
    const activateButton = element.querySelector('[data-activatehtml]');
    const stopButton = element.querySelector('[data-stophtml]');
    const reloadButton = element.querySelector('[data-reloadhtml]'); 
    // If not actively connecting, ensure any transient "connecting" flag is cleared
    if (activateButton && source.status !== 'activating') {
        delete activateButton.dataset.connecting;
    }

    // While activating a regular WSS, allow stopping
    if ((source.connectionMode === 'websocket' || (source.target === 'tiktok' && (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy'))) && source.status === 'activating') {
        const stopButton = element.querySelector('[data-stophtml]');
        const reloadButton = element.querySelector('[data-reloadhtml]');
        setActivateButtonConnecting(element);
        stopButton?.classList.add('hidden');
        if (reloadButton) reloadButton.classList.add('hidden');
    } else if (source.status === 'active' && (source.vid || source.wssId)) {
        activateButton?.classList.add('hidden');
        stopButton?.classList.remove('hidden');
        
        // Hide reload button for TikTok websocket mode
        const isTikTokApiMode = source.target === 'tiktok' && (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy');
        if (reloadButton) {
            reloadButton.classList.toggle('hidden', isTikTokApiMode || !source.vid);
        }
        
        element.dataset.vid = source.vid; 
    } else {
        // Default inactive UI, but if a WSS window exists, allow closing it
        if (activateButton) activateButton.classList.remove('hidden');
        if (stopButton) stopButton.classList.add('hidden');
        if (reloadButton) reloadButton.classList.add('hidden');
        if (source.connectionMode === 'websocket' && source.vid) {
            // Window exists but not connected: present a Close action
            activateButton.textContent = '⏹️ Close WebSocket';
            activateButton.onclick = function() { stopThis(this); };
        } else {
            // Restore default activate label based on mode
            if (activateButton) {
                const mode = source.connectionMode || 'classic';
                if (mode === 'tiktok-websocket' && source.target === 'tiktok') {
                    activateButton.textContent = 'Connect TikTok WebSocket';
                } else if (mode === 'tiktok-legacy' && source.target === 'tiktok') {
                    activateButton.textContent = 'Connect TikTok Legacy';
                } else if (mode === 'websocket') {
                    activateButton.textContent = 'Connect WebSocket';
                } else {
                    activateButton.textContent = translate('btn.activate');
                }
                activateButton.onclick = function() { activateSource(this); };
            }
        }
        delete element.dataset.vid;
    }
    updateSourceUIAfterModeChange(element, source.connectionMode, (source.status === 'active'));
    
    // Show/hide YouTube type toggle based on source type and status
    const youtubeTypeToggle = element.querySelector('.youtube-type-toggle');
    if (youtubeTypeToggle) {
        if ((source.target === 'youtube' || source.target === 'youtubeshorts') && source.status !== 'active') {
            youtubeTypeToggle.classList.remove('hidden');
            const toggleText = youtubeTypeToggle.querySelector('.toggle-type-text');
            if (toggleText) {
                toggleText.textContent = source.target === 'youtube' ? 'YouTube Shorts' : 'YouTube';
            }
        } else {
            youtubeTypeToggle.classList.add('hidden');
        }
    }
}

function updateGroupUI(element, group) {
    if (!element || !group) return;

    element.querySelector("[data-sourceicon]").src = `https://socialstream.ninja/sources/images/${group.target || "unknown"}.png`;
    element.querySelector("[data-sourceicon]").title = group.target;
    element.querySelector("[data-channelname]").textContent = group.username || "";
    element.querySelector("[data-targetname]").textContent = group.target || "";

    const autoActivateCheckbox = element.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = group.autoActivate;
    }
    
    const groupSigninButton = element.querySelector('[data-group-signin]');
    if (groupSigninButton) {
        const isYouTubeGroup = group.target === 'youtube' || group.target === 'youtubeshorts';
        if (isYouTubeGroup) {
            const label = typeof translate === 'function' ? translate('btn.signin') : '🔑 Sign-in';
            groupSigninButton.textContent = label;
            groupSigninButton.classList.remove('hidden');
            groupSigninButton.classList.remove('authenticated');
            groupSigninButton.disabled = false;
            groupSigninButton.style.cursor = '';
            groupSigninButton.title = 'Open a sign-in window for this group\'s browser session.';
            groupSigninButton.onclick = function() { signin(this); };
            applySigninPolicy(groupSigninButton, group);
        } else {
            groupSigninButton.classList.add('hidden');
        }
    }
    
    const visibilityButton = element.querySelector('.group-actions button[title="Toggle All Streams Visibility"]');
    if (visibilityButton) {
        visibilityButton.textContent = group.groupVisible ? '👁️' : '🙈';
    }
    const muteButton = element.querySelector('.group-actions button[title="Toggle All Streams Mute"]');
    if (muteButton) {
        muteButton.textContent = group.groupMuted ? '🔇' : '🔊';
    }
    
    // Update the connection mode in the settings menu
    const settingsMenu = element.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.querySelectorAll('[data-action^="group-"]').forEach(item => {
            item.classList.remove('active');
        });
        const activeItem = settingsMenu.querySelector(`[data-action="group-${group.connectionMode || 'classic'}-mode"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
}


// --- Element Creation Functions ---
function createSourceElement(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source) {
        console.error("createSourceElement: Source not found in stateManager for ID:", sourceId);
        return null;
    }
    
    const ele = document.getElementById("sourceTemplate").cloneNode(true);
    ele.id = `source-${sourceId}`; 
    ele.dataset.sourceId = sourceId; 
    ele.dataset.target = source.target; 
    
    ele.classList.remove("hidden");
    
    updateSourceUI(ele, source);
    setupSourceControls(ele); 
    
    // Force mode selector to be visible for sources that support it
    const modeSelector = ele.querySelector('.mode-selector');
    if (modeSelector) {
        const target = source.target;
        // Check if platform supports websockets
        const hasWebSocketSupport = 
            target.startsWith('youtube') || 
            target === 'tiktok' ||
            (manifest?.content_scripts?.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            ) || false);
            
        if (hasWebSocketSupport) {
            modeSelector.classList.remove('hidden');
        }
    }

    return ele;
}

function createGroupElement(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group) {
        console.error("createGroupElement: Group not found in stateManager for ID:", groupId);
        return null;
    }

    const ele = document.getElementById("groupTemplate").cloneNode(true);
    ele.id = `group-${groupId}`; 
    ele.dataset.groupId = groupId; 
    ele.dataset.target = group.target; 
    ele.dataset.username = group.username; 

    ele.classList.remove("hidden");
    
    updateGroupUI(ele, group);
    setupGroupControls(ele); 

    const streamsContainer = ele.querySelector('.stream-group');
    if (streamsContainer) {
        console.log("Creating group element for:", groupId, "streams:", group.streams);
        group.streams.forEach(sourceId => {
            if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                console.log("Creating source element for stream:", sourceId);
                const sourceElement = createSourceElement(sourceId);
                if (sourceElement) {
                    console.log("Appending source element to group:", sourceId);
                    streamsContainer.appendChild(sourceElement);
                } else {
                    console.error("Failed to create source element for:", sourceId);
                }
            }
        });
    }
    return ele;
}

/* Modified createYouTubeEntry */
async function createYouTubeEntry(streamData, usernameForGroup, isShortSelected) {
    const target = isShortSelected ? 'youtubeshorts' : 'youtube';
    
    let group = stateManager.getGroups().find(g => g.username === usernameForGroup && g.target === target);
    let groupId = group ? group.id : null;

    if (!groupId) {
        console.warn(`Group for ${usernameForGroup} (${target}) not found. Creating now.`);
        groupId = stateManager.addGroup({ 
            target, 
            username: usernameForGroup, 
            // Only UC/HC/UU prefixes indicate a channel ID. @ is a handle, not necessarily a channel
            isChannel: (usernameForGroup.startsWith('UC') || usernameForGroup.startsWith('HC') || usernameForGroup.startsWith('UU')),
            autoActivate: false 
        });
        // The groupAdded listener will handle creating the group DOM element.
        // Wait for the DOM to potentially update.
        await Promise.resolve();
    }
    
    if (!groupId) {
         console.error("Cannot add YouTube entry: Failed to find or create a group ID for username:", usernameForGroup);
         return null;
    }
    const parentGroup = stateManager.getGroup(groupId);

    // Check if YouTube supports WebSockets
    let supportsWSS = false;
    if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }

    const sourceDataObject = {
        target: target,
        videoId: streamData.videoId,
        username: streamData.channelTitle || usernameForGroup,
        url: `https://www.youtube.com/live_chat?is_popout=1&v=${streamData.videoId}${isShortSelected ? '&shorts' : ''}`,
        isAutoDiscovered: true,
        groupId: groupId,
        title: streamData.title, 
        connectionMode: parentGroup?.connectionMode || 'classic',
        isVisible: parentGroup?.groupVisible !== undefined ? parentGroup.groupVisible : true,
        isMuted: parentGroup?.groupMuted !== undefined ? parentGroup.groupMuted : true,
        autoActivate: false,
        supportsWSS
    };

    const sourceId = stateManager.addSource(sourceDataObject);

    if (!sourceId) {
        console.error("Failed to add YouTube source to state manager for video ID:", streamData.videoId);
        return null;
    }
    

    // Instead of relying purely on the event listener, directly create and append if the listener hasn't already.
    // This makes it more robust for immediate activation needs.
    let sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
    if (!sourceElement) {
        console.log(`createYouTubeEntry: Element for ${sourceId} not found by listener, creating directly.`);
        sourceElement = createSourceElement(sourceId); // This function sets up UI and controls
        if (sourceElement) {
            const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
            const streamsContainer = groupElement?.querySelector('.stream-group');
            if (streamsContainer) {
                streamsContainer.appendChild(sourceElement);
            } else if (groupElement) {
                 console.warn("createYouTubeEntry: '.stream-group' not found, appending to group header for source:", sourceId);
                 groupElement.appendChild(sourceElement);
            } else {
                console.warn("createYouTubeEntry: Group element not found, appending to main #sources for source:", sourceId);
                document.getElementById("sources").appendChild(sourceElement);
            }
        }
    }
    
    if (!sourceElement) {
        console.error(`DOM element for YouTube source ID ${sourceId} could not be created or found.`);
        return null;
    }
    
    return sourceElement; 
}


async function newSourcePrompt(target) {
    let username = '';
    let isChannelName = false;
    let lastError = '';
    let lastInvalidToast = null;

    const spaceErrorMessage = 'Usernames cannot contain spaces. Please enter the username exactly as it appears on the platform.';
    const emptyErrorMessage = 'Please enter a username to continue.';

    while (true) {
        const errorType = lastError;
        const errorMessage = errorType === 'space' ? spaceErrorMessage : errorType === 'empty' ? emptyErrorMessage : '';
        lastError = '';

        let response;
        if (target === "facebook") {
            const messageParts = [];
            if (errorMessage) messageParts.push(errorMessage);
            messageParts.push("When you activate this source, you'll need to still manually select the video in the page.");
            const allowSpacesForChannel = (target === 'youtube' || target === 'youtubeshorts' || target === 'rumble') && isChannelName;
            if (allowSpacesForChannel) {
                messageParts.push('Channel names can include spaces when the channel option is enabled.');
            } else {
                messageParts.push('Note: Usernames cannot contain spaces.');
            }
            const promptOptions = {
                title: `Enter the ${target} user name`,
                message: messageParts.join('\n\n'),
                value: typeof username === 'string' ? username : '',
                errorMessage,
                errorType
            };
            response = window.prompt(promptOptions);
            isChannelName = false;
        } else if (target === "youtube" || target === "youtubeshorts") {
            const messageParts = [];
            if (errorMessage) messageParts.push(errorMessage);
            messageParts.push('If loading chat via username on Youtube, you must be live and the stream set to public for it to work.');
            const allowSpacesForChannel = (target === 'youtube' || target === 'youtubeshorts') && isChannelName;
            if (allowSpacesForChannel) {
                messageParts.push('Channel names can include spaces when the channel option is enabled.');
            } else {
                messageParts.push('Note: Usernames cannot contain spaces.');
            }
            response = await ipcRenderer.sendSync('prompt', {
                title: `Enter the ${target} user name or channel name`,
                message: messageParts.join('\n\n'),
                showChannelTypeCheckbox: true,
                showShortsCheckbox: (target === "youtubeshorts"),
                value: typeof username === 'string' ? username : '',
                defaultIsChannelName: isChannelName,
                errorMessage,
                errorType
            });
        } else if (target === "rumble") {
            const messageParts = [];
            if (errorMessage) messageParts.push(errorMessage);
            const allowSpacesForChannel = target === 'rumble' && isChannelName;
            if (allowSpacesForChannel) {
                messageParts.push('Channel names can include spaces when the channel option is enabled.');
            } else {
                messageParts.push('Note: Usernames cannot contain spaces.');
            }
            response = await ipcRenderer.sendSync('prompt', {
                title: `Enter the Rumble username or channel name`,
                message: messageParts.join('\n\n'),
                showChannelTypeCheckbox: true,
                value: typeof username === 'string' ? username : '',
                defaultIsChannelName: isChannelName,
                errorMessage,
                errorType
            });
        } else if (target === "parti") {
            const messageParts = [];
            if (errorMessage) messageParts.push(errorMessage);
            messageParts.push('This is a number which can be found at the end of the pop-out chat URL.');
            messageParts.push('Note: Usernames cannot contain spaces.');
            const promptOptions = {
                title: `Enter the ${target} user ID`,
                message: messageParts.join('\n\n'),
                value: typeof username === 'string' ? username : '',
                errorMessage,
                errorType
            };
            response = window.prompt(promptOptions);
            isChannelName = false;
        } else {
            const messageParts = [];
            if (errorMessage) messageParts.push(errorMessage);
            messageParts.push('Note: Usernames cannot contain spaces.');
            const promptOptions = {
                title: `Enter the ${target} user name`,
                message: messageParts.join('\n\n'),
                value: typeof username === 'string' ? username : '',
                errorMessage,
                errorType
            };
            response = window.prompt(promptOptions);
            isChannelName = false;
        }

        if (response === null || typeof response === 'undefined') {
            return;
        }

        let inputValue;
        if (response && typeof response === 'object' && 'value' in response) {
            inputValue = response.value;
            isChannelName = target === 'youtube' || target === 'youtubeshorts' || target === 'rumble'
                ? !!response.isChannelName
                : false;
        } else {
            inputValue = response;
            if (target === 'youtube' || target === 'youtubeshorts' || target === 'rumble') {
                isChannelName = false;
            }
        }

        if (inputValue === null || typeof inputValue === 'undefined') {
            lastError = 'empty';
            username = '';
            continue;
        }

        inputValue = `${inputValue}`;
        const trimmedInput = inputValue.trim();

        if (!trimmedInput) {
            lastError = 'empty';
            if (lastInvalidToast) {
                Toast.hide(lastInvalidToast);
                lastInvalidToast = null;
            }
            lastInvalidToast = Toast.warning('Missing Username', emptyErrorMessage);
            username = inputValue;
            continue;
        }

        const allowSpacesForChannel = (target === 'youtube' || target === 'youtubeshorts' || target === 'rumble') && isChannelName;
        if (/\s/.test(trimmedInput) && !allowSpacesForChannel) {
            lastError = 'space';
            if (lastInvalidToast) {
                Toast.hide(lastInvalidToast);
                lastInvalidToast = null;
            }
            lastInvalidToast = Toast.warning('Invalid Username', spaceErrorMessage);
            username = inputValue;
            continue;
        }

        username = trimmedInput;
        break;
    }

    if (lastInvalidToast) {
        Toast.hide(lastInvalidToast);
        lastInvalidToast = null;
    }

    // Clean up username - remove @ for platforms that don't use it
    // YouTube needs @ for handles, so we preserve it there
    if (target !== 'youtube' && target !== 'youtubeshorts') {
        username = username.replace(/^@+/, '').trim();
    }

    await newSource(target, username, false, {}, isChannelName);
}

async function newSourceVideoIDPrompt(targetPlatform) {
    let videoID, target = targetPlatform, isShorts = false;
    if (target === "youtube" || target === "youtubeshorts") {
        const response = await ipcRenderer.sendSync('prompt', {
            title: "Enter the YouTube video ID or URL",
            message: "Example: dQw4w9WgXcQ or https://youtube.com/watch?v=dQw4w9WgXcQ\nThe video must be already LIVE, and set to public or unlisted.",
            showShortsCheckbox: true
        });
        if (response && response.value) {
            const extracted = extractYoutubeID(response.value); 
            if (extracted) {
                videoID = extracted.id;
                isShorts = extracted.isShorts || response.isShorts; 
                target = isShorts ? "youtubeshorts" : "youtube";
            } else { 
                videoID = response.value;
                isShorts = response.isShorts;
                target = isShorts ? "youtubeshorts" : "youtube";
            }
        } else {
            return;
        }
    } else if (target === "rumble") {
        const input = window.prompt("Enter the Rumble video URL (e.g., https://rumble.com/a1b2c3d4-now-live.html):");
        if (input) { 
            // Check if it's a full Rumble URL and extract the video ID or full path
            const trimmedInput = input.trim();
            if (trimmedInput.includes('rumble.com/')) {
                try {
                    const url = new URL(trimmedInput);
                    const pathname = url.pathname;
                    
                    if (pathname.includes('/chat/popup/')) {
                        // Extract chat ID from popup URL
                        const chatIdMatch = pathname.match(/\/chat\/popup\/(\d+)/);
                        if (chatIdMatch && chatIdMatch[1]) {
                            videoID = chatIdMatch[1];
                        }
                    } else if (pathname.startsWith('/')) {
                        // Extract the full path (everything after the first /)
                        videoID = pathname.substring(1).replace(/\?.*$/, ''); // Remove query params
                    }
                } catch (e) {
                    // If URL parsing fails, try regex
                    const matches = trimmedInput.match(/rumble\.com\/([vp]\w+-[^?#]+)/);
                    if (matches && matches[1]) {
                        videoID = matches[1];
                    } else {
                        videoID = trimmedInput;
                    }
                }
            } else if (/^[vp]\w+$/.test(trimmedInput)) {
                // Just a video ID was entered - we can't use this alone
                alert("Please enter the full Rumble URL, not just the video ID.\n\nExample: https://rumble.com/v60552h-newsmax2-live.html");
                return;
            } else {
                videoID = trimmedInput;
            }
        } else { return; }
    } else { 
        const input = window.prompt("Enter the " + target + " video ID");
        videoID = input;
        if (!videoID) return;
    }

    if (videoID) {
       await newSourceVideoID(target, videoID.trim(), false, { isAutoDiscovered: false });
    }
}

async function cleanUpURL(url) {
	url = url.trim();
	
	// If it's already a chat popup URL, return it as-is
	if (url.startsWith("https://rumble.com/chat/popup/") || url.startsWith("http://rumble.com/chat/popup/")) {
		return url;
	}
	
	// For other Rumble URLs, try to fetch the chat ID
	if (url.startsWith("https://rumble.com/") || url.startsWith("http://rumble.com/")) {
		// Note: getRumbleVideoId actually returns the chat ID despite its name
		const chatId = await getRumbleVideoId(url);
		if (chatId) {
			return "https://rumble.com/chat/popup/" + chatId;
		}
	}
	
	return url;
}

async function newOtherSourcePrompt(target = "") {
    let URL = window.prompt("Enter the full URL for the source:");
    if (URL) {
        URL = URL.trim();
        // If no scheme provided, default to https://
        if (!/^https?:\/\//i.test(URL)) {
            URL = 'https://' + URL;
        }
        URL = (await cleanUpURL(URL)).trim(); 
        let typeGuess = target;
        if (!typeGuess) {
            const guessedArr = checkSupported(URL); 
            if (guessedArr.length) {
                if (guessedArr.length === 1) {
                    typeGuess = guessedArr[0].split(".js")[0].split("/").pop();
                } else { 
                    try {
                        const chosenScript = await customPrompt(guessedArr.map(g => `sources/${g}`)); 
                        typeGuess = chosenScript.split(".js")[0].split("/").pop();
                    } catch (e) { Toast.error("Cancelled adding source."); return; }
                }
            } else { 
                const allSources = manifest.content_scripts.map(dom => dom.js[0].split(".js")[0].split("/").pop()).filter(Boolean);
                try {
                    const chosenScript = await customPrompt(allSources.map(s => `sources/${s}.js`));
                     typeGuess = chosenScript.split(".js")[0].split("/").pop();
                } catch (e) { 
                    Toast.error("Cancelled adding source."); 
                    return; 
                }
            }
        }
        if (typeGuess === "youtube" && (URL.includes("&shorts") || URL.includes("?shorts"))) {
            typeGuess = "youtubeshorts";
        }
        await newOtherSource(typeGuess, URL, false, {});
    }
}

/* Modified newSource */
async function newSource(target, username, startup = false, initialState = {}, isChannelName = false) {
    document.getElementById('welcomeFrame')?.remove();
    
     if (username) {
        // Clean up username based on platform requirements
        // For YouTube: Keep @ for handles, UC for channels, c/ for custom channels
        // For other platforms: Remove @ symbol as they don't use it
        const allowSpacesForChannel = (target === 'youtube' || target === 'youtubeshorts' || target === 'rumble') && isChannelName;
        if (target !== 'youtube' && target !== 'youtubeshorts') {
            // Remove @ symbol from the start for all platforms except YouTube
            username = username.replace(/^@+/, '').trim();
        } else {
            // For YouTube, just trim whitespace but preserve @, UC, c/ prefixes
            username = username.trim();
        }
        if (!startup && /\s/.test(username) && !allowSpacesForChannel) {
            Toast.warning('Invalid Username', 'Usernames cannot contain spaces. Please enter the username exactly as it appears on the platform.');
            return;
        }
        let isUrl = false;
        try { new URL(username); isUrl = true; } catch (_) {}

        if (isUrl) {
            const url = new URL(username);
            const hostname = url.hostname.toLowerCase();
            if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
                const result = parseYoutubeUrl(url); 
                if (result.isYoutubeUrl && result.id) {
                    return newSourceVideoID(result.isShort ? "youtubeshorts" : "youtube", result.id, startup, initialState);
                } else if (result.isYoutubeUrl && result.username) {
                    target = result.isShort ? "youtubeshorts" : "youtube"; 
                    username = result.username;
                } else { 
                    username = url.pathname.split('/').filter(Boolean)[0]; 
                }
            } 
            else if (hostname.includes('rumble.com')) {
                 if (url.pathname.startsWith("/c/")) {
                    // Extract channel name from /c/channelname/livestreams
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    if (pathParts.length >= 2) {
                        username = pathParts[1]; // Get channel name
                        target = 'rumble';
                        isChannelName = true; // This is a channel URL
                    }
                } else if (url.pathname.startsWith("/user/")) {
                    // Extract username from /user/username/livestreams
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    if (pathParts.length >= 2) {
                        username = pathParts[1]; // Get username
                        target = 'rumble';
                        isChannelName = false; // This is a user URL
                    }
                } else if (url.pathname.startsWith("/chat/popup/")) {
                    // Direct chat popup URL - extract chat ID
                    const chatIdMatch = url.pathname.match(/\/chat\/popup\/(\d+)/);
                    if (chatIdMatch && chatIdMatch[1]) {
                        // For chat popup URLs, use newOtherSource instead
                        return newOtherSource('rumble', url.toString(), startup, initialState);
                    }
                } else {
                    // Try to extract video ID from URL like /v6vpthn-...
                    const videoIdMatch = url.pathname.match(/^\/([vp]\w+)-/);
                    if (videoIdMatch && videoIdMatch[1]) {
                        return newSourceVideoID('rumble', videoIdMatch[1], startup, initialState);
                    } else {
                        // Fall back to fetching video ID from page
                        const videoId = await getRumbleVideoId(url.toString()); 
                        if (videoId) return newSourceVideoID('rumble', videoId, startup, initialState);
                    }
                }
            }
        }
    }


    if (!username) { 
        console.warn("newSource called without username after prompt phase.");
        return;
    }

    let elementToReturnId; 

    if (target === "youtube" || target === "youtubeshorts") {
        const groupId = stateManager.addGroup({
            target,
            username,
            isChannel: isChannelName, 
            connectionMode: initialState.connectionMode || 'classic',
            autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
            groupVisible: initialState.groupVisible !== "false", 
            groupMuted: initialState.groupMuted === "true"
        });
        elementToReturnId = groupId; 
    } else {
        let sourceUrl = initialState.URL || initialState.url || ""; 
        let sourceFile = initialState.sourceFile || null; // Check for existing sourceFile

        if (!sourceUrl) { 
            if (target === "twitch") sourceUrl = `https://www.twitch.tv/popout/${username}/chat?popout=`;
            else if (target === "kick") sourceUrl = `https://kick.com/popout/${username}/chat`;
            else if (target === "parti") sourceUrl = `https://parti.com/popout-chat?id=${username}`;
            else if (target === "rumble") {
                if (isChannelName) {
                    sourceUrl = `https://rumble.com/c/${username}/livestreams`;
                } else {
                    sourceUrl = `https://rumble.com/user/${username}/livestreams`;
                }
            } 
            else if (target === "tiktok") sourceUrl = `https://www.tiktok.com/@${username.replace('@','')}/live`;
            else if (target === "trovo") sourceUrl = `https://trovo.live/chat/${username}`;
            else if (target === "instagram" || target === "instagramlive") sourceUrl = `https://www.instagram.com/${username}/live/`;
            else if (target === "picarto") sourceUrl = `https://picarto.tv/chatpopout/${username}/public`;
            else if (target === "dlive") sourceUrl = `https://dlive.tv/c/${username}/${username}`;
            else if (target === "x") sourceUrl = `https://x.com/${username}/chat`;
            else if (target === "beamstream") sourceUrl = `https://beamstream.gg/${username}/chat`;
            else if (target === "vimm") sourceUrl = `https://www.vimm.tv/c/${username}`;
            else if (target === "bilibili") sourceUrl = `https://live.bilibili.com/${username}`;
            else if (target === "facebook") sourceUrl = `https://www.facebook.com/${username}/videos`;
			else if (target === "arenasocial") sourceUrl = `https://arena.social/live/${username}`;
            // Add other URL constructions as needed
        }
        
        // Determine specific sourceFile if not provided in initialState
        if (!sourceFile) {
            if (target === "instagramlive" || target === "instagram") sourceFile = "sources/instagram.js";
            else if (target === "trovo") sourceFile = "sources/trovo.js";
            else if (target === "picarto") sourceFile = "sources/picarto.js";
            else if (target === "dlive") sourceFile = "sources/dlive.js";
            else if (target === "x") sourceFile = "sources/x.js";
            else if (target === "beamstream") sourceFile = "sources/beamstream.js";
            // Add other platform-specific script files here if necessary
        }


        // Check if platform supports WebSockets
        let supportsWSS = false;
        if (target === 'tiktok') {
            supportsWSS = true; // TikTok has built-in websocket support
        } else if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
            supportsWSS = manifest.content_scripts.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            );
        }
        
        // Set default connection mode based on platform
        let defaultMode = 'classic';
        if (target === 'tiktok') {
            if (preferTikTokClassic || cliForcesTikTokClassic) {
                defaultMode = 'classic';
            } else {
                defaultMode = lastTikTokMode || 'tiktok-websocket';
            }
        }
        
        // Force classic mode for platforms that don't have websocket support
        let connectionMode = initialState.connectionMode || defaultMode;
        if (!supportsWSS && connectionMode === 'websocket') {
            connectionMode = 'classic';
        }

        let sourceData = {
            target,
            username,
            url: sourceUrl,
            videoId: initialState.videoId || '', 
            connectionMode: connectionMode, // Use the validated connectionMode
            isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
            isMuted: (initialState.togglemute === "false" || initialState.isMuted === false) ? false : true,
            autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
            supportsWSS,
            isChannel: target === 'rumble' ? isChannelName : undefined,
            ...initialState
        };
        if (sourceFile) { // Add sourceFile to the data if it was determined
            sourceData.sourceFile = sourceFile;
        }

        // Offer reply-only bot mode on duplicate URL/videoId
        sourceData = await handleDuplicateForSource(sourceData);

        const sourceId = stateManager.addSource(sourceData);
        elementToReturnId = sourceId; 
    }
    
    manageWelcomePage();
    
    await Promise.resolve(); 
    const elementToReturn = elementToReturnId ? 
        (document.querySelector(`[data-source-id="${elementToReturnId}"]`) || document.querySelector(`[data-group-id="${elementToReturnId}"]`))
        : null;

    if (elementToReturn && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        if (elementToReturn.dataset.sourceId) { 
            const source = stateManager.getSource(elementToReturn.dataset.sourceId);
            if (source && source.autoActivate && !source.vid && !source.wssId) {
                 setTimeout(async () => {
                    const latest = stateManager.getSource(source.id);
                    if (!latest || !latest.autoActivate) return;
                    const activateButton = elementToReturn.querySelector('[data-activatehtml]');
                    if (activateButton && !latest.vid && !latest.wssId) { 
                        await createWindow(activateButton);
                    }
                }, 2000 + Math.random() * 1000);
            }
        } else if (elementToReturn.dataset.groupId) { 
            const group = stateManager.getGroup(elementToReturn.dataset.groupId);
            if (group && group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                 setTimeout(async () => {
                    console.log('Auto-activating YouTube group from newSource:', group.username);
                     await handleYouTubeActivation(
                        group.username,
                        group.target === "youtubeshorts",
                        false, 
                        true,  
                        group.isChannel
                    );
                }, 2500 + Math.random() * 1000);
            }
        }
    }
    return elementToReturn;
}

async function newSourceVideoID(target, videoID, startup = false, initialState = {}) {
    document.getElementById('welcomeFrame')?.remove();
    
    if (!videoID) return;

    let url = initialState.URL || initialState.url || "";
    if (!url) { 
        if (target === "youtube" || target === "youtubeshorts") {
            url = `https://www.youtube.com/live_chat?is_popout=1&v=${videoID}${target === "youtubeshorts" ? "&shorts" : ""}`;
        } else if (target === "rumble") {
            // For Rumble, videoID might be alphanumeric (v6vpthn) or numeric (412388813)
            // We'll fetch the proper chat ID later during activation
            url = null; // Don't set a default URL, let activation handle it
        }
    }

    // Check if platform supports WebSockets
    let supportsWSS = false;
    if (target === 'tiktok') {
        supportsWSS = true; // TikTok has built-in websocket support
    } else if (typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // Set default connection mode based on platform
    let defaultMode = 'classic';
    // TikTok defaults based on global preference
    if (target === 'tiktok') {
        if (preferTikTokClassic || cliForcesTikTokClassic) {
            defaultMode = 'classic';
        } else {
            defaultMode = lastTikTokMode || 'tiktok-websocket';
        }
    }

    let sourceDataVid = {
        target,
        videoId: videoID,
        url: url,
        username: initialState.username || '', 
        connectionMode: initialState.connectionMode || defaultMode,
        isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
        isMuted: (initialState.togglemute === "false" || initialState.isMuted === false) ? false : true,
        autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
        supportsWSS,
         ...initialState
    };

    // Offer reply-only bot mode on duplicate videoId/URL
    sourceDataVid = await handleDuplicateForSource(sourceDataVid);
    const sourceId = stateManager.addSource(sourceDataVid);
    
    manageWelcomePage();
    
    await Promise.resolve(); 
    const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);

    if (sourceElement && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        const source = stateManager.getSource(sourceId);
         if (source && source.autoActivate && !source.vid && !source.wssId) {
            setTimeout(async () => {
                const latest = stateManager.getSource(source.id);
                if (!latest || !latest.autoActivate) return;
                const activateButton = sourceElement.querySelector('[data-activatehtml]');
                if (activateButton && !latest.vid && !latest.wssId) {
                    await createWindow(activateButton);
                }
            }, 2000 + Math.random() * 1000);
        }
    }
    return sourceElement;
}

/* Modified newOtherSource */
async function newOtherSource(target, URL, startup = false, initialState = {}) {
    document.getElementById('welcomeFrame')?.remove();
    if (!URL) return;

    let displayName = initialState.username || '';
    let chatId = null;
    
    // Check if this is a Rumble chat popup URL
    if (URL.includes('rumble.com/chat/popup/')) {
        const chatIdMatch = URL.match(/\/chat\/popup\/(\d+)/);
        if (chatIdMatch && chatIdMatch[1]) {
            chatId = chatIdMatch[1];
            displayName = `Rumble Chat ${chatId}`;
        }
    }
    
    if (!displayName) {
        try {
            const link = new URL(URL);
            const parts = link.hostname.split('.');
            displayName = parts.length >= 2 ? `${parts[parts.length - 2]}.${parts[parts.length - 1]}` : link.hostname;
        } catch {
            displayName = target || 'Unknown Source';
        }
    }
    
    // Determine sourceFile based on target, similar to how newSource handles it
    let sourceFile = initialState.sourceFile || null;
    if (!sourceFile && target) {
        // Example: if target is 'instagramlive', sourceFile should be 'sources/instagram.js'
        // This logic needs to be robust based on your platform-to-script mapping
        if (target === "instagramlive") {
            sourceFile = "sources/instagram.js";
        } else {
            // Default assumption: target maps directly to script name
            sourceFile = `sources/${target}.js`;
        }
    }


    // Check if platform supports WebSockets
    let supportsWSS = false;
    if (target === 'tiktok') {
        supportsWSS = true; // TikTok has built-in websocket support
    } else if (target && typeof manifest !== 'undefined' && manifest?.content_scripts) {
        supportsWSS = manifest.content_scripts.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // Set default connection mode based on platform
    let defaultMode = 'classic';
    // TikTok defaults based on global preference
    if (target === 'tiktok') {
        if (preferTikTokClassic || cliForcesTikTokClassic) {
            defaultMode = 'classic';
        } else {
            defaultMode = lastTikTokMode || 'tiktok-websocket';
        }
    }

    let sourceData = {
        target: target || 'unknown', 
        url: URL,
        username: displayName, 
        videoId: initialState.videoId || '', 
        connectionMode: initialState.connectionMode || defaultMode,
        isVisible: initialState.togglehtml !== "false" && initialState.isVisible !== false,
        isMuted: (initialState.togglemute === "false" || initialState.isMuted === false) ? false : true,
        autoActivate: initialState.togglelock === "true" || initialState.autoActivate === true,
        supportsWSS,
        ...initialState
    };
    
    // Add chatId if this is a Rumble chat popup
    if (chatId) {
        sourceData.chatId = chatId;
        // Clear username to prevent fetching videos for "rumble"
        if (target === 'rumble') {
            sourceData.username = displayName; // Keep the display name but it won't be used for fetching
            sourceData.videoId = ''; // Ensure videoId is empty
        }
    }
    
    // For Rumble URLs that aren't standard patterns, mark them as direct URLs
    if (target === 'rumble' && URL.includes('rumble.com') && !chatId) {
        // This is a custom Rumble URL that should be used as-is
        sourceData.isDirectUrl = true;
        // Keep the URL but clear fields that would trigger fetching
        sourceData.videoId = '';
        // Keep username for display but it won't be used for fetching
    }
    if (sourceFile) {
        sourceData.sourceFile = sourceFile;
    }
    
    // Offer reply-only bot mode on duplicate URL/videoId
    sourceData = await handleDuplicateForSource(sourceData);
    const sourceId = stateManager.addSource(sourceData);

    manageWelcomePage();

    await Promise.resolve(); 
    const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);

     if (sourceElement && startup && (initialState.togglelock === "true" || initialState.autoActivate)) {
        const source = stateManager.getSource(sourceId);
         if (source && source.autoActivate && !source.vid && !source.wssId) {
            setTimeout(async () => {
                const latest = stateManager.getSource(source.id);
                if (!latest || !latest.autoActivate) return;
                const activateButton = sourceElement.querySelector('[data-activatehtml]');
                if (activateButton && !latest.vid && !latest.wssId) {
                    await createWindow(activateButton);
                }
            }, 2000 + Math.random() * 1000);
        }
    }
    return sourceElement;
}


async function newSourceOLD(target, username = false, startup = false, state = {}, isChannelName = false) {
    console.warn("newSourceOLD is deprecated and should not be called directly. Use newSourcePrompt or newSource.");
    if (username) {
        return newSource(target, username, startup, state, isChannelName);
    }
    return null;
}

async function cleanupYouTubeGroups() {
    console.log("Cleaning up YouTube video sources on startup...");
    
    // Get ALL sources, not just auto-discovered ones
    const allSources = stateManager.getSources();
    let removedCount = 0;
    let debugInfo = {
        totalSources: allSources.length,
        youtubeSources: 0,
        withVideoId: 0,
        autoDiscovered: 0,
        removed: 0
    };
    
    allSources.forEach(source => {
        if (source.target && source.target.startsWith('youtube')) {
            debugInfo.youtubeSources++;
            
            if (source.videoId) {
                debugInfo.withVideoId++;
                
                // Debug log for each YouTube source with video ID
                console.log(`YouTube source ${source.id}: videoId=${source.videoId}, isAutoDiscovered=${source.isAutoDiscovered}, groupId=${source.groupId || 'none'}`);
                
                // New rule: remove all grouped YouTube video entries on startup (ephemeral)
                if (source.groupId) {
                    console.log("Removing grouped YouTube video source on startup:", source.id, "videoId:", source.videoId, "groupId:", source.groupId);
                    
                    // Remove the source element from DOM if it exists
                    const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
                    if (sourceElement) {
                        sourceElement.remove();
                    }
                    
                    // Remove from state
                    stateManager.removeSource(source.id);
                    removedCount++;
                    debugInfo.removed++;
                } else {
                    // Standalone manual YouTube entries (no group) are preserved
                    console.log(`Preserving standalone YouTube source ${source.id}: videoId=${source.videoId}`);
                }
            }
        }
    });
    
    if (window.SSAPP_DEBUG_LOGS) {
        console.log("YouTube cleanup debug info:", debugInfo);
    }
    
    if (removedCount > 0) {
        console.log(`Removed ${removedCount} auto-discovered YouTube video sources on startup`);
        
        // Clean up orphaned stream references in groups
        const groups = stateManager.getGroups();
        groups.forEach(group => {
            if ((group.target === "youtube" || group.target === "youtubeshorts") && group.streams) {
                const validStreams = group.streams.filter(streamId => 
                    stateManager.getSource(streamId) !== null
                );
                
                if (validStreams.length !== group.streams.length) {
                    console.log(`Cleaned ${group.streams.length - validStreams.length} orphaned streams from group ${group.username}`);
                    group.streams = validStreams;
                }
            }
        });
        
        // Persist the cleaned state
        stateManager.persist();
    }
}

function setupGroupControls(groupHeaderElement) {
    if (!groupHeaderElement) return;
    const groupId = groupHeaderElement.dataset.groupId;
    if (!groupId) return;

    const group = stateManager.getGroup(groupId);
    if (!group) return;

    const target = group.target;
    const controlPanel = groupHeaderElement.querySelector('.control-panel');
    
    // Add connection mode selector for YouTube groups
    if (target && target.startsWith('youtube') && controlPanel) {
        let modeSelector = controlPanel.querySelector('.mode-selector');
        
        if (!modeSelector) {
            modeSelector = document.createElement('div');
            modeSelector.className = 'mode-selector';
            modeSelector.innerHTML = `
                <div class="mode-selector-label">Default Mode:</div>
                <div class="mode-options">
                    <div class="mode-option" 
                         data-mode="classic" 
                         onclick="setGroupConnectionMode(this.closest('.entry'), 'classic'); updateModeSelector(this)">
                        📄 Standard
                    </div>
                    <div class="mode-option" 
                         data-mode="websocket" 
                         onclick="setGroupConnectionMode(this.closest('.entry'), 'websocket'); updateModeSelector(this)">
                        🌐 WebSocket
                    </div>
                </div>
                <div class="mode-info">
                    <span class="info-icon" title="WebSocket mode uses less resources and provides additional data like followers/subs when signed in. Requires login for full features.">ℹ️</span>
                </div>`;
            
            controlPanel.appendChild(modeSelector);
            
            // Update the active state based on current connection mode
            const currentMode = group.connectionMode || 'classic';
            modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.mode === currentMode) {
                    opt.classList.add('active');
                }
            });
        }
    }

    const autoActivateCheckbox = groupHeaderElement.querySelector('.auto-activate-toggle input[data-state-key="autoActivate"]');
    if (autoActivateCheckbox) {
        autoActivateCheckbox.checked = group.autoActivate;
        autoActivateCheckbox.onchange = () => {
            stateManager.updateGroup(groupId, { autoActivate: autoActivateCheckbox.checked });
            
            // Start or stop auto-checking for YouTube groups
            if (group.target === "youtube" || group.target === "youtubeshorts") {
                if (autoActivateCheckbox.checked) {
                    startYouTubeGroupAutoCheck(groupId);
                } else {
                    stopYouTubeGroupAutoCheck(groupId);
                }
            }
        };
    }
    
    const settingsBtn = groupHeaderElement.querySelector('.settings-btn');
    const settingsMenu = groupHeaderElement.querySelector('.settings-menu');
    if (settingsBtn && settingsMenu) {
        settingsBtn.onclick = (e) => {
            e.stopPropagation();
            document.querySelectorAll('.settings-menu.active').forEach(menu => {
                if (menu !== settingsMenu) menu.classList.remove('active');
            });
            settingsMenu.classList.toggle('active');
            if (settingsMenu.classList.contains('active')) {
                try { updateMoveMenuItemsForGroup(groupHeaderElement); } catch (e) { /* noop */ }
            }
        };
        document.addEventListener('click', (e) => {
            if (!settingsMenu.classList.contains('hidden') && !settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsMenu.classList.remove('active');
            }
        });
    }
}

function toggleGroupVisibility(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    stateManager.updateGroup(groupId, { groupVisible: !group.groupVisible });
}

function toggleGroupMute(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    stateManager.updateGroup(groupId, { groupMuted: !group.groupMuted });
}

function updateModeSelector(clickedOption) {
    if (!clickedOption) return;
    if (clickedOption.dataset?.disabled === 'true') {
        Toast.info('TikTok Classic', cliForcesTikTokClassic
            ? 'Classic mode is locked by launch flag.'
            : 'Disable the global TikTok Classic preference to use TikTok WebSocket mode.');
        return;
    }
    const modeOptions = clickedOption.parentElement;
    modeOptions.querySelectorAll('.mode-option').forEach(opt => {
        opt.classList.remove('active');
    });
    clickedOption.classList.add('active');
}

function setGroupConnectionMode(groupElement, mode) {
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    
    if (group.target === 'tiktok' && mode === 'tiktok-websocket' && (preferTikTokClassic || cliForcesTikTokClassic)) {
        Toast.info('TikTok Classic', cliForcesTikTokClassic
            ? 'Classic mode is locked by launch flag.'
            : 'Disable the global TikTok Classic preference to use TikTok WebSocket mode for this group.');
        return;
    }
    
    // Update the group's default connection mode
    stateManager.updateGroup(groupId, { connectionMode: mode });

    if (group.target === 'tiktok') {
        const allowedLastModes = new Set(['classic', 'tiktok-websocket', 'tiktok-legacy']);
        if (allowedLastModes.has(mode) && mode !== lastTikTokMode) {
            lastTikTokMode = mode;
            if (stateManager.state?.global?.lastTikTokMode !== mode) {
                stateManager.updateGlobal({ lastTikTokMode: mode });
            }
        }
    }

    // Update child sources that are not currently active; skip active ones
    const sources = stateManager.getSourcesByGroup(groupId);
    let skipped = 0;
    sources.forEach(source => {
        const isActive = !!(source.vid || source.wssId);
        if (isActive) { skipped++; return; }
        stateManager.updateSource(source.id, { connectionMode: mode, activeConnectionMode: null });

        // Update the UI for each source
        const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
        if (sourceElement) {
            updateSourceUIAfterModeChange(sourceElement, mode, source.status === 'active');
        }
    });
    
    // Update the group's settings menu to show the active mode
    const settingsMenu = groupElement.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.querySelectorAll('[data-action^="group-"]').forEach(item => {
            item.classList.remove('active');
        });
        const activeItem = settingsMenu.querySelector(`[data-action="group-${mode}-mode"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
    
    // Close the settings menu
    const settingsBtn = groupElement.querySelector('.settings-btn');
    if (settingsBtn) {
        settingsBtn.classList.remove('active');
    }
    
    if (skipped > 0) {
        Toast.warning('Partial Mode Update', `Updated inactive streams; ${skipped} active source(s) unchanged. Stop them to switch modes.`);
    } else {
        Toast.info('Connection Mode Updated', `All streams in ${group.username} now use ${mode === 'websocket' ? 'WebSocket' : (mode === 'tiktok-websocket' ? 'TikTok WS' : (mode === 'tiktok-legacy' ? 'TikTok Legacy' : 'Standard'))} mode`);
    }
}

function stopAllStreamsInGroup(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && (source.vid || source.wssId)) {
            const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
            const stopButton = sourceElement?.querySelector('[data-stophtml]');
            if (stopButton) stopThis(stopButton); 
        }
    });
}

function reloadAllStreamsInGroup(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group) return;

    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid) { 
            const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
            const reloadButton = sourceElement?.querySelector('[data-reloadhtml]');
            if (reloadButton) refreshWindow(reloadButton);
        }
    });
}

function handleYouTubeGroupActivationPrompt(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return;

    handleYouTubeActivation(group.username, group.target === "youtubeshorts", true, false, group.isChannel);
}

function handleYouTubeGroupAutoActivation(buttonElement) {
    const groupElement = buttonElement.closest('[data-is-group-header="true"]');
    const groupId = groupElement?.dataset.groupId;
    if (!groupId) return;
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return;
    
    handleYouTubeActivation(group.username, group.target === "youtubeshorts", false, true, group.isChannel);
}

// Store interval IDs for YouTube group checking
const youtubeGroupIntervals = new Map();

// Store backoff state for YouTube groups
const youtubeGroupBackoffState = new Map();

// Store interval IDs for Rumble auto-checking
const rumbleIntervals = new Map();

function startYouTubeGroupAutoCheck(groupId) {
    // Clear any existing interval for this group
    stopYouTubeGroupAutoCheck(groupId);
    
    const group = stateManager.getGroup(groupId);
    if (!group || !group.autoActivate) return;

    // Skip auto-check entirely if any source in the group is already active
    const hasActive = (group.streams || []).some(sid => {
        const s = stateManager.getSource(sid);
        return s && s.status === 'active' && (s.vid || s.wssId);
    });
    if (hasActive) {
        console.log(`YouTube group ${group.username} already has an active stream; skipping auto-check.`);
        return;
    }
    
    console.log(`Starting auto-check for YouTube group: ${group.username}`);
    
    // Initialize backoff state
    youtubeGroupBackoffState.set(groupId, {
        checkCount: 0,
        intervals: [60000, 360000, 960000] // 1 min, 6 min, 16 min
    });
    
    // Check immediately
    checkYouTubeGroupForNewStreamsWithBackoff(groupId);
}

function stopYouTubeGroupAutoCheck(groupId) {
    const timeoutId = youtubeGroupIntervals.get(groupId);
    if (timeoutId) {
        clearTimeout(timeoutId);
        youtubeGroupIntervals.delete(groupId);
        youtubeGroupBackoffState.delete(groupId);
        console.log(`Stopped auto-check for YouTube group: ${groupId}`);
    }
}

async function checkYouTubeGroupForNewStreamsWithBackoff(groupId) {
    // If any stream is already active, stop checking and return
    const groupPre = stateManager.getGroup(groupId);
    if (groupPre && (groupPre.streams || []).some(sid => {
        const s = stateManager.getSource(sid);
        return s && s.status === 'active' && (s.vid || s.wssId);
    })) {
        console.log(`YouTube group ${groupPre.username} has an active stream; stopping auto-check.`);
        stopYouTubeGroupAutoCheck(groupId);
        return;
    }

    // Check for new streams
    const foundNewStreams = await checkYouTubeGroupForNewStreams(groupId);
    
    // If we found NEW streams, stop checking (not just any streams)
    if (foundNewStreams) {
        stopYouTubeGroupAutoCheck(groupId);
        return;
    }
    
    // Get backoff state
    const backoffState = youtubeGroupBackoffState.get(groupId);
    if (!backoffState) return;
    
    // Determine next check interval
    let nextInterval;
    if (backoffState.checkCount < backoffState.intervals.length) {
        nextInterval = backoffState.intervals[backoffState.checkCount];
        backoffState.checkCount++;
    } else {
        // Use the last interval (16 minutes) for all subsequent checks
        nextInterval = backoffState.intervals[backoffState.intervals.length - 1];
    }
    
    const group = stateManager.getGroup(groupId);
    if (group) {
        const minutes = Math.floor(nextInterval / 60000);
        console.log(`No new streams found for YouTube group ${group.username}, checking again in ${minutes} minute(s)`);
    }
    
    // Schedule next check
    const timeoutId = setTimeout(() => {
        checkYouTubeGroupForNewStreamsWithBackoff(groupId);
    }, nextInterval);
    
    youtubeGroupIntervals.set(groupId, timeoutId);
}

async function checkYouTubeGroupForNewStreams(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group || (group.target !== "youtube" && group.target !== "youtubeshorts")) return false;
    
    console.log(`Checking for new streams in YouTube group: ${group.username}`);
    
    let streams = [];
    let usingFallback = false;
    
    try {
        // Try the API first
        const response = await fetch(`https://api.socialstream.ninja/youtube/streams?username=${encodeURIComponent(group.username)}`);
        const data = await response.json();
        
        if (!data.success || !Array.isArray(data.data)) {
            console.warn("API response invalid, falling back to fetchYoutube");
            throw new Error("Invalid API response");
        }
        
        streams = data.data;
    } catch (error) {
        console.error("API call failed, attempting fallback to fetchYoutube:", error);
        
        // Fallback to fetchYoutube
        try {
            usingFallback = true;
            
            // Check if fetchYoutube is available
            if (typeof fetchYoutube !== 'function') {
                console.error("fetchYoutube function not available");
                return false;
            }
            
            // Try both alt=false and alt=true if needed
            let fetchResult = await fetchYoutube(group.username, false);
            if (!fetchResult || fetchResult.length === 0) {
                fetchResult = await fetchYoutube(group.username, true);
            }
            
            if (fetchResult && Array.isArray(fetchResult)) {
                streams = fetchResult;
                console.log(`Fallback successful, found ${streams.length} streams via fetchYoutube`);
            } else {
                console.error("Fallback to fetchYoutube also failed");
                return false;
            }
        } catch (fallbackError) {
            console.error("Fallback to fetchYoutube failed:", fallbackError);
            return false;
        }
    }
    
    // Filter streams based on type
    const isShorts = group.target === "youtubeshorts";
    const filteredStreams = streams.filter(stream => stream.isShort === isShorts);

    // Further filter to eligible statuses:
    // - live
    // - upcoming within the next 60 minutes
    const now = new Date();
    const eligibleStreams = filteredStreams.filter(stream => {
        if (!stream || !stream.status) return false;
        if (stream.status === 'live') return true;
        if (stream.status === 'upcoming' && stream.scheduledStartTime) {
            try {
                let startMs = stream.scheduledStartTime;
                if (typeof startMs === 'string') startMs = Number(startMs);
                if (typeof startMs === 'number' && startMs < 1e12) startMs *= 1000; // seconds -> ms
                const start = new Date(startMs);
                const diffMins = (start - now) / (1000 * 60);
                return diffMins >= 0 && diffMins <= 60; // within next hour
            } catch (_) { /* ignore parse errors */ }
        }
        return false;
    });
    
    // Get existing video IDs for this group
    const existingVideoIds = new Set();
    group.streams.forEach(sourceId => {
        const source = stateManager.getSource(sourceId);
        if (source && source.videoId) {
            existingVideoIds.add(source.videoId);
        }
    });
    
    // Find new streams among eligible list only
    const newStreams = eligibleStreams.filter(stream => !existingVideoIds.has(stream.videoId));
    
    if (newStreams.length > 0) {
        console.log(`Found ${newStreams.length} new streams for group ${group.username}${usingFallback ? ' (via fallback)' : ''}`);
        Toast.info("New Streams Found", `Found ${newStreams.length} new live stream(s) for ${group.username}`);
        
        // Auto-activate new streams if auto-activate is enabled
        for (const stream of newStreams) {
            const newSource = {
                target: group.target,
                username: group.username,
                url: `https://www.youtube.com/live_chat?is_popout=1&v=${stream.videoId}${group.target === 'youtubeshorts' ? '&shorts' : ''}`,
                groupId: groupId,
                videoId: stream.videoId,
                title: stream.title,
                autoActivate: true, // Inherit auto-activate from group
                connectionMode: group.connectionMode || 'classic'
            };
            
            console.log("Adding new YouTube stream:", newSource);
            stateManager.addSource(newSource);
            
            // Auto-activate the new source
            setTimeout(async () => {
                const addedSource = stateManager.getSources().find(s => s.videoId === stream.videoId);
                if (addedSource) {
                    const sourceElement = document.querySelector(`[data-source-id="${addedSource.id}"]`);
                    const activateButton = sourceElement?.querySelector('[data-activatehtml]');
                    if (activateButton) {
                        await createWindow(activateButton);
                    }
                }
            }, 500);
        }
    }

    // If there are eligible streams but none are new, try activating any existing eligible stream entries that are not active
    if (newStreams.length === 0 && eligibleStreams.length > 0) {
        let activatedExisting = 0;
        for (const stream of eligibleStreams) {
            // Find the existing source within this group matching the videoId
            const existingSourceId = group.streams.find(sid => {
                const s = stateManager.getSource(sid);
                return s && s.videoId === stream.videoId;
            });
            if (!existingSourceId) continue;
            const existingSource = stateManager.getSource(existingSourceId);
            if (!existingSource) continue;
            const isOpen = !!(existingSource.vid || existingSource.wssId);
            const isActive = existingSource.status === 'active';
            if (isOpen || isActive) continue;

            try {
                // Ensure a DOM element exists
                let sourceElement = document.querySelector(`[data-source-id="${existingSourceId}"]`);
                if (!sourceElement) {
                    sourceElement = createSourceElement(existingSourceId);
                    const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
                    const streamsContainer = groupElement?.querySelector('.stream-group');
                    if (sourceElement && streamsContainer) streamsContainer.appendChild(sourceElement);
                }
                const activateButton = sourceElement?.querySelector('[data-activatehtml]');
                if (activateButton) {
                    const winId = await createWindow(activateButton);
                    if (winId) activatedExisting++;
                }
            } catch (e) {
                console.warn('Failed to activate existing eligible YouTube source:', existingSourceId, e);
            }
        }
        if (activatedExisting > 0) {
            console.log(`Activated ${activatedExisting} existing eligible stream(s) for group ${group.username}`);
            // Treat as success so we stop the backoff loop
            return true;
        }
    }

    // Return true only if we found NEW streams (not just any streams)
    return newStreams.length > 0;
}

// Rumble auto-check functions
function startRumbleAutoCheck(sourceId) {
    // Clear any existing interval for this source
    stopRumbleAutoCheck(sourceId);
    
    const source = stateManager.getSource(sourceId);
    if (!source || !source.autoActivate || source.target !== 'rumble') return;
    
    console.log(`Starting auto-check for Rumble source: ${source.username}`);
    
    // Check immediately
    checkRumbleForStream(sourceId);
    
    // Then check every minute until a stream is found
    const intervalId = setInterval(() => {
        checkRumbleForStream(sourceId);
    }, 60000); // 60 seconds
    
    rumbleIntervals.set(sourceId, intervalId);
}

function stopRumbleAutoCheck(sourceId) {
    const intervalId = rumbleIntervals.get(sourceId);
    if (intervalId) {
        clearInterval(intervalId);
        rumbleIntervals.delete(sourceId);
        console.log(`Stopped auto-check for Rumble source: ${sourceId}`);
    }
}

async function checkRumbleForStream(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source || source.target !== 'rumble') return;
    
    // Don't check if already activated
    if (source.status === 'active' && source.vid) {
        console.log(`Rumble source ${source.username} already active, stopping auto-check`);
        stopRumbleAutoCheck(sourceId);
        return;
    }
    
    console.log(`Checking for live stream for Rumble user: ${source.username}`);
    
    try {
        // Try to activate the source
        const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
        const activateButton = sourceElement?.querySelector('[data-activatehtml]');
        
        if (activateButton) {
            // Try to create the window
            const windowId = await createWindow(activateButton);
            
            if (windowId) {
                console.log(`Rumble stream found and activated for ${source.username}`);
                Toast.success("Rumble Stream Live", `${source.username} is now live on Rumble!`);
                
                // Stop checking since Rumble only allows one stream per user
                stopRumbleAutoCheck(sourceId);
            } else {
                console.log(`No live stream found for Rumble user ${source.username}, will check again in 1 minute`);
            }
        }
    } catch (error) {
        console.error("Error checking Rumble for stream:", error);
        // Keep checking on error
    }
}


function updateSourceUIAfterModeChange(sourceElement, mode, isActive = false) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    
    const target = source ? source.target : sourceElement.dataset.target;
    const activeMode = source ? (getEffectiveConnectionMode(source) || mode) : mode;

    const activateButton = sourceElement.querySelector('[data-activatehtml]');
    const controlPanel = sourceElement.querySelector('.control-panel');
    
    const classicModePanelButton = controlPanel?.querySelector('.mode-option[data-mode="classic"]');
    const wsModePanelButton = controlPanel?.querySelector('.mode-option[data-mode="websocket"]');

    const settingsMenu = sourceElement.querySelector('.settings-menu');
    const classicMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-action="classic-mode"]');
    const wssMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-wss="true"]');
    const tiktokWssMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-tiktokwss="true"]');
    const tiktokLegacyMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-tiktoklegacy="true"]');

    classicModePanelButton?.classList.remove('active');
    wsModePanelButton?.classList.remove('active');
    if (classicMenuItem) classicMenuItem.dataset.selected = "false";
    if (wssMenuItem) wssMenuItem.dataset.selected = "false";
    if (tiktokWssMenuItem) tiktokWssMenuItem.dataset.selected = "false";
    if (tiktokLegacyMenuItem) tiktokLegacyMenuItem.dataset.selected = "false";

    if (activateButton) { 
        // Ensure transient connecting flag is cleared if not truly connecting
        const srcForMode = source || stateManager.getSource(sourceId);
        if (srcForMode && srcForMode.status !== 'activating') {
            delete activateButton.dataset.connecting;
        }

        const displayMode = getEffectiveConnectionMode(srcForMode) || mode;

        if (target === 'tiktok') {
            if (srcForMode && srcForMode.status === 'activating') {
                setActivateButtonConnecting(sourceElement);
            } else if (displayMode === 'tiktok-legacy') {
                activateButton.innerText = 'Connect TikTok Legacy';
            } else if (displayMode === 'tiktok-websocket') {
                activateButton.innerText = 'Connect TikTok WebSocket';
            } else {
                activateButton.innerText = translate('btn.activate');
            }
        } else if (displayMode === 'websocket') {
            const s = srcForMode;
            if (s && s.status === 'activating') {
                activateButton.innerText = '⏹️ Stop connecting';
            } else if (s && s.vid) {
                activateButton.innerText = '⏹️ Close WebSocket';
            } else {
                activateButton.innerText = 'Connect WebSocket';
            }
        } else {
            activateButton.innerText = translate('btn.activate');
        }
    }
    
    if (target === 'tiktok') {
        const panelClassic = controlPanel?.querySelector('.mode-option[data-mode="classic"]');
        const panelWss = controlPanel?.querySelector('.mode-option[data-mode="tiktok-websocket"]');
        const panelLegacy = controlPanel?.querySelector('.mode-option[data-mode="tiktok-legacy"]');
        panelClassic?.classList.remove('active');
        panelWss?.classList.remove('active');
        panelLegacy?.classList?.remove('active');

        if (mode === 'tiktok-websocket') {
            if (tiktokWssMenuItem) tiktokWssMenuItem.dataset.selected = "true";
            panelWss?.classList.add('active');
        } else if (mode === 'tiktok-legacy') {
            if (tiktokLegacyMenuItem) tiktokLegacyMenuItem.dataset.selected = "true";
            panelLegacy?.classList?.add('active');
        } else {
            if (classicMenuItem) classicMenuItem.dataset.selected = "true";
            panelClassic?.classList.add('active');
        }
        // Don't hide mode selector
    } else { 
        if (mode === 'websocket') {
            wsModePanelButton?.classList.add('active');
            if (wssMenuItem) wssMenuItem.dataset.selected = "true";
        } else { 
            classicModePanelButton?.classList.add('active');
            if (classicMenuItem) classicMenuItem.dataset.selected = "true";
        }
        // Don't hide the mode selector based on menu item visibility
    }
    
    // Update sign-in button visibility and behavior based on connection mode
    const signinButton = sourceElement.querySelector("[data-signin]");
    if (signinButton) {
        const signinMode = source ? (getEffectiveConnectionMode(source) || mode) : mode;
        const isWebsocketMode = signinMode === 'websocket' || signinMode === 'tiktok-websocket' || signinMode === 'tiktok-legacy';
        
        if (target === 'tiktok' && (signinMode === 'tiktok-websocket' || signinMode === 'tiktok-legacy')) {
            // Allow users to supply credentials even in read-only mode
            const hasSession = !!(source && typeof source.tiktokSessionId === 'string' && source.tiktokSessionId.trim());
            signinButton.classList.remove("hidden");
            signinButton.setAttribute('data-tiktok-signin', 'true');
            signinButton.innerHTML = hasSession ? '✓ TikTok Session Saved' : '🔐 Add TikTok Session ID';
            signinButton.classList.toggle('authenticated', hasSession);
            signinButton.style.cursor = '';
            signinButton.title = 'Provide your TikTok session cookie to enable chat replies and authenticated features.';
            signinButton.onclick = function() {
                showTikTokSignInMenu(sourceId);
            };
            applySigninPolicy(signinButton, source);
        } else if (isWebsocketMode) {
            // Hide for other websocket modes
            signinButton.classList.add("hidden");
        } else {
            // Regular sign-in button
            signinButton.classList.remove("hidden");
            signinButton.removeAttribute('data-tiktok-signin');
            signinButton.innerHTML = '🔑 Sign-in';
            signinButton.onclick = function() { signin(this); };
            signinButton.classList.remove('authenticated');
            signinButton.title = '';
            // Apply config-based sign-in policy (disable if requested)
            applySigninPolicy(signinButton, source);
        }
    }

    const fallbackMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-tiktok-fallback]');
    if (fallbackMenuItem) {
        if (source && target === 'tiktok') {
            const fallbackEnabled = !source.disableTikTokAutoFallback;
            fallbackMenuItem.classList.remove('hidden');
            fallbackMenuItem.classList.toggle('active', fallbackEnabled);
            fallbackMenuItem.textContent = fallbackEnabled
                ? '✅ TikTok auto-fallback enabled'
                : '🚫 TikTok auto-fallback disabled';
        } else {
            fallbackMenuItem.classList.add('hidden');
        }
    }

    if (target === 'tiktok') {
        applyTikTokClassicPreferenceToEntry(sourceElement, preferTikTokClassic || cliForcesTikTokClassic);
    }

    // Disable/enable mode selector panel when active/inactive
    const modeSelector = controlPanel?.querySelector('.mode-selector');
    if (modeSelector) {
        if (isActive) {
            modeSelector.style.pointerEvents = 'none';
            modeSelector.style.opacity = '0.5';
            modeSelector.title = 'Stop source to change mode';
        } else {
            modeSelector.style.pointerEvents = '';
            modeSelector.style.opacity = '';
            modeSelector.title = '';
        }
    }
}


async function setSourceConnectionMode(sourceElement, mode, clickedMenuItemOrPanelButton) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source) return;

    const forcingClassic = preferTikTokClassic || cliForcesTikTokClassic;
    const isTikTokApiMode = mode === 'tiktok-websocket' || mode === 'tiktok-legacy';
    if (source.target === 'tiktok' && isTikTokApiMode && forcingClassic) {
        Toast.info('TikTok Classic', cliForcesTikTokClassic
            ? 'Classic mode is locked by launch flag.'
            : 'Disable the global TikTok Classic preference to use TikTok API connectors.');
        return;
    }
    if (clickedMenuItemOrPanelButton && clickedMenuItemOrPanelButton.dataset?.disabled === 'true') {
        Toast.info('TikTok Classic', cliForcesTikTokClassic
            ? 'Classic mode is locked by launch flag.'
            : 'Disable the global TikTok Classic preference to use TikTok API connectors.');
        return;
    }

    console.log(`[Mode Switch] Setting connection mode for ${sourceId} from ${source.connectionMode} to ${mode}`);

    // If source is active, block changing modes until stopped
    if (source.vid || source.wssId) {
        if (clickedMenuItemOrPanelButton) {
            try { clickedMenuItemOrPanelButton.title = 'Stop source to change mode'; } catch (e) {}
        }
        Toast.warning('Mode Locked', 'Stop the current connection before changing modes.');
        return;
    }

    stateManager.updateSource(sourceId, { connectionMode: mode, activeConnectionMode: null });

    if (source.target === 'tiktok') {
        const allowedLastModes = new Set(['classic', 'tiktok-websocket', 'tiktok-legacy']);
        const normalizedMode = allowedLastModes.has(mode) ? mode : lastTikTokMode;
        if (normalizedMode && allowedLastModes.has(normalizedMode) && normalizedMode !== lastTikTokMode) {
            lastTikTokMode = normalizedMode;
            if (stateManager.state?.global?.lastTikTokMode !== normalizedMode) {
                stateManager.updateGlobal({ lastTikTokMode: normalizedMode });
            }
        }
    }

    if (clickedMenuItemOrPanelButton && clickedMenuItemOrPanelButton.classList.contains('settings-menu-item')) {
        const mainActivateButton = sourceElement.querySelector('[data-activatehtml]');
        if (mainActivateButton && !mainActivateButton.classList.contains('hidden')) {
            await createWindow(mainActivateButton); 
        }
    }
}


function setupSourceControls(sourceElement) {
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    const isGroupHeader = sourceElement.dataset.isGroupHeader === "true";


    const settingsBtn = sourceElement.querySelector('.settings-btn');
    const settingsMenu = sourceElement.querySelector('.settings-menu');
    if (!settingsBtn || !settingsMenu) return;

    const target = source ? source.target : sourceElement.dataset.target;
    const username = source ? source.username : sourceElement.dataset.username; 
    const controlPanel = sourceElement.querySelector('.control-panel');


    let connectionModesSection = settingsMenu?.querySelector('.connection-modes');
    if (!connectionModesSection && settingsMenu) {
        connectionModesSection = document.createElement('div');
        connectionModesSection.className = 'settings-menu-section connection-modes';

        const connectionHeader = document.createElement('div');
        connectionHeader.className = 'settings-menu-header';
        connectionHeader.textContent = 'Connection Modes';
        connectionModesSection.appendChild(connectionHeader);

        const createConnectionItem = (icon, label, dataset, handler) => {
            const item = document.createElement('div');
            item.className = 'settings-menu-item';
            Object.entries(dataset || {}).forEach(([key, value]) => {
                item.dataset[key] = value;
            });
            const iconElement = document.createElement('i');
            iconElement.textContent = icon;
            item.appendChild(iconElement);
            const labelSpan = document.createElement('span');
            labelSpan.textContent = label;
            item.appendChild(labelSpan);
            if (handler) {
                item.setAttribute('onclick', handler);
            }
            return item;
        };

        const classicItem = createConnectionItem('📄', translate('source.mode.standard'), { action: 'classic-mode' }, 'setClassicMode(this)');
        const genericWsItem = createConnectionItem('🌐', translate('source.mode.websocket'), { wss: 'true' }, "setSourceConnectionMode(this.closest('.entry'), 'websocket', this)");
        const tiktokWsItem = createConnectionItem('🌐', translate('source.mode.websocket'), { tiktokwss: 'true' }, "setSourceConnectionMode(this.closest('.entry'), 'tiktok-websocket', this)");
        const tiktokLegacyItem = createConnectionItem('🕰️', translate('source.mode.legacy'), { tiktoklegacy: 'true' }, "setSourceConnectionMode(this.closest('.entry'), 'tiktok-legacy', this)");
        tiktokWsItem.classList.add('hidden');
        tiktokLegacyItem.classList.add('hidden');

        connectionModesSection.appendChild(classicItem);
        connectionModesSection.appendChild(genericWsItem);
        connectionModesSection.appendChild(tiktokWsItem);
        connectionModesSection.appendChild(tiktokLegacyItem);

        const sourceManagementSection = settingsMenu.querySelector('.settings-menu-section:nth-last-child(1)');
        if (sourceManagementSection) {
            settingsMenu.insertBefore(connectionModesSection, sourceManagementSection);
        } else {
            settingsMenu.appendChild(connectionModesSection);
        }
    }

    const classicMenuItem = settingsMenu.querySelector('.settings-menu-item[data-action="classic-mode"]');
    const wssMenuItem = settingsMenu.querySelector('.settings-menu-item[data-wss="true"]');
    const tiktokWssMenuItem = settingsMenu.querySelector('.settings-menu-item[data-tiktokwss="true"]');
    const tiktokLegacyMenuItem = settingsMenu.querySelector('.settings-menu-item[data-tiktoklegacy="true"]');

    let isYouTube = target && target.startsWith('youtube');
    let isTikTok = target === 'tiktok';
    let genericWsSupported = false;
    
    // Check if platform supports websockets
    if (!isYouTube && !isTikTok && target) { 
        // Check manifest for websocket support
        genericWsSupported = manifest?.content_scripts?.some(cs => 
            cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
        );
    }
    
    // For YouTube entries, websocket is supported
    if (isYouTube) {
        genericWsSupported = true;
    }
    
    if (isTikTok) {
        wssMenuItem?.classList.add('hidden');
        tiktokWssMenuItem?.classList.remove('hidden');
        tiktokLegacyMenuItem?.classList.remove('hidden');
        
        // Add TikTok-specific mode selector
        let modeSelector = controlPanel?.querySelector('.mode-selector');
        if (!modeSelector && controlPanel) {
            modeSelector = document.createElement('div');
            modeSelector.className = 'mode-selector';
            modeSelector.innerHTML = `
                <div class="mode-selector-label">Connection Mode:</div>
                <div class="mode-options">
                    <div class="mode-option" 
                         data-mode="classic" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'classic', this); updateModeSelector(this)">
                        📄 Standard
                    </div>
                    <div class="mode-option" 
                         data-mode="tiktok-websocket" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'tiktok-websocket', this); updateModeSelector(this)">
                        🌐 TikTok WS
                    </div>
                    <div class="mode-option" 
                         data-mode="tiktok-legacy" 
                         onclick="setSourceConnectionMode(this.closest('.entry'), 'tiktok-legacy', this); updateModeSelector(this)">
                        🕰️ Legacy
                    </div>
                </div>
                <div class="mode-info">
                    <span class="info-icon" title="WebSocket uses the new v2.x signer (read-only). Legacy uses the former v1.x bridge. Standard opens a browser window.">ℹ️</span>
                </div>`;
            controlPanel.appendChild(modeSelector);
        }
        if (modeSelector) {
            modeSelector.classList.remove('hidden');
            // Update the active state based on current connection mode
            const fallbackMode = (preferTikTokClassic || cliForcesTikTokClassic) ? 'classic' : (lastTikTokMode || 'tiktok-websocket');
            const currentMode = source?.connectionMode || fallbackMode;
            modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.mode === currentMode) {
                    opt.classList.add('active');
                }
            });
        }
    } else {
        tiktokWssMenuItem?.classList.add('hidden');
        tiktokLegacyMenuItem?.classList.add('hidden');
        if (isYouTube || genericWsSupported) {
            wssMenuItem?.classList.remove('hidden');
            let modeSelector = controlPanel?.querySelector('.mode-selector');
            if (!modeSelector && controlPanel) { 
                modeSelector = document.createElement('div');
                modeSelector.className = 'mode-selector';
                modeSelector.innerHTML = `
                    <div class="mode-selector-label">Connection Mode:</div>
                    <div class="mode-options">
                        <div class="mode-option" 
                             data-mode="classic" 
                             onclick="setSourceConnectionMode(this.closest('.entry'), 'classic', this); updateModeSelector(this)">
                            📄 Standard
                        </div>
                        <div class="mode-option" 
                             data-mode="websocket" 
                             onclick="setSourceConnectionMode(this.closest('.entry'), 'websocket', this); updateModeSelector(this)">
                            🌐 WebSocket
                        </div>
                    </div>
                    <div class="mode-info">
                        <span class="info-icon" title="WebSocket mode uses less resources and provides additional data like followers/subs when signed in. Requires login for full features.">ℹ️</span>
                    </div>`;
                controlPanel.appendChild(modeSelector);
            }
            if (modeSelector) {
                modeSelector.classList.remove('hidden');
                // Update the active state based on current connection mode
                const currentMode = source?.connectionMode || 'classic';
                modeSelector.querySelectorAll('.mode-option').forEach(opt => {
                    opt.classList.remove('active');
                    if (opt.dataset.mode === currentMode) {
                        opt.classList.add('active');
                    }
                });
            }
        } else { 
            wssMenuItem?.classList.add('hidden');
            // Don't remove the mode selector if it exists
        }
    }

    const autoActivateToggleDiv = controlPanel?.querySelector('.auto-activate-toggle');
    if (autoActivateToggleDiv) {
        const checkbox = autoActivateToggleDiv.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.onchange = () => {
                if (sourceId) { 
                    stateManager.updateSource(sourceId, { autoActivate: checkbox.checked });
                } else if (isGroupHeader && sourceElement.dataset.groupId) { 
                    stateManager.updateGroup(sourceElement.dataset.groupId, { autoActivate: checkbox.checked });
                }
            };
        }
    }

    const fallbackMenuItem = settingsMenu?.querySelector('.settings-menu-item[data-tiktok-fallback]');
    if (fallbackMenuItem) {
        if (source && target === 'tiktok') {
            const fallbackDisabled = !!source.disableTikTokAutoFallback;
            fallbackMenuItem.classList.remove('hidden');
            fallbackMenuItem.classList.toggle('active', !fallbackDisabled);
            fallbackMenuItem.textContent = fallbackDisabled
                ? '🚫 TikTok auto-fallback disabled'
                : '✅ TikTok auto-fallback enabled';
        } else {
            fallbackMenuItem.classList.add('hidden');
        }
    }

    settingsBtn.onclick = (e) => {
        e.stopPropagation();
        document.querySelectorAll('.settings-menu.active').forEach(menu => {
            if (menu !== settingsMenu) menu.classList.remove('active');
        });
        settingsMenu.classList.toggle('active');
        if (settingsMenu.classList.contains('active')) {
            try { updateMoveMenuItemsForSource(sourceElement); } catch (e) { /* noop */ }
            // Update reply-only menu item visual state
            try {
                const s = sourceId ? stateManager.getSource(sourceId) : null;
                const roItem = settingsMenu.querySelector('.settings-menu-item[data-reply-only]');
                if (roItem && s) {
                    roItem.classList.toggle('active', !!s.replyOnly);
                    roItem.textContent = (s.replyOnly ? '✅ ' : '🤖 ') + 'Bot reply-only (no capture)';
                }
            } catch (_) {}
            try {
                const s = sourceId ? stateManager.getSource(sourceId) : null;
                const fallbackItem = settingsMenu.querySelector('.settings-menu-item[data-tiktok-fallback]');
                if (fallbackItem) {
                    if ( s && s.target === 'tiktok') {
                        const fallbackDisabled = !!s.disableTikTokAutoFallback;
                        fallbackItem.classList.remove('hidden');
                        fallbackItem.classList.toggle('active', !fallbackDisabled);
                        fallbackItem.textContent = fallbackDisabled
                            ? '🚫 TikTok auto-fallback disabled'
                            : '✅ TikTok auto-fallback enabled';
                    } else {
                        fallbackItem.classList.add('hidden');
                    }
                }
            } catch (_) {}
        }

        const currentSource = sourceId ? stateManager.getSource(sourceId) : null;
        const isActive = currentSource ? (!!currentSource.vid || !!currentSource.wssId) : false;
        const currentMode = currentSource ? currentSource.connectionMode : (sourceElement.dataset.lastConnectionMode || 'classic');
        const forcedClassic = (preferTikTokClassic || cliForcesTikTokClassic) && target === 'tiktok';

        settingsMenu.querySelectorAll('.connection-modes .settings-menu-item').forEach(item => {
            if (item.classList.contains('hidden')) return; 

            const itemMode = item.dataset.action === 'classic-mode' ? 'classic' :
                             item.dataset.wss === 'true' ? 'websocket' :
                             item.dataset.tiktokwss === 'true' ? 'tiktok-websocket' :
                             item.dataset.tiktoklegacy === 'true' ? 'tiktok-legacy' : null;

            const isSelected = itemMode === currentMode;
            item.dataset.selected = isSelected.toString(); 

            if (isActive) { 
                if (isSelected) { 
                    item.style.opacity = '1';
                    item.style.pointerEvents = 'auto';
                    item.title = 'Click to stop current connection';
                    const icon = item.querySelector('i');
                    if (icon) icon.textContent = '⏹️'; 
                } else { 
                    item.style.opacity = '0.5';
                    item.style.pointerEvents = 'none';
                    item.title = 'Stop current connection to change/activate another mode.';
                    const icon = item.querySelector('i');
                    if (icon) {
                        if (item.dataset.action === 'classic-mode') icon.textContent = '📄';
                        else if (item.dataset.wss === 'true' || item.dataset.tiktokwss === 'true') icon.textContent = '🌐';
                        else if (item.dataset.tiktoklegacy === 'true') icon.textContent = '🕰️';
                    }
                }
            } else { 
                item.style.opacity = '1';
                item.style.pointerEvents = 'auto';
                const icon = item.querySelector('i');
                if (item.dataset.action === 'classic-mode') {
                    item.title = 'Use standard browser window for this source';
                    if (icon) icon.textContent = '📄';
                } else if (item.dataset.wss === 'true') {
                    item.title = 'Connect to the API directly using WebSocket';
                     if (icon) icon.textContent = '🌐';
                } else if (item.dataset.tiktokwss === 'true') {
                    item.title = forcedClassic
                        ? (cliForcesTikTokClassic
                            ? 'TikTok API connectors are disabled by launch flag.'
                            : 'Disable the global TikTok Classic preference to use TikTok API connectors.')
                        : 'Connect to the TikTok API directly using WebSockets';
                    if (icon) icon.textContent = '🌐';
                } else if (item.dataset.tiktoklegacy === 'true') {
                    item.title = forcedClassic
                        ? (cliForcesTikTokClassic
                            ? 'TikTok API connectors are disabled by launch flag.'
                            : 'Disable the global TikTok Classic preference to use TikTok API connectors.')
                        : 'Use HTTP polling without signing.';
                    if (icon) icon.textContent = '🕰️';
                } else {
                    item.title = '';
                }
                if (!isActive && forcedClassic && (itemMode === 'tiktok-websocket' || itemMode === 'tiktok-legacy')) {
                    item.style.opacity = '0.5';
                    item.style.pointerEvents = 'none';
                }
            }
        });
    };
    document.addEventListener('click', (e) => { 
        if (!settingsMenu.classList.contains('active')) return;
        if (!settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
            settingsMenu.classList.remove('active');
        }
    });

    if (source) {
        updateSourceUIAfterModeChange(sourceElement, source.connectionMode, (source.status === 'active'));
    } else if (!isGroupHeader) { 
        updateSourceUIAfterModeChange(sourceElement, 'classic', false);
    }
    applyTikTokClassicPreferenceToEntry(sourceElement, preferTikTokClassic || cliForcesTikTokClassic);
}

// Toggle per-source reply-only mode (do not capture messages)
async function toggleReplyOnly(menuItem) {
    const entry = menuItem.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;
    const enabled = !source.replyOnly;
    stateManager.updateSource(sourceId, { replyOnly: enabled });
    // Update UI label
    menuItem.classList.toggle('active', enabled);
    menuItem.textContent = (enabled ? '✅ ' : '🤖 ') + 'Bot reply-only (no capture)';
    
    const wasActive = !!(source.vid || source.wssId);
    if (wasActive) {
        Toast.info('Restarting', 'Applying reply-only setting…');
        // Stop current connection/window
        try {
            const stopBtn = entry.querySelector('[data-stophtml]');
            const actBtn = entry.querySelector('[data-activatehtml]');
            if (actBtn && actBtn.dataset.connecting === 'true') {
                await stopThis(actBtn);
            } else if (stopBtn) {
                await stopThis(stopBtn);
            }
        } catch (e) { console.warn('Failed to stop before restart:', e); }
        // Small delay to allow state/UI settle
        await new Promise(r => setTimeout(r, 150));
        // Start again with updated setting
        try {
            const activateBtn = entry.querySelector('[data-activatehtml]');
            if (activateBtn) await createWindow(activateBtn);
            Toast.success('Updated', enabled ? 'Reply-only mode enabled and applied' : 'Reply-only mode disabled and applied');
        } catch (e) {
            console.error('Failed to restart after reply-only toggle:', e);
            Toast.error('Error', 'Failed to restart source. Try activating it again.');
        }
    } else {
        Toast.success('Updated', enabled ? 'Reply-only mode enabled' : 'Reply-only mode disabled');
    }
}

function toggleTikTokAutoFallback(menuItem) {
    const entry = menuItem.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source || source.target !== 'tiktok') {
        Toast.info('TikTok Fallback', 'Automatic fallback applies to TikTok sources only.');
        return;
    }

    const currentlyDisabled = !!source.disableTikTokAutoFallback;
    const nextDisabled = !currentlyDisabled;
    stateManager.updateSource(sourceId, { disableTikTokAutoFallback: nextDisabled });

    const enabled = !nextDisabled;
    menuItem.classList.toggle('active', enabled);
    menuItem.textContent = enabled
        ? '✅ TikTok auto-fallback enabled'
        : '🚫 TikTok auto-fallback disabled';
    if (entry._tiktokFallback) {
        entry._tiktokFallback.fallbackDisabled = nextDisabled;
        if (enabled) {
            entry._tiktokFallback.notifiedExhausted = false;
        }
    }
    Toast.success('TikTok Fallback', enabled
        ? 'Automatic fallback enabled for this source.'
        : 'Automatic fallback disabled for this source.');
}

// Ensure a default bot session exists
function ensureBotSession() {
    const key = 'customSessions';
    let sessions = [];
    try { sessions = JSON.parse(localStorage.getItem(key) || '[]'); } catch(_) { sessions = []; }
    if (!sessions.some(s => s.name === 'bot-account')) {
        sessions.push({ name: 'bot-account', created: Date.now(), description: 'Custom session for bot account' });
        localStorage.setItem(key, JSON.stringify(sessions));
    }
}

function normalizeUrlForMatch(u) {
    try {
        const url = new URL(u);
        return url.origin + url.pathname; // ignore query/hash for duplicate detection
    } catch (_) {
        return (u || '').trim();
    }
}

// If the source matches an existing one (same target + same videoId or URL),
// prompt to add as reply-only bot with its own session, and apply settings accordingly.
async function handleDuplicateForSource(sourceData) {
    try {
        const all = stateManager.getSources();
        const candidateTarget = sourceData.target;
        const candidateVid = (sourceData.videoId || '').trim();
        const candidateUrl = (sourceData.url || '').trim();
        const normalizedCandidateUrl = candidateUrl ? normalizeUrlForMatch(candidateUrl) : '';

        const dup = all.find(s => {
            if (!s || s.target !== candidateTarget) return false;
            if (candidateVid && s.videoId && s.videoId === candidateVid) return true;
            if (normalizedCandidateUrl && s.url && normalizeUrlForMatch(s.url) === normalizedCandidateUrl) return true;
            return false;
        });

        if (dup) {
            const wantsBot = window.confirm('A source for this video/URL already exists.\n\nAdd this as a reply-only bot source with its own browser session? It will not capture messages, but will still let you send them.');
            if (wantsBot) {
                // Enable reply-only and assign a bot session
                sourceData.replyOnly = true;
                ensureBotSession();
                sourceData.customSession = 'bot-account';
            }
        }
    } catch (e) {
        console.warn('Duplicate check failed:', e);
    }
    return sourceData;
}

function getSessionDisplayNameForSource(source) {
    try {
        const defaults = {
            'youtube': 'YouTube Default',
            'youtubeshorts': 'YouTube Default',
            'twitch': 'Twitch Default',
            'kick': 'Kick Default',
            'tiktok': 'TikTok Default',
            'facebook': 'Facebook Default',
            'instagramlive': 'Instagram Default',
            'instagram': 'Instagram Default',
            'x': 'X.com Default',
            'rumble': 'Rumble Default'
        };
        let sess = source.customSession || 'AUTO';
        if (sess === 'AUTO') {
            return defaults[source.target] || 'Default';
        }
        if (sess === 'default' || sess === `default-${source.target}`) {
            return defaults[source.target] || 'Default';
        }
        return sess;
    } catch (_) {
        return 'Default';
    }
}

function setClassicMode(menuItemElement) { 
    const sourceElement = menuItemElement.closest('.entry');
    if (!sourceElement) return;
    setSourceConnectionMode(sourceElement, 'classic', menuItemElement);
}

async function activateSource(ele) {
    const parentElement = ele.closest('.entry');
    if (!parentElement) {
        console.error("activateSource: Could not find parent .entry");
        return;
    }
    const sourceId = parentElement.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    const isTikTokWebsocketAttempt = !!(source && source.target === 'tiktok' && (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy') && !source.wssId);

    if (isTikTokWebsocketAttempt) {
        updateConnectionStatus(parentElement, 'connecting');
        setActivateButtonConnecting(parentElement);
        await waitForNextRender();
    }

    let windowId;
    try {
        windowId = await createWindow(ele);
    } catch (err) {
        if (isTikTokWebsocketAttempt) {
            updateConnectionStatus(parentElement, 'clear');
            restoreActivateButton(parentElement);
        }
        throw err;
    }

    if (isTikTokWebsocketAttempt && !windowId) {
        updateConnectionStatus(parentElement, 'clear');
        restoreActivateButton(parentElement);
        return;
    }

    // For classic mode, add a subtle reminder to verify chat/sign-in
    try {
        const sid = parentElement.dataset.sourceId;
        const src = sid ? stateManager.getSource(sid) : null;
        if (src && (src.connectionMode === 'classic')) {
            updateConnectionStatus(parentElement, 'info', 'Reminder: After the window opens, sign in (if required) and confirm the chat is visible.');
        }
    } catch (_) {}
}

/* Modified toggleSourceVisibility */
function toggleSourceVisibility(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source || !source.vid) {
        Toast.info("Info", "Source must be active to toggle visibility.");
        return;
    }
    
    const desiredUiState = !source.isVisible; // What the UI should become

    // Because main.js showWindow handler has inverted logic for explicit state:
    // if desiredUiState is true (want to show), send state: false to main
    // if desiredUiState is false (want to hide), send state: true to main
    const stateToSendToMain = !desiredUiState;

    console.log(`toggleSourceVisibility: sourceId=${sourceId}, current IsVisible=${source.isVisible}, desired UI State=${desiredUiState}, sending to main=${stateToSendToMain}`);

    if (!ipcRenderer) {
        console.error("ipcRenderer not available for toggleSourceVisibility");
        Toast.error("IPC Error", "Cannot communicate with main process.");
        return;
    }

    
    ipcRenderer.invoke('showWindow', {
        vid: source.vid,
        state: stateToSendToMain 
    }).then(responseFromMain => {
        // responseFromMain should be the *actual* new visibility state from main process
        let actualNewState = desiredUiState; // Default to desired if main doesn't respond clearly

        if (responseFromMain !== undefined && typeof responseFromMain.newState === 'boolean') {
            actualNewState = responseFromMain.newState;
        } else if (typeof responseFromMain === 'boolean') { // If main process just returns the boolean state
            actualNewState = responseFromMain;
        } else {
             console.warn('toggleSourceVisibility: Unexpected response from main process for showWindow IPC. Assuming desired state.', responseFromMain);
        }
        
        console.log(`toggleSourceVisibility: main process responded with actualNewState=${actualNewState}. Updating stateManager.`);
        stateManager.updateSource(sourceId, { isVisible: actualNewState });

    }).catch(error => {
        console.error("Error in toggleSourceVisibility IPC:", error);
        Toast.error("Visibility Error", "Could not toggle window visibility. Check console for details.");
        // Optionally, revert UI or state if IPC fails catastrophically, though sourceUpdated should handle UI
    });
}


function toggleSourceMute(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;

    const newMuteState = !source.isMuted;
    console.log(`Toggling mute for ${sourceId}: ${source.isMuted} -> ${newMuteState}`);
    
    // Update the state first
    stateManager.updateSource(sourceId, { isMuted: newMuteState });
    
    // Update UI immediately
    const button = ele;
    button.textContent = newMuteState ? '🔇' : '🔊';
    
    // If the window is active, also update the actual mute state
    if (source.vid && ipcRenderer) {
        console.log(`Sending mute command to window ${source.vid}: ${newMuteState}`);
        ipcRenderer.sendSync('muteWindow', {
            vid: source.vid,
            muteWindow: newMuteState
        });
    }
    
    // Verify the state was saved
    const updatedSource = stateManager.getSource(sourceId);
    console.log(`Mute state after update: ${updatedSource.isMuted}`);
}

async function deleteThis(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;

    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;

    if (sourceId) { 
        const source = stateManager.getSource(sourceId);
        if (source) {
            if (source.wssId && source.target === 'tiktok') {
                try {
                    if (ipcRenderer) await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
                } catch (e) { console.warn('Error disconnecting TikTok WSS during delete:', e); }
            } else if (source.vid) { 
                try {
                    if (ipcRenderer) await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
                } catch (e) { console.warn('Error closing window/WSS during delete:', e); }
            }
            stateManager.removeSource(sourceId); 
        }
    } else if (groupId) { 
        const group = stateManager.getGroup(groupId);
        if (group) {
            stateManager.removeGroup(groupId); 
        }
    }
    manageWelcomePage();
}

async function clearAllSources() {
    if (typeof stateManager === 'undefined') return;

    const sourcesSnapshot = stateManager.getSources();
    const groupsSnapshot = stateManager.getGroups ? stateManager.getGroups() : [];

    if (sourcesSnapshot.length === 0 && groupsSnapshot.length === 0) {
        if (typeof Toast !== 'undefined' && Toast?.info) {
            Toast.info('Nothing to Clear', 'No sources or groups are currently configured.');
        }
        return;
    }

    if (ipcRenderer) {
        const closedWindows = new Set();
        const disconnectedWss = new Set();
        for (const source of sourcesSnapshot) {
            if (!source) continue;
            if (source.target === 'tiktok' && source.wssId && !disconnectedWss.has(source.wssId)) {
                try {
                    ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
                } catch (e) {
                    console.warn('Failed to disconnect TikTok connection during clear-all-sources:', e);
                }
                disconnectedWss.add(source.wssId);
            }
            if (source.vid && !closedWindows.has(source.vid)) {
                try {
                    ipcRenderer.sendSync('closeWindow', { vid: source.vid });
                } catch (e) {
                    console.warn('Failed to close window during clear-all-sources:', e);
                }
                closedWindows.add(source.vid);
            }
        }
    }

    if (typeof stateManager.clearAllSourcesAndGroups === 'function') {
        stateManager.clearAllSourcesAndGroups();
    } else {
        groupsSnapshot.forEach(group => group?.id && stateManager.removeGroup(group.id));
        const remaining = stateManager.getSources();
        remaining.forEach(src => src?.id && stateManager.removeSource(src.id));
        if (typeof setRootOrder === 'function') {
            try { setRootOrder([]); } catch (e) { /* ignore */ }
        }
    }
    manageWelcomePage();

    if (typeof Toast !== 'undefined' && Toast?.success) {
        Toast.success('Sources Cleared', 'All sources and groups have been removed.');
    }
}


// ----- Reordering Helpers -----
function getRootOrder() {
    try {
        const ro = stateManager?.state?.global?.rootOrder;
        return Array.isArray(ro) ? ro.slice() : [];
    } catch (e) { return []; }
}

function setRootOrder(order) {
    try {
        stateManager.updateGlobal({ rootOrder: order });
    } catch (e) {
        console.warn('Failed to set rootOrder', e);
    }
}

function topLevelContainer() {
    return document.getElementById('sources');
}

function keyForTopLevelElement(el) {
    if (!el) return null;
    const gid = el.dataset.groupId;
    if (gid) return `g:${gid}`;
    const sid = el.dataset.sourceId;
    if (sid) return `s:${sid}`;
    return null;
}

function elementForTopLevelKey(key) {
    if (!key || typeof key !== 'string') return null;
    if (key.startsWith('g:')) {
        const gid = key.slice(2);
        return document.querySelector(`[data-group-id="${gid}"]`);
    }
    if (key.startsWith('s:')) {
        const sid = key.slice(2);
        // Only return standalone source if it's a direct child of #sources
        const el = document.querySelector(`[data-source-id="${sid}"]`);
        if (el && el.parentElement && el.parentElement.id === 'sources') return el;
        return null;
    }
    return null;
}

function buildTopLevelKeysFromDom() {
    const container = topLevelContainer();
    const keys = [];
    if (!container) return keys;
    const children = container.querySelectorAll(':scope > .entry:not(#sourceTemplate):not(#groupTemplate)');
    children.forEach(el => {
        const key = keyForTopLevelElement(el);
        if (key) keys.push(key);
    });
    return keys;
}

function reorderTopLevelDomAccordingToRootOrder() {
    const container = topLevelContainer();
    if (!container) return;
    let order = getRootOrder();
    const presentKeys = buildTopLevelKeysFromDom();
    // Filter to only present keys
    order = order.filter(k => presentKeys.includes(k));
    // Append any missing present keys (new items) at the end
    presentKeys.forEach(k => { if (!order.includes(k)) order.push(k); });
    // Re-append children in specified order
    order.forEach(k => {
        const el = elementForTopLevelKey(k);
        if (el) container.appendChild(el);
    });
    // Persist normalized order
    setRootOrder(order);
}

function applyRootOrder() {
    try { reorderTopLevelDomAccordingToRootOrder(); } catch (e) { console.warn('applyRootOrder failed', e); }
}

function reorderGroupDom(groupId) {
    const group = stateManager.getGroup(groupId);
    if (!group) return;
    const container = document.querySelector(`[data-group-id="${groupId}"] .stream-group`);
    if (!container) return;
    (group.streams || []).forEach(sourceId => {
        const el = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (el) container.appendChild(el);
    });
}

function updateMoveMenuItemsForSource(sourceElement) {
    const moveUp = sourceElement.querySelector('.settings-menu-item[data-move="up"]');
    const moveDown = sourceElement.querySelector('.settings-menu-item[data-move="down"]');
    if (!moveUp || !moveDown) return;
    moveUp.classList.remove('disabled');
    moveDown.classList.remove('disabled');

    const sourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;

    if (source.groupId) {
        const group = stateManager.getGroup(source.groupId);
        if (!group) return;
        const idx = group.streams.indexOf(sourceId);
        if (idx <= 0) moveUp.classList.add('disabled');
        if (idx === -1 || idx >= group.streams.length - 1) moveDown.classList.add('disabled');
    } else {
        // Top-level
        const keys = getRootOrder().length ? getRootOrder() : buildTopLevelKeysFromDom();
        const key = `s:${sourceId}`;
        const idx = keys.indexOf(key);
        if (idx <= 0) moveUp.classList.add('disabled');
        if (idx === -1 || idx >= keys.length - 1) moveDown.classList.add('disabled');
    }
}

function updateMoveMenuItemsForGroup(groupHeaderElement) {
    const moveUp = groupHeaderElement.querySelector('.settings-menu-item[data-group-move="up"]');
    const moveDown = groupHeaderElement.querySelector('.settings-menu-item[data-group-move="down"]');
    if (!moveUp || !moveDown) return;
    moveUp.classList.remove('disabled');
    moveDown.classList.remove('disabled');

    const groupId = groupHeaderElement.dataset.groupId;
    const keys = getRootOrder().length ? getRootOrder() : buildTopLevelKeysFromDom();
    const key = `g:${groupId}`;
    const idx = keys.indexOf(key);
    if (idx <= 0) moveUp.classList.add('disabled');
    if (idx === -1 || idx >= keys.length - 1) moveDown.classList.add('disabled');
}

function moveSourceInGroup(sourceId, direction) { // direction: -1 or +1
    const source = stateManager.getSource(sourceId);
    if (!source || !source.groupId) return;
    const group = stateManager.getGroup(source.groupId);
    if (!group || !Array.isArray(group.streams)) return;
    const idx = group.streams.indexOf(sourceId);
    if (idx === -1) return;
    const newIdx = idx + direction;
    if (newIdx < 0 || newIdx >= group.streams.length) return;
    const newStreams = group.streams.slice();
    const [moved] = newStreams.splice(idx, 1);
    newStreams.splice(newIdx, 0, moved);
    stateManager.updateGroup(group.id, { streams: newStreams });
    // Reorder DOM immediately for responsiveness
    reorderGroupDom(group.id);
    Toast.info('Reordered', `Moved source ${direction < 0 ? 'up' : 'down'} in group.`);
}

function moveTopLevelByKey(key, direction) { // direction: -1 or +1
    let order = getRootOrder();
    if (!order.length) order = buildTopLevelKeysFromDom();
    if (!order.includes(key)) order.push(key);
    const idx = order.indexOf(key);
    const newIdx = idx + direction;
    if (idx === -1 || newIdx < 0 || newIdx >= order.length) return;
    const swapped = order.slice();
    const [item] = swapped.splice(idx, 1);
    swapped.splice(newIdx, 0, item);
    setRootOrder(swapped);
    reorderTopLevelDomAccordingToRootOrder();
    Toast.info('Reordered', `Moved ${key.startsWith('g:') ? 'group' : 'source'} ${direction < 0 ? 'up' : 'down'}.`);
}

function moveSourceUp(menuItem) {
    const sourceElement = menuItem.closest('[data-source-id]');
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;
    if (source.groupId) return moveSourceInGroup(sourceId, -1);
    return moveTopLevelByKey(`s:${sourceId}`, -1);
}

function moveSourceDown(menuItem) {
    const sourceElement = menuItem.closest('[data-source-id]');
    if (!sourceElement) return;
    const sourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(sourceId);
    if (!source) return;
    if (source.groupId) return moveSourceInGroup(sourceId, +1);
    return moveTopLevelByKey(`s:${sourceId}`, +1);
}

function moveGroupUp(menuItem) {
    const groupElement = menuItem.closest('[data-group-id]');
    if (!groupElement) return;
    const groupId = groupElement.dataset.groupId;
    return moveTopLevelByKey(`g:${groupId}`, -1);
}

function moveGroupDown(menuItem) {
    const groupElement = menuItem.closest('[data-group-id]');
    if (!groupElement) return;
    const groupId = groupElement.dataset.groupId;
    return moveTopLevelByKey(`g:${groupId}`, +1);
}


async function stopThis(ele) {
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    const source = stateManager.getSource(sourceId);
    if (!source) return;
    const effectiveMode = getEffectiveConnectionMode(source) || source.connectionMode;
    
    if (ele.dataset.connecting === "true" && source.target === 'tiktok' && (effectiveMode === 'tiktok-websocket' || effectiveMode === 'tiktok-legacy')) {
        cancelPendingTikTokActivation(sourceId);
        if (source.wssId && ipcRenderer) { 
            try {
                await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
            } catch (e) { console.warn("Error stopping TikTok connection attempt:", e); }
        }
        // Clear any local countdown and UI
        if (entry._tiktokRetryTimer) {
            clearInterval(entry._tiktokRetryTimer);
            entry._tiktokRetryTimer = null;
        }
        entry._tiktokRetryEndAt = null;
        entry._tiktokRetryAttempt = null;
        entry._tiktokRetryMax = null;
        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null, activeConnectionMode: null });
        // Update UI status
        updateConnectionStatus(entry, 'stopped', "Stopping...");
        setTimeout(() => updateConnectionStatus(entry, 'clear'), 500);

        // Restore the main activate button to default action so user can start again
        restoreActivateButton(entry);
        entry._tiktokFallback = null;
        return;
    }

    if (source.vid || source.wssId) {
        try {
            if (source.target === 'tiktok' && (effectiveMode === 'tiktok-websocket' || effectiveMode === 'tiktok-legacy') && source.wssId && ipcRenderer) {
                await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
            } else if (source.vid && ipcRenderer) { 
                await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
            }
        } catch (error) {
            console.error('Error in stopThis during IPC call:', error);
        }
        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null, activeConnectionMode: null });
        if (source.target === 'tiktok') updateConnectionStatus(entry, 'clear');

        // Restore activate button for any stop
        restoreActivateButton(entry);
        entry._tiktokFallback = null;
        
        // For Rumble sources, clear video ID and chat ID for username-based sources
        if (source.target === 'rumble' && source.username && (source.videoId || source.chatId)) {
            stateManager.updateSource(sourceId, { videoId: null, chatId: null, url: null });
        }
        
        // Restart auto-check for Rumble sources with auto-activate
        if (source.target === 'rumble' && source.autoActivate) {
            console.log(`Restarting auto-check for deactivated Rumble source: ${source.username}`);
            setTimeout(() => {
                startRumbleAutoCheck(sourceId);
            }, 1000); // Small delay before restarting
        }
    }
}

function setActivateButtonConnecting(entryElement) {
    if (!entryElement) return;
    const activateButton = entryElement.querySelector('[data-activatehtml]');
    if (!activateButton) return;
    activateButton.classList.remove('hidden');
    activateButton.dataset.connecting = 'true';
    activateButton.textContent = '⏹️ Stop connecting';
    activateButton.onclick = function() { stopThis(this); };
}

function restoreActivateButton(entryElement) {
    if (!entryElement) return;
    const activateButton = entryElement.querySelector('[data-activatehtml]');
    if (!activateButton) return;
    delete activateButton.dataset.connecting;

    const sourceId = entryElement.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    const preferredMode = source?.connectionMode || 'classic';
    const activeMode = source ? (getEffectiveConnectionMode(source) || preferredMode) : preferredMode;
    const target = source?.target;

    if (target === 'tiktok') {
        if (activeMode === 'tiktok-websocket') {
            activateButton.textContent = 'Connect TikTok WebSocket';
        } else if (activeMode === 'tiktok-legacy') {
            activateButton.textContent = 'Connect TikTok Legacy';
        } else {
            activateButton.textContent = translate('btn.activate');
        }
    } else if (activeMode === 'websocket') {
        activateButton.textContent = 'Connect WebSocket';
    } else {
        activateButton.textContent = translate('btn.activate');
    }

    activateButton.onclick = function() { activateSource(this); };
}

function waitForNextRender() {
    return new Promise(resolve => {
        if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(() => resolve());
        } else {
            setTimeout(resolve, 0);
        }
    });
}

const STALE_CONNECTION_STATUSES = new Set(['activating', 'active', 'connected', 'reconnecting']);

const pendingTikTokActivations = new Map();
let tikTokActivationTokenSeed = 0;

function beginPendingTikTokActivation(sourceId) {
    const token = ++tikTokActivationTokenSeed;
    pendingTikTokActivations.set(sourceId, token);
    return token;
}

function isPendingTikTokActivationCurrent(sourceId, token) {
    return pendingTikTokActivations.get(sourceId) === token;
}

function markPendingTikTokActivationComplete(sourceId, token) {
    if (token && isPendingTikTokActivationCurrent(sourceId, token)) {
        pendingTikTokActivations.delete(sourceId);
    }
}

function cancelPendingTikTokActivation(sourceId) {
    pendingTikTokActivations.delete(sourceId);
}


async function clearThis(ele) {
	const entry = ele.closest('.entry');
    if (!entry) return;
    
    let idsToClear = [];
    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;

    if (sourceId) {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid) idsToClear.push(source.vid);
    } else if (groupId) {
        const group = stateManager.getGroup(groupId);
        if (group) {
            group.streams.forEach(sId => {
                const stream = stateManager.getSource(sId);
                if (stream && stream.vid) idsToClear.push(stream.vid);
            });
        }
    }

	if (idsToClear.length === 0) {
		Toast.info("Info", "No active sources to clear cache for.");
		return;
	}

    const buttonText = ele.textContent;
    ele.textContent = idsToClear.length > 1 ? 'Clearing All...' : 'Clearing...';
    ele.disabled = true;

    for (const vid of idsToClear) {
        if (ipcRenderer) {
            try {
                const result = await ipcRenderer.invoke('clearWindowCache', vid); 
                if (!result.success) {
                    console.error('Failed to clear cache for', vid, result.error);
                    Toast.error("Error", `Cache clear failed for source window ${vid}.`);
                }
            } catch (error) {
                console.error('Error invoking clearWindowCache for', vid, error);
                Toast.error("Error", `Error clearing cache for source window ${vid}.`);
            }
        }
    }
    Toast.success("Success", `Cache cleared for ${idsToClear.length} source(s).`);
    ele.textContent = buttonText;
    ele.disabled = false;
}

async function refreshWindow(ele) {
	const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const groupId = entry.dataset.groupId;
    if (!sourceId && !groupId) return;

    if (sourceId) {
        const source = stateManager.getSource(sourceId);
        if (source && source.vid && ipcRenderer) {
            ipcRenderer.sendSync('reloadWindow', { 
                tab: source.vid 
            });
        }
        return;
    }

    if (groupId && ipcRenderer) {
        const group = stateManager.getGroup(groupId);
        if (!group) return;
        let refreshedCount = 0;
        (group.streams || []).forEach(childId => {
            const childSource = stateManager.getSource(childId);
            if (childSource && childSource.vid) {
                ipcRenderer.sendSync('reloadWindow', { tab: childSource.vid });
                refreshedCount++;
            }
        });
        if (refreshedCount === 0) {
            Toast.info("Refresh Info", "No active group sources to refresh.");
        } else if (refreshedCount > 1) {
            Toast.info("Refresh Info", `Refreshed ${refreshedCount} active sources in this group.`);
        }
    }
}

async function createWindow(ele, tabid = false) { 
	if (!ele) { console.error('No element provided to createWindow'); return false; }
	if (!configReady) { 
        Toast.error("Config Error", "Configuration not ready. Please wait or check console.");
        return false;
    }

	const entry = ele.closest('.entry');
	if (!entry) { console.error("Could not find entry for createWindow"); return false; }
    
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) { console.error("No sourceId on entry for createWindow"); return false; }

    const source = stateManager.getSource(sourceId);
    console.log(`[CREATEWINDOW DEBUG] Source ID: ${sourceId}, Source:`, source);
    if (!source) { console.error("Source not found in stateManager:", sourceId); return false; }

    const target = source.target; // Move this declaration up before it's used

	if (source.vid || source.wssId) {
		console.log('Window/connection already active for this entry:', source.vid || source.wssId);
		console.log(`[Window Mapping Debug] Source ${sourceId} state:`, {
			vid: source.vid,
			wssId: source.wssId,
			connectionMode: source.connectionMode,
			target: source.target,
			username: source.username
		});
		
		// Check if we're switching connection modes
		const currentMode = source.connectionMode;
		const isTikTokModeSwitch = target === 'tiktok' && 
			(((currentMode === 'tiktok-websocket' || currentMode === 'tiktok-legacy') && source.vid && source.vid < 900000) || // Was classic, now websocket
			 (currentMode === 'classic' && source.vid && source.vid > 900000)); // Was websocket, now classic
		
		if (isTikTokModeSwitch) {
			console.log(`[Mode Switch] Switching TikTok from ${source.vid > 900000 ? 'websocket' : 'classic'} to ${currentMode}`);
			// Close the old connection/window
			try {
				if (source.vid > 900000 && source.wssId) {
					// Close websocket connection
					await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: source.wssId });
				} else if (source.vid) {
					// Close classic window
					await ipcRenderer.sendSync('closeWindow', { vid: source.vid });
				}
			} catch (e) {
				console.warn('Error closing old connection during mode switch:', e);
			}
			// Clear the old IDs
			stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive', activeConnectionMode: null });
		} else {
			// Verify the window actually exists before reusing the ID
			if (source.vid && ipcRenderer) {
				const windowExists = await ipcRenderer.invoke('checkWindowExists', { vid: source.vid });
				if (!windowExists) {
					stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive', activeConnectionMode: null });
				} else {
					return source.vid;
				}
			} else if (source.wssId && target === 'tiktok' && (currentMode === 'tiktok-websocket' || currentMode === 'tiktok-legacy')) {
				// For TikTok websocket, we need to check if the connection still exists
				// The wssId alone doesn't mean the connection is active
				// Clear the stale wssId and allow new connection
				stateManager.updateSource(sourceId, { vid: null, wssId: null, status: 'inactive', activeConnectionMode: null });
				return false;
			} else if (source.wssId) {
				return source.wssId;
			}
		}
	}

    let mode = source.connectionMode;
    // target already declared above
    if (target === 'tiktok') {
        const forcedClassic = preferTikTokClassic || cliForcesTikTokClassic;
        if (forcedClassic && (mode === 'tiktok-websocket' || mode === 'tiktok-legacy')) {
            mode = 'classic';
            stateManager.updateSource(sourceId, { connectionMode: 'classic' });
            updateSourceUIAfterModeChange(entry, 'classic', false);
        }
    }
    
    // Validate connection mode - force classic for platforms without websocket support
    if (mode === 'websocket' && !source.supportsWSS) {
        // Check WebSocket support if not already stored
        const hasWebSocketSupport = (target === 'tiktok') || 
            (typeof manifest !== 'undefined' && manifest?.content_scripts?.some(cs => 
                cs.js?.some(jsFile => jsFile.includes(`websocket/${target}.js`))
            ));
        
        if (!hasWebSocketSupport) {
            console.log(`Platform ${target} doesn't support websocket, switching to classic mode`);
            mode = 'classic';
            // Update the source to reflect the correct mode
            stateManager.updateSource(sourceId, { connectionMode: 'classic', supportsWSS: false });
        }
    }
    
    const windowId = await attemptActivationModes({
        sourceId,
        entry,
        initialMode: mode,
        tabid
    });
    return windowId;
}

async function attemptActivationModes({ sourceId, entry, initialMode, tabid, reuseFallbackState = false }) {
    const source = stateManager.getSource(sourceId);
    if (!source) {
        console.warn('attemptActivationModes: source missing', sourceId);
        return false;
    }

    const target = source.target;
    const preferredMode = source.connectionMode || initialMode || 'classic';
    const preferredNormalized = target === 'tiktok'
        ? normalizeTikTokMode(preferredMode)
        : preferredMode;

    const resolvedEntry = entry || document.querySelector(`[data-source-id="${sourceId}"]`);

    if (target !== 'tiktok') {
        const result = await performActivationAttempt({
            sourceId,
            entry: resolvedEntry,
            tabid,
            mode: initialMode,
            target
        });
        return result.success ? result.windowId : false;
    }

    const fallbackLockedToClassic = (preferTikTokClassic || cliForcesTikTokClassic);
    const fallbackDisabled = fallbackLockedToClassic || !!source.disableTikTokAutoFallback;

    let fallbackState = resolvedEntry ? resolvedEntry._tiktokFallback : null;
    let sequence;

    const fallbackStateNeedsReset = !reuseFallbackState ||
        !fallbackState ||
        fallbackState.preferredMode !== preferredNormalized ||
        fallbackState.forceClassic !== fallbackLockedToClassic;

    if (fallbackStateNeedsReset) {
        const baseSequence = fallbackLockedToClassic
            ? ['classic']
            : buildTikTokFallbackSequence(initialMode, preferredMode);
        sequence = [...baseSequence];
        fallbackState = {
            sequence,
            attempted: new Set(),
            preferredMode: preferredNormalized,
            fallbackDisabled,
            forceClassic: fallbackLockedToClassic,
            lastMode: null,
            connectedMode: null,
            pendingAutoRetry: false,
            autoRetryCount: 0,
            exhausted: false,
            lastFailureStatus: null,
            lastFailureMessage: null,
            lastError: null,
            inProgress: false,
            lastAttemptAt: null,
            lastSuccessAt: null,
            notifiedExhausted: false
        };
        if (resolvedEntry) {
            resolvedEntry._tiktokFallback = fallbackState;
        }
    } else {
        sequence = Array.isArray(fallbackState.sequence) && fallbackState.sequence.length
            ? fallbackState.sequence
            : (fallbackLockedToClassic
                ? ['classic']
                : buildTikTokFallbackSequence(initialMode, preferredMode));
        fallbackState.sequence = sequence;
        fallbackState.fallbackDisabled = fallbackDisabled;
        fallbackState.forceClassic = fallbackLockedToClassic;
        fallbackState.exhausted = false;
        fallbackState.notifiedExhausted = false;
    }

    const attempted = fallbackState?.attempted || new Set();
    let lastError = null;

    for (const candidate of sequence) {
        const normalizedCandidate = normalizeTikTokMode(candidate);
        if (attempted.has(normalizedCandidate)) {
            continue;
        }
        if (fallbackDisabled && normalizedCandidate !== preferredNormalized) {
            continue;
        }

        attempted.add(normalizedCandidate);

        if (fallbackState) {
            fallbackState.lastMode = normalizedCandidate;
            fallbackState.inProgress = true;
            fallbackState.lastAttemptAt = Date.now();
        }

        const result = await performActivationAttempt({
            sourceId,
            entry: resolvedEntry,
            tabid,
            mode: normalizedCandidate,
            target
        });

        if (fallbackState) {
            fallbackState.lastError = result.error || null;
            fallbackState.inProgress = false;
        }

        if (result.success) {
            if (fallbackState) {
                fallbackState.connectedMode = normalizedCandidate;
                fallbackState.pendingAutoRetry = false;
                fallbackState.lastFailureStatus = null;
                fallbackState.lastFailureMessage = null;
                fallbackState.autoRetryCount = 0;
                fallbackState.exhausted = false;
                fallbackState.lastSuccessAt = Date.now();
            }
            if (normalizedCandidate !== preferredNormalized) {
                notifyTikTokFallbackSuccess(resolvedEntry, preferredMode, normalizedCandidate);
            } else if (resolvedEntry) {
                updateConnectionStatus(resolvedEntry, 'connected');
            }
            return result.windowId;
        }

        lastError = result.error;
        if (result.error && result.error.message === 'Activation canceled') {
            break;
        }
        const fallbackInfo = result.fallbackInfo;

        if (fallbackDisabled) {
            break;
        }

        const allowClassicFallback = preferTikTokClassic || cliForcesTikTokClassic;
        if (allowClassicFallback && fallbackInfo && fallbackInfo.mode === 'classic' && !sequence.includes('classic')) {
            sequence.push('classic');
        }
    }

    if (fallbackState) {
        fallbackState.exhausted = true;
        fallbackState.lastFailureStatus = 'activation';
        fallbackState.lastFailureMessage = lastError ? lastError.message : null;
    }

    if (lastError) {
        console.error(`TikTok activation failed for ${sourceId} after fallback attempts:`, lastError);
        if (resolvedEntry) {
            updateConnectionStatus(resolvedEntry, 'error', lastError.message || 'TikTok activation failed');
        }
        if (!fallbackDisabled || attempted.size > 1) {
            const message = lastError.message || 'All TikTok modes failed to connect.';
            Toast.error('TikTok Error', message);
        }
    }
    return false;
}

function buildTikTokFallbackSequence(initialMode, preferredMode) {
    const order = [];
    const seen = new Set();
    const allowClassicFallback = preferTikTokClassic || cliForcesTikTokClassic;
    const pushMode = (mode) => {
        const normalized = normalizeTikTokMode(mode);
        if (!normalized || seen.has(normalized)) return;
        seen.add(normalized);
        order.push(normalized);
    };

    pushMode(initialMode);
    pushMode(preferredMode);
    ['tiktok-websocket', 'tiktok-legacy'].forEach(pushMode);
    if (allowClassicFallback) {
        pushMode('classic');
    }
    return order;
}

function normalizeTikTokMode(mode) {
    if (!mode || typeof mode !== 'string') return null;
    if (mode === 'websocket') return 'tiktok-websocket';
    if (mode === 'legacy') return 'tiktok-legacy';
    return mode;
}

function describeTikTokMode(mode) {
    const normalized = normalizeTikTokMode(mode);
    switch (normalized) {
        case 'tiktok-websocket':
            return 'TikTok WebSocket';
        case 'tiktok-legacy':
            return 'TikTok Legacy';
        case 'classic':
            return 'TikTok Standard';
        default:
            return normalized || 'Unknown';
    }
}

const TIKTOK_AUTO_FALLBACK_DELAY_MS = 2000;

function autoFallbackToNextTikTokMode(sourceId, failureStatus, errorMessage = null) {
    if (!sourceId) return;
    const source = stateManager.getSource(sourceId);
    if (!source || source.target !== 'tiktok') return;
    if (preferTikTokClassic || cliForcesTikTokClassic) return;
    if (source.disableTikTokAutoFallback) return;

    const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
    if (!entry) return;

    let fallbackState = entry._tiktokFallback;
    const preferredMode = normalizeTikTokMode(source.connectionMode || 'classic');
    if (!fallbackState) {
        const sequence = buildTikTokFallbackSequence(preferredMode, preferredMode);
        fallbackState = {
            sequence,
            attempted: new Set(),
            preferredMode,
            fallbackDisabled: !!source.disableTikTokAutoFallback,
            forceClassic: (preferTikTokClassic || cliForcesTikTokClassic),
            lastMode: null,
            connectedMode: null,
            pendingAutoRetry: false,
            autoRetryCount: 0,
            exhausted: false,
            lastFailureStatus: null,
            lastFailureMessage: null,
            lastError: null,
            inProgress: false,
            lastAttemptAt: null,
            lastSuccessAt: null,
            notifiedExhausted: false
        };
        entry._tiktokFallback = fallbackState;
    }

    if (fallbackState.fallbackDisabled || fallbackState.pendingAutoRetry) {
        return;
    }

    const attempted = (fallbackState.attempted instanceof Set) ? fallbackState.attempted : new Set();
    fallbackState.attempted = attempted;
    const sequence = Array.isArray(fallbackState.sequence) && fallbackState.sequence.length
        ? fallbackState.sequence
        : buildTikTokFallbackSequence(preferredMode, preferredMode);
    fallbackState.sequence = sequence;

    const lastKnownMode = normalizeTikTokMode(
        fallbackState.lastMode
        || source.activeConnectionMode
        || fallbackState.connectedMode
        || source.connectionMode
        || preferredMode
    );
    if (lastKnownMode) {
        attempted.add(lastKnownMode);
    }

    let nextMode = null;
    for (const candidate of sequence) {
        const normalizedCandidate = normalizeTikTokMode(candidate);
        if (!attempted.has(normalizedCandidate)) {
            nextMode = normalizedCandidate;
            break;
        }
    }

    if (!nextMode) {
        fallbackState.exhausted = true;
        if (!fallbackState.notifiedExhausted) {
            fallbackState.notifiedExhausted = true;
            const message = errorMessage || 'All TikTok connection modes failed. Try again later or disable automatic fallback.';
            Toast.error('TikTok Error', message);
        }
        return;
    }

    fallbackState.pendingAutoRetry = true;
    fallbackState.autoRetryCount = (fallbackState.autoRetryCount || 0) + 1;
    fallbackState.lastFailureStatus = failureStatus || null;
    fallbackState.lastFailureMessage = errorMessage || null;

    const fromLabel = describeTikTokMode(lastKnownMode);
    const toLabel = describeTikTokMode(nextMode);
    const statusMessage = errorMessage
        ? `${errorMessage} — Trying ${toLabel} after ${fromLabel} failed.`
        : `Trying ${toLabel} after ${fromLabel} failed.`;

    updateConnectionStatus(entry, 'info', statusMessage);
    Toast.info('TikTok Auto Fallback', `Trying ${toLabel} after ${fromLabel} failed.`);

    setTimeout(async () => {
        fallbackState.pendingAutoRetry = false;

        const latestSource = stateManager.getSource(sourceId);
        if (!latestSource || latestSource.status === 'active') {
            return;
        }

        const latestEntry = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (!latestEntry) {
            return;
        }
        if (!latestEntry._tiktokFallback) {
            latestEntry._tiktokFallback = fallbackState;
        }

        await attemptActivationModes({
            sourceId,
            entry: latestEntry,
            initialMode: nextMode,
            tabid: false,
            reuseFallbackState: true
        });
    }, fallbackState.retryDelayMs ?? TIKTOK_AUTO_FALLBACK_DELAY_MS);
}

function notifyTikTokFallbackSuccess(entry, preferredMode, fallbackMode) {
    const preferredLabel = describeTikTokMode(preferredMode);
    const fallbackLabel = describeTikTokMode(fallbackMode);
    const message = `Connected using ${fallbackLabel} after ${preferredLabel} failed.`;
    Toast.info('TikTok Fallback', message);
    if (entry) {
        updateConnectionStatus(entry, 'info', message);
        setTimeout(() => updateConnectionStatus(entry, 'connected'), 4000);
    }
}

async function performActivationAttempt({ sourceId, entry, tabid, mode, target }) {
    let source = stateManager.getSource(sourceId);
    if (!source) {
        return { success: false, error: new Error('Source not available') };
    }

    const resolvedTarget = target || source.target;
    const normalizedMode = resolvedTarget === 'tiktok' ? normalizeTikTokMode(mode) : mode;
    let pendingTikTokToken = null;

    try {
        const baseUpdate = {
            status: 'activating',
            error: null,
            activeConnectionMode: normalizedMode
        };
        stateManager.updateSource(sourceId, baseUpdate);
        source = stateManager.getSource(sourceId);

        let windowId;
        if (resolvedTarget === 'tiktok' && (normalizedMode === 'tiktok-websocket' || normalizedMode === 'tiktok-legacy')) {
            pendingTikTokToken = beginPendingTikTokActivation(sourceId);
            windowId = await createTikTokWSSFromSource(source, normalizedMode === 'tiktok-legacy' ? 'legacy' : 'websocket');
        } else if (normalizedMode === 'websocket') {
            if (resolvedTarget && resolvedTarget.startsWith('youtube')) {
                windowId = await createYoutubeWebSocketWindowFromSource(source, tabid);
            } else {
                windowId = await createWindowWSSFromSource(source, tabid);
            }
        } else {
            windowId = await createClassicWindowFromSource(source, tabid);
        }

        if (pendingTikTokToken && !isPendingTikTokActivationCurrent(sourceId, pendingTikTokToken)) {
            if (windowId && ipcRenderer && resolvedTarget === 'tiktok' && (normalizedMode === 'tiktok-websocket' || normalizedMode === 'tiktok-legacy')) {
                const actualWssId = windowId > 900000 ? windowId - 900000 : windowId;
                if (actualWssId) {
                    try {
                        await ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: actualWssId });
                    } catch (cancelError) {
                        console.warn('Error disconnecting canceled TikTok activation:', cancelError);
                    }
                }
            }
            markPendingTikTokActivationComplete(sourceId, pendingTikTokToken);
            stateManager.updateSource(sourceId, {
                status: 'inactive',
                vid: null,
                wssId: null,
                activeConnectionMode: null
            });
            return { success: false, error: new Error('Activation canceled') };
        }

        if (windowId) {
            let actualWssId = null;
            if (resolvedTarget === 'tiktok' && windowId > 900000) {
                actualWssId = windowId - 900000;
            } else if (normalizedMode && typeof normalizedMode === 'string' && normalizedMode.includes('websocket')) {
                actualWssId = windowId;
            } else if (normalizedMode === 'tiktok-legacy') {
                actualWssId = windowId;
            }

            const statusValue = (normalizedMode === 'websocket' || normalizedMode === 'tiktok-websocket' || normalizedMode === 'tiktok-legacy')
                ? 'activating'
                : 'active';

            stateManager.updateSource(sourceId, {
                vid: windowId,
                wssId: actualWssId,
                status: statusValue,
                activeConnectionMode: normalizedMode,
                error: null
            });

            if (pendingTikTokToken) {
                markPendingTikTokActivationComplete(sourceId, pendingTikTokToken);
            }

            if (entry && resolvedTarget === 'tiktok') {
                updateConnectionStatus(entry, statusValue === 'active' ? 'connected' : 'connecting');
            }

            return { success: true, windowId };
        }

        stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null, activeConnectionMode: null });
        if (pendingTikTokToken) {
            markPendingTikTokActivationComplete(sourceId, pendingTikTokToken);
        }
        const failureTarget = source.username || source.target || 'source';
        Toast.error("Activation Failed", `Could not activate ${failureTarget}. Main process might have failed.`);
        return { success: false, error: new Error('Activation failed without window ID') };
    } catch (error) {
        const fallbackInfo = resolveTikTokFallbackInfo(error);
        if (pendingTikTokToken) {
            markPendingTikTokActivationComplete(sourceId, pendingTikTokToken);
        }
        stateManager.updateSource(sourceId, {
            status: 'error',
            error: error.message,
            vid: null,
            wssId: null,
            activeConnectionMode: null
        });
        if (entry) {
            const statusMessage = error.message || 'Connection failed';
            updateConnectionStatus(entry, 'error', statusMessage);
        }
        return { success: false, error, fallbackInfo };
    }
}

function resolveTikTokFallbackInfo(error) {
    if (!error) return null;
    const visited = new Set();
    let current = error;
    while (current && typeof current === 'object' && !visited.has(current)) {
        visited.add(current);
        const code = typeof current.code === 'string' ? current.code : null;
        const explicitMode = typeof current.ssappFallbackMode === 'string' ? current.ssappFallbackMode : null;
        let derivedMode = explicitMode;
        if (!derivedMode && code === 'SSAPP_TIKTOK_FORCED_CLASSIC') {
            derivedMode = 'classic';
        } else if (!derivedMode && code === 'SSAPP_TIKTOK_FALLBACK') {
            derivedMode = 'polling';
        }
        if (!derivedMode) {
            const message = typeof current.message === 'string' ? current.message : '';
            if (message.includes('SSAPP_TIKTOK_FORCED_CLASSIC')) {
                derivedMode = 'classic';
            } else if (message.includes('SSAPP_TIKTOK_FALLBACK')) {
                derivedMode = 'polling';
            }
        }
        if (code === 'SSAPP_TIKTOK_FORCED_CLASSIC' || code === 'SSAPP_TIKTOK_FALLBACK' || current.ssappFallback === true || derivedMode) {
            const fallbackMessage = typeof current.ssappFallbackMessage === 'string' && current.ssappFallbackMessage.trim()
                ? current.ssappFallbackMessage.trim()
                : (typeof current.message === 'string'
                    ? current.message.replace(/SSAPP_TIKTOK_(?:FORCED_CLASSIC|FALLBACK):\s*/g, '').trim()
                    : null);
            return {
                code: code || null,
                mode: derivedMode || 'unknown',
                message: fallbackMessage || null
            };
        }
        current = current.cause || current.data || current.originalError || current.error || null;
    }
    return null;
}

function isTikTokFallbackError(error) {
    return !!resolveTikTokFallbackInfo(error);
}

async function handleTikTokFallbackToClassic({ sourceId, entryElement, tabid, originalError, pendingTikTokToken }) {
    console.warn('[TikTok] Falling back to standard mode for source', sourceId, originalError);
    const fallbackInfo = resolveTikTokFallbackInfo(originalError);
    const fallbackReason = (fallbackInfo && fallbackInfo.message)
        ? fallbackInfo.message
        : 'TikTok WebSocket unavailable. Switching to standard mode...';
    const entry = entryElement;
    if (entry) {
        updateConnectionStatus(entry, 'info', fallbackReason);
        setActivateButtonConnecting(entry);
    }

    stateManager.updateSource(sourceId, {
        status: 'activating',
        vid: null,
        wssId: null,
        error: null,
        activeConnectionMode: 'classic'
    });

    const updatedSource = stateManager.getSource(sourceId);

    try {
        const fallbackWindowId = await createClassicWindowFromSource(updatedSource, tabid);
        if (!fallbackWindowId) {
            throw new Error('Classic connection failed to open');
        }

        stateManager.updateSource(sourceId, {
            vid: fallbackWindowId,
            wssId: null,
            status: 'active',
            activeConnectionMode: 'classic',
            error: null
        });

        if (pendingTikTokToken) {
            markPendingTikTokActivationComplete(sourceId, pendingTikTokToken);
        }

        if (entry) {
            updateConnectionStatus(entry, 'connected');
            restoreActivateButton(entry);
        }

        const formattedReason = fallbackReason.endsWith('.') ? fallbackReason : `${fallbackReason}.`;
        Toast.info('TikTok Fallback', `${formattedReason} Now using standard connection mode.`);
        return fallbackWindowId;
    } catch (fallbackErr) {
        console.error('TikTok classic fallback failed:', fallbackErr);
        stateManager.updateSource(sourceId, {
            status: 'error',
            error: fallbackErr.message || 'Classic fallback failed',
            vid: null,
            wssId: null,
            activeConnectionMode: null
        });
        if (entry) {
            updateConnectionStatus(entry, 'error', fallbackErr.message || 'Classic fallback failed');
            restoreActivateButton(entry);
        }
        if (pendingTikTokToken) {
            markPendingTikTokActivationComplete(sourceId, pendingTikTokToken);
        }
        throw fallbackErr;
    }
}

// Helper function to fetch with retries
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`Fetch attempt ${attempt} for ${url} with timeout of ${options.timeout || 10000}`);
            const response = await ipcRenderer.invoke('nodefetch', {
                url,
                ...options,
                timeout: options.timeout || 10000
            });
            
            if (!response) {
                throw new Error("No response received");
            }
            
            if (response.error) {
                throw new Error(response.error);
            }
            
            if (response.status && response.status >= 500) {
                throw new Error(`Server error: ${response.status}`);
            }
            
            return response;
        } catch (error) {
            lastError = error;
            console.warn(`Fetch attempt ${attempt} failed:`, error.message);
            
            if (attempt < maxRetries) {
                // Exponential backoff: 1s, 2s, 4s
                const delay22 = Math.pow(2, attempt - 1) * 5000;
                console.log(`Retrying in ${delay22}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay22));
            }
        }
    }
    
    throw lastError;
}

async function createClassicWindowFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let urlToLoad = source.url;

    if (source.target?.startsWith("youtube") && source.videoId && (!urlToLoad || !urlToLoad.includes(source.videoId))) {
        const isShort = source.target === "youtubeshorts";
        if (source.videoId) { 
             urlToLoad = `https://www.youtube.com/live_chat?is_popout=1&v=${source.videoId}${isShort ? '&shorts' : ''}`;
             if (source.url !== urlToLoad) {
                stateManager.updateSource(source.id, { url: urlToLoad });
             }
        } else if (source.username) { 
            console.log("Attempting to fetch video ID for YouTube classic activation:", source.username);
            const videoDescArray = await fetchYoutube(source.username, false) || await fetchYoutube(source.username, true);
            if (videoDescArray && videoDescArray.length > 0) {
                // Only use a LIVE stream when resolving by username in classic mode
                const liveOnly = videoDescArray.filter(v => v && v.status === 'live');
                if (liveOnly.length === 0) {
                    Toast.error("YouTube Error", `No live video found for ${source.username} to activate in classic mode.`);
                    return false;
                }
                const videoDesc = liveOnly[0];
                stateManager.updateSource(source.id, { videoId: videoDesc.videoId }); 
                urlToLoad = `https://www.youtube.com/live_chat?is_popout=1&v=${videoDesc.videoId}${isShort ? '&shorts' : ''}`;
                stateManager.updateSource(source.id, { url: urlToLoad });
            } else {
                Toast.error("YouTube Error", `No live video found for ${source.username} to activate in classic mode.`);
                return false;
            }
        }
    } else if (source.target === "rumble" && source.username && !source.chatId && !source.isDirectUrl) {
        // Skip fetching if we already have a chat popup URL
        if (source.url && source.url.includes('/chat/popup/')) {
            console.log("Already have chat popup URL, skipping fetch");
            urlToLoad = source.url;
        } else if (/^\d+$/.test(source.username)) {
            // Check if the username is actually a numeric chat ID
            console.log(`Username appears to be a numeric chat ID: ${source.username}`);
            const chatId = source.username;
            urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
            stateManager.updateSource(source.id, { url: urlToLoad, chatId: chatId });
        } else {
            // For username-based Rumble sources, always fetch fresh video ID
            console.log("Attempting to fetch video ID for Rumble:", source.username);
            let videoId = null;
        
        // Try the primary option first (channel if isChannel is true, user otherwise)
        const tryChannelFirst = source.isChannel !== false; // Default to channel if not specified
        let videoInfo = await fetchRumble(source.username, !tryChannelFirst);
        
        // If not found, try the alternate option
        if (!videoInfo) {
            console.log("Rumble video not found with primary option, trying alternate...");
            videoInfo = await fetchRumble(source.username, tryChannelFirst);
        }
        
        if (videoInfo) {
            // Handle both old format (string) and new format (object)
            videoId = typeof videoInfo === 'string' ? videoInfo : videoInfo.videoId;
            const fullPath = typeof videoInfo === 'string' ? `${videoInfo}.html` : videoInfo.fullPath;
            
            // Fetch the chat ID from the video page
            console.log(`Fetching Rumble chat ID for video: ${videoId} (path: ${fullPath})`);
            const videoUrl = `https://rumble.com/${fullPath}`;
            
            try {
                const response = await fetchWithRetry(videoUrl, {
                    headers: {
                        'User-Agent': config?.global?.userAgent || 'Mozilla/5.0',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                        'Accept-Language': APP_ACCEPT_LANGUAGE,
                        'Referer': 'https://rumble.com/',
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    },
                    timeout: 15000
                }, 2); // Only 2 retries for Rumble to prevent long freezes
                
                if (response.status && response.status !== 200) {
                    console.error(`Rumble fetch returned status ${response.status}`);
                    if (response.status === 404) {
                        Toast.error("Rumble Error", `Video not found: ${videoUrl}`);
                    } else {
                        Toast.error("Rumble Error", `Rumble returned error ${response.status}`);
                    }
                    return false;
                }
                
                const htmlData = response?.data || response;
                if (htmlData && typeof htmlData === 'string') {
                    
                    // Try multiple patterns to find the numeric video/chat ID
                    let chatId = null;
                    
                    // Pattern 1: data-video-id attribute
                    const dataVideoIdMatch = htmlData.match(/data-video-id=["'](\d+)["']/);
                    if (dataVideoIdMatch && dataVideoIdMatch[1]) {
                        chatId = dataVideoIdMatch[1];
                    }
                    
                    // Pattern 2: content_id in hx-vals
                    if (!chatId) {
                        const contentIdMatch = htmlData.match(/&#34;content_id&#34;:(\d+)/);
                        if (contentIdMatch && contentIdMatch[1]) {
                            chatId = contentIdMatch[1];
                        }
                    }
                    
                    // Pattern 3: video_id in JavaScript
                    if (!chatId) {
                        const videoIdMatch = htmlData.match(/video_id:\s*(\d+)/);
                        if (videoIdMatch && videoIdMatch[1]) {
                            chatId = videoIdMatch[1];
                        }
                    }
                    
                    // Pattern 4: cvid in window.rads
                    if (!chatId) {
                        const cvidMatch = htmlData.match(/cvid:(\d+)/);
                        if (cvidMatch && cvidMatch[1]) {
                            chatId = cvidMatch[1];
                        }
                    }
                    
                    if (chatId) {
                        console.log(`Found Rumble chat ID: ${chatId} for video: ${videoId}`);
                        stateManager.updateSource(source.id, { videoId: videoId, chatId: chatId });
                        urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
                        stateManager.updateSource(source.id, { url: urlToLoad });
                    } else {
                        // Debug: look for any numeric IDs
                        const numericIds = htmlData.match(/\b\d{9,10}\b/g);
                        if (numericIds) {
                        }
                        console.warn(`Could not find chat ID for Rumble video: ${videoId}`);
                        Toast.error("Rumble Error", `Could not find chat ID for video ${videoId}`);
                        return false;
                    }
                } else {
                    console.error("Invalid response when fetching Rumble video page");
                    return false;
                }
            } catch (e) {
                console.error("Error fetching Rumble chat ID:", e);
                if (e.message.includes("timeout")) {
                    Toast.error("Rumble Error", "Connection timed out. Rumble might be slow or unreachable.");
                } else {
                    Toast.error("Rumble Error", `Failed to get chat ID: ${e.message}`);
                }
                return false;
            }
            } else {
                Toast.error("Rumble Error", `No live video found for ${source.username}.`);
                return false;
            }
        }
    } else if (source.target === "rumble" && source.chatId) {
        // Direct chat ID provided
        console.log("Using provided chat ID:", source.chatId);
        urlToLoad = `https://rumble.com/chat/popup/${source.chatId}`;
    } else if (source.target === "rumble" && source.isDirectUrl) {
        // Direct Rumble URL that should be used as-is
        console.log("Using direct Rumble URL:", source.url);
        urlToLoad = source.url;
    } else if (source.target === "rumble" && source.videoId && !source.username) {
        // For direct video ID entries, we need to fetch the chat ID
        {
            // Check if the videoId is actually a numeric chat ID
            if (/^\d+$/.test(source.videoId) && source.videoId.length >= 8) {
                // This looks like a chat ID, not a video ID
                console.log(`Video ID appears to be a chat ID: ${source.videoId}`);
                urlToLoad = `https://rumble.com/chat/popup/${source.videoId}`;
                stateManager.updateSource(source.id, { chatId: source.videoId, url: urlToLoad });
            } else {
                // We need to fetch the chat ID
                console.log(`Direct video ID entry needs chat ID, fetching...`);
                try {
                    let videoUrl;
                    
                    // Check if this is a full path or just a video ID
                    if (source.videoId.includes('-') || source.videoId.includes('.html')) {
                        // This looks like a full path
                        videoUrl = `https://rumble.com/${source.videoId}`;
                    } else if (/^[vp]\w+$/.test(source.videoId)) {
                        // This is just a video ID, we need to construct a URL
                        // Unfortunately, we can't know the full path without additional info
                        // Let's try the simple format first
                        videoUrl = `https://rumble.com/${source.videoId}.html`;
                    } else {
                        // Unknown format, try as-is
                        videoUrl = `https://rumble.com/${source.videoId}`;
                    }
                    
                    console.log(`Fetching Rumble page: ${videoUrl}`);
                    const response = await fetchWithRetry(videoUrl, {
                        headers: {'User-Agent': config?.global?.userAgent || 'Mozilla/5.0'},
                        timeout: 10000
                    }, 2); // Only 2 retries for Rumble to prevent long freezes
                
                if (response.status && response.status !== 200) {
                    console.error(`Rumble fetch returned status ${response.status}`);
                    if (response.status === 404) {
                        Toast.error("Rumble Error", `Video not found: ${videoUrl}`);
                    } else {
                        Toast.error("Rumble Error", `Rumble returned error ${response.status}`);
                    }
                    return false;
                }
                
                const htmlData = response?.data || response;
                if (htmlData && typeof htmlData === 'string') {
                    
                    // Try multiple patterns to find the numeric video/chat ID
                    let chatId = null;
                    
                    // Pattern 1: data-video-id attribute
                    const dataVideoIdMatch = htmlData.match(/data-video-id=["'](\d+)["']/);
                    if (dataVideoIdMatch && dataVideoIdMatch[1]) {
                        chatId = dataVideoIdMatch[1];
                    }
                    
                    // Pattern 2: content_id in hx-vals
                    if (!chatId) {
                        const contentIdMatch = htmlData.match(/&#34;content_id&#34;:(\d+)/);
                        if (contentIdMatch && contentIdMatch[1]) {
                            chatId = contentIdMatch[1];
                        }
                    }
                    
                    // Pattern 3: video_id in JavaScript
                    if (!chatId) {
                        const videoIdMatch = htmlData.match(/video_id:\s*(\d+)/);
                        if (videoIdMatch && videoIdMatch[1]) {
                            chatId = videoIdMatch[1];
                        }
                    }
                    
                    // Pattern 4: cvid in window.rads
                    if (!chatId) {
                        const cvidMatch = htmlData.match(/cvid:(\d+)/);
                        if (cvidMatch && cvidMatch[1]) {
                            chatId = cvidMatch[1];
                        }
                    }
                    
                    if (chatId) {
                        console.log(`Found Rumble chat ID: ${chatId} for video: ${source.videoId}`);
                        stateManager.updateSource(source.id, { chatId: chatId });
                        urlToLoad = `https://rumble.com/chat/popup/${chatId}`;
                        stateManager.updateSource(source.id, { url: urlToLoad });
                    } else {
                        Toast.error("Rumble Error", `Could not find chat ID for video ${source.videoId}`);
                        return false;
                    }
                }
            } catch (e) {
                console.error("Error fetching Rumble chat ID:", e);
                if (e.message.includes("timeout")) {
                    Toast.error("Rumble Error", "Connection timed out. Rumble might be slow or unreachable.");
                } else {
                    Toast.error("Rumble Error", `Failed to get chat ID: ${e.message}`);
                }
                return false;
            }
            }
        }
    }
    
    if (!urlToLoad) {
        Toast.error("Activation Error", `No URL specified for ${source.username || source.target} (classic mode).`);
        return false;
    }
    
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        if (source.mockUserAgentData) conf.mockUserAgentData = source.mockUserAgentData;
        console.log('[CreateClassicWindow] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateClassicWindow] Using AUTO user agent from config:', conf.userAgent);
    }

    const targetSourceFile = source.target === "youtubeshorts" ? "youtube" : source.target;
    const scriptPath = source.sourceFile || `sources/${targetSourceFile}.js`; // Use sourceFile from state if available

    try {
        // For now, fall back to sync while we debug the async issue
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlToLoad),
            config: conf,
            visible: source.isVisible,
            muted: source.isMuted,
            source: scriptPath, 
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            replyOnly: !!source.replyOnly,
            isBetaMode: isBetaMode,
            domain: new URL(urlToLoad).hostname
        });
        console.log('[CreateClassicWindow] Created window/tab ID:', response, 'for', source.username || source.videoId);
        return response;
        
        // TODO: Fix async implementation
        /*
        const response = await window.ipc.send('createWindow', {
            url: rewriteKickUrl(urlToLoad),
            config: conf,
            visible: source.isVisible,
            muted: source.isMuted,
            source: scriptPath, 
            tab: tabid,
            isBetaMode: isBetaMode,
            domain: new URL(urlToLoad).hostname
        });
        return response; 
        */
    } catch(e) {
        console.error("Error in createClassicWindowFromSource:", e);
        Toast.error("Window Error", `Failed to create classic window: ${e.message}`);
        return false;
    }
}

async function createWindowWSSFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] };
    if (conf.wss) conf = { ...conf, ...conf.wss };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        if (source.mockUserAgentData) conf.mockUserAgentData = source.mockUserAgentData;
        console.log('[CreateWindowWSS] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateWindowWSS] Using AUTO user agent from config:', conf.userAgent);
    }

    let urlWSS;
    if (devmode || sourcemode) {
        const baseUrl = sourcemode || 'http://localhost:8080/';
        urlWSS = `${baseUrl}sources/websocket/${source.target}.html?channel=${source.username}`;
        if (devmode) urlWSS += '&devmode=';
    } else {
        const domain = isBetaMode ? 'https://socialstream.ninja/beta/' : 'https://socialstream.ninja/';
        urlWSS = `${domain}sources/websocket/${source.target}.html?channel=${source.username}`;
    }
    
    const scriptPath = source.sourceFile || `sources/websocket/${source.target}.js`;


    try {
        // For now, fall back to sync while we debug the async issue
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlWSS.trim()),
            muted: source.isMuted,
            visible: source.isVisible,
            source: scriptPath, 
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            wss: true,
            replyOnly: !!source.replyOnly,
            config: conf,
            isBetaMode: isBetaMode
        });
        console.log('[CreateWindowWSS] Created window/tab ID:', response, 'for', source.username || source.videoId);
        return response; 
    } catch (e) {
        console.error("Error in createWindowWSSFromSource:", e);
        Toast.error("WebSocket Error", `Failed to create WebSocket window: ${e.message}`);
        return false;
    }
}

async function createYoutubeWebSocketWindowFromSource(source, tabid = false) {
    if (!ipcRenderer) return false;
    let conf = config.global ? { ...config.global } : {};
    if (config[source.target]) conf = { ...conf, ...config[source.target] }; 
    if (conf.wss) conf = { ...conf, ...conf.wss };

    // Apply custom user agent if set
    if (source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        if (source.mockUserAgentData) conf.mockUserAgentData = source.mockUserAgentData;
        console.log('[CreateYouTubeWSS] Using custom user agent:', source.userAgent);
    } else {
        console.log('[CreateYouTubeWSS] Using AUTO user agent from config:', conf.userAgent);
    }

    const queryParams = new URLSearchParams();
    if (source.videoId) queryParams.set('videoId', source.videoId);
    else if (source.username) queryParams.set('channel', source.username);
    else {
        Toast.error("YouTube WSS Error", "Missing Video ID or Username for YouTube WebSocket.");
        return false;
    }

    let baseUrl;
    if (devmode || sourcemode) {
        baseUrl = sourcemode ? `${sourcemode}sources/websocket/youtube.html` : `http://localhost:8080/sources/websocket/youtube.html`;
        if (devmode && !queryParams.has('devmode')) queryParams.set('devmode','');
    } else {
        const domain = isBetaMode ? 'https://socialstream.ninja/beta/' : 'https://socialstream.ninja/';
        baseUrl = `${domain}sources/websocket/youtube.html`;
    }
    const urlWSS = `${baseUrl}?${queryParams.toString()}`;
    
    // For YouTube WSS, the script path is specific
    const scriptPath = devmode || sourcemode ? 
                       (sourcemode ? `${sourcemode}sources/websocket/youtube.js` : `http://localhost:8080/sources/websocket/youtube.js`) : 
                       (isBetaMode ? 'https://socialstream.ninja/beta/sources/websocket/youtube.js' : 'https://socialstream.ninja/sources/websocket/youtube.js');

    try {
        const response = ipcRenderer.sendSync('createWindow', {
            url: rewriteKickUrl(urlWSS.trim()),
            muted: source.isMuted,
            visible: source.isVisible,
            source: scriptPath,
            tab: tabid,
            sourceId: source.id,
            customSession: source.customSession || 'AUTO',
            wss: true,
            replyOnly: !!source.replyOnly,
            config: conf,
            isBetaMode: isBetaMode
        });
        console.log('[CreateYouTubeWSS] Created window/tab ID:', response, 'for', source.username || source.videoId);
         return response; 
    } catch (e) {
        console.error("Error in createYoutubeWebSocketWindowFromSource IPC call:", e, "URL:", urlWSS, "Script:", scriptPath);
        Toast.error("YouTube WSS Error", `Failed to create YouTube WebSocket: ${e.message}`);
        return false;
    }
}

async function createTikTokWSSFromSource(source, strategy = 'websocket') { 
    if (!ipcRenderer) return false;
    const cleanUsername = source.username?.replace('@', '').trim();
    if (!cleanUsername) {
        Toast.warning('TikTok Connector Error', 'No username found for TikTok connection');
        return false;
    }

    if ((preferTikTokClassic || cliForcesTikTokClassic) && strategy !== 'classic') {
        const fallbackError = new Error('SSAPP_TIKTOK_FORCED_CLASSIC: TikTok API connectors disabled by classic mode preference');
        fallbackError.code = 'SSAPP_TIKTOK_FORCED_CLASSIC';
        fallbackError.ssappFallback = true;
        fallbackError.ssappFallbackMode = 'classic';
        fallbackError.ssappFallbackMessage = 'TikTok API connectors disabled by classic mode preference';
        throw fallbackError;
    }

    const entryElement = document.querySelector(`[data-source-id="${source.id}"]`);
    updateConnectionStatus(entryElement, 'connecting');
    setActivateButtonConnecting(entryElement);
    await waitForNextRender();

    try {
        const sessionId = source.tiktokSessionId || null;
        const ttTargetIdc = source.tiktokTtTargetIdc || null;

        const wssID = await ipcRenderer.invoke('createTikTokConnection', {
            username: cleanUsername,
            sessionId: sessionId,
            ttTargetIdc: ttTargetIdc,
            replyOnly: !!source.replyOnly,
            strategy: strategy
        });

        if (wssID === null || typeof wssID === 'undefined') {
            throw new Error('Failed to create TikTok connection (main process returned no tab ID)');
        }
        return wssID;
    } catch (error) {
        const fallbackInfo = resolveTikTokFallbackInfo(error);
        const isLegacyAttempt = strategy === 'legacy';
        if (!fallbackInfo || fallbackInfo.mode !== 'classic') {
            console.error('Error in TikTok connector from source:', error);
            const label = isLegacyAttempt ? 'Legacy' : 'WebSocket';
            Toast.warning('TikTok Connector Error', `(${label}) Connection Failed: ${error.message || 'Please try again.'}`);
        }
        throw error; 
    }
}

// Simple modal functions for TikTok auth
function showModal(content) {
    // Remove any existing modal
    closeModal();
    
    const modal = document.createElement('div');
    modal.id = 'tiktok-auth-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    modal.innerHTML = content;
    
    // Close on background click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeModal();
        }
    });
    
    document.body.appendChild(modal);
}

function closeModal() {
    const modal = document.getElementById('tiktok-auth-modal');
    if (modal) {
        modal.remove();
    }
}

function showTikTokSignInMenu(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (!source) return;
    
    const isAuthenticated = source.tiktokSessionId ? true : false;
    
    let menuContent = `
        <div style="padding: 20px; background: #2a2a2a; border-radius: 8px;">
            <h3 style="margin-bottom: 15px;">TikTok Authentication</h3>
            <p style="margin: 0 0 14px 0; color: #facc15;">
                Experimental option — these sign-in and session workflows may not work reliably yet. Please share feedback or bug reports at
                <a href="https://discord.socialstream.ninja" target="_blank" style="color: #fde68a;">discord.socialstream.ninja</a>.
            </p>
            ${isAuthenticated ? 
                `<p style="color: #4ade80; margin-bottom: 15px;">✓ TikTok session cookie saved for this source.</p>` : 
                `<p style="margin-bottom: 15px;">Add your TikTok session cookie to unlock:</p>
                <ul style="margin-bottom: 15px; margin-left: 20px;">
                    <li>Sending chat messages from the app</li>
                    <li>Improved connection stability</li>
                    <li>Access to additional TikTok metadata</li>
                </ul>`
            }
            <p style="margin: 0 0 16px 0; line-height: 1.4;">
                <strong>Tip:</strong> Clicking <em>Sign in with Browser</em> opens TikTok inside the app and automatically saves your <code>sessionid</code> once you finish signing in. Use the manual option only if you prefer to copy the cookie yourself.
            </p>
            <div style="background: rgba(148, 163, 184, 0.12); border-radius: 6px; padding: 12px 14px; margin-bottom: 18px;">
                <h4 style="margin: 0 0 10px 0; font-size: 15px;">Manual session cookie steps</h4>
                <ol style="margin: 0 0 10px 18px; padding: 0; line-height: 1.4;">
                    <li>Open <strong>tiktok.com</strong> in your browser and sign in.</li>
                    <li>Press <strong>F12</strong> (or right-click → Inspect) to open Developer Tools.</li>
                    <li>Navigate to <strong>Application → Storage → Cookies → https://www.tiktok.com</strong>.</li>
                    <li>Copy the value of the <code>sessionid</code> cookie. Optionally note <code>tt-target-idc</code> if it exists.</li>
                </ol>
                <p style="margin: 0; font-size: 13px; color: #e2e8f0;">
                    Only the <code>sessionid</code> cookie is required to send chat replies. The <code>tt-target-idc</code> cookie is optional but can improve routing.
                </p>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="tiktokSignIn('${sourceId}')" class="button" style="background: #6366f1;">
                    🌐 Sign in with Browser
                </button>
                <button onclick="tiktokManualSignIn('${sourceId}')" class="button" style="background: #6b7280;">
                    📝 Enter Session ID
                </button>
                ${isAuthenticated ? `
                    <button onclick="clearTikTokAuth('${sourceId}')" class="button" style="background: #ef4444;">
                        🗑️ Clear Authentication
                    </button>` : ''}
                <button onclick="closeModal()" class="button" style="background: #374151;">
                    Close
                </button>
            </div>
        </div>
    `;
    
    showModal(menuContent);
}

function clearTikTokAuth(sourceId) {
    const source = stateManager.getSource(sourceId);
    if (source) {
        stateManager.updateSource(sourceId, {
            tiktokSessionId: null,
            tiktokTtTargetIdc: null
        });
        
        // Update UI
        const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (entry) {
            const signInBtn = entry.querySelector('[data-tiktok-signin]') || entry.querySelector('[data-signin]');
            if (signInBtn) {
                if (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy') {
                    signInBtn.innerHTML = '🔐 Add TikTok Session ID';
                    signInBtn.title = 'Provide your TikTok session cookie to enable chat replies and authenticated features.';
                } else {
                    const defaultLabel = typeof translate === 'function' ? translate('btn.signin') : '🔑 Sign-in';
                    signInBtn.innerHTML = defaultLabel;
                    signInBtn.title = '';
                }
                signInBtn.classList.remove('authenticated');
            }
        }
        
        Toast.success("TikTok Sign-in", "Authentication cleared");
        closeModal();
    }
}

async function tiktokSignIn(sourceId) {
    closeModal();
    try {
        const result = await ipcRenderer.invoke('authenticateTikTok');
        if (result.success && result.credentials) {
            const rawSession = typeof result.credentials.sessionId === 'string' ? result.credentials.sessionId.trim() : '';
            const rawIdc = typeof result.credentials.ttTargetIdc === 'string' ? result.credentials.ttTargetIdc.trim() : '';
            if (!rawSession) {
                Toast.error("TikTok Sign-in", "TikTok did not return a sessionid cookie. Please try again manually.");
                return;
            }
            // Store credentials in the source
            const source = stateManager.getSource(sourceId);
            if (source) {
                stateManager.updateSource(sourceId, {
                    tiktokSessionId: rawSession,
                    tiktokTtTargetIdc: rawIdc || null
                });
                Toast.success("TikTok Sign-in", "Successfully signed in to TikTok!");
                
                // Update UI to show authenticated status
                const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
                if (entry) {
                    const signInBtn = entry.querySelector('[data-tiktok-signin]') || entry.querySelector('[data-signin]');
                    if (signInBtn) {
                        if (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy') {
                            signInBtn.innerHTML = '✓ TikTok Session Saved';
                            signInBtn.classList.add('authenticated');
                            signInBtn.title = 'TikTok session cookie stored for this source.';
                        } else {
                            const defaultLabel = typeof translate === 'function' ? translate('btn.signin') : '🔑 Sign-in';
                            signInBtn.innerHTML = defaultLabel;
                            signInBtn.classList.remove('authenticated');
                            signInBtn.title = '';
                        }
                    }
                }
            }
        } else {
            Toast.error("TikTok Sign-in", result.error || "Sign-in failed");
        }
    } catch (error) {
        console.error('TikTok sign-in error:', error);
        Toast.error("TikTok Sign-in", error.message || "Sign-in failed");
    }
}

async function tiktokManualSignIn(sourceId) {
    closeModal();
    try {
        const result = await ipcRenderer.invoke('promptTikTokCookies');
        if (result.success && result.credentials) {
            const rawSession = typeof result.credentials.sessionId === 'string' ? result.credentials.sessionId.trim() : '';
            const rawIdc = typeof result.credentials.ttTargetIdc === 'string' ? result.credentials.ttTargetIdc.trim() : '';
            if (!rawSession) {
                Toast.error("TikTok Sign-in", "Session ID is required.");
                return;
            }
            // Store credentials in the source
            const source = stateManager.getSource(sourceId);
            if (source) {
                stateManager.updateSource(sourceId, {
                    tiktokSessionId: rawSession,
                    tiktokTtTargetIdc: rawIdc || null
                });
                Toast.success("TikTok Sign-in", "Successfully added TikTok credentials!");
                
                // Update UI to show authenticated status
                const entry = document.querySelector(`[data-source-id="${sourceId}"]`);
                if (entry) {
                    const signInBtn = entry.querySelector('[data-tiktok-signin]') || entry.querySelector('[data-signin]');
                    if (signInBtn) {
                        if (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy') {
                            signInBtn.innerHTML = '✓ TikTok Session Saved';
                            signInBtn.classList.add('authenticated');
                            signInBtn.title = 'TikTok session cookie stored for this source.';
                        } else {
                            const defaultLabel = typeof translate === 'function' ? translate('btn.signin') : '🔑 Sign-in';
                            signInBtn.innerHTML = defaultLabel;
                            signInBtn.classList.remove('authenticated');
                            signInBtn.title = '';
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.error('TikTok manual sign-in error:', error);
        Toast.error("TikTok Sign-in", error.message || "Failed to add credentials");
    }
}

function cleanupTikTokConnection(entry, errorMessage = null) {
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    if (!sourceId) return;

    if (errorMessage) {
        updateConnectionStatus(entry, 'error', errorMessage);
    } else {
        updateConnectionStatus(entry, 'stopped', 'Connection stopped.');
        setTimeout(()=> updateConnectionStatus(entry, 'clear'), 3000);
    }
}

function updateUIForActiveTikTokConnection(element) {
    if (element) updateConnectionStatus(element, 'connected');
}

function updateConnectionStatus(element, status, message = null) {
	if (!element) return;
	let statusElement = element.querySelector('.ws-status');
	if (!statusElement) { 
		statusElement = document.createElement('div');
		statusElement.className = 'ws-status';
		const controlPanel = element.querySelector('.control-panel');
        if (controlPanel) {
            element.insertBefore(statusElement, controlPanel.nextSibling); 
        } else { 
            element.appendChild(statusElement);
        }
	}
	statusElement.classList.remove('hidden', 'error', 'connecting', 'connected', 'retry', 'stopped', 'info');
    statusElement.style.display = 'inline-flex'; 

	// Try to access source for context (mode-specific tips)
	let sourceCtx = null;
	try {
		const sid = element.dataset.sourceId;
		if (sid && window.stateManager) sourceCtx = window.stateManager.getSource(sid);
	} catch (_) {}

	switch (status) {
		case 'connecting':
			statusElement.classList.add('connecting');
			{
				let tipHtml = '';
					try {
						const isWss = sourceCtx && (sourceCtx.connectionMode === 'websocket' || sourceCtx.connectionMode === 'tiktok-websocket' || sourceCtx.connectionMode === 'tiktok-legacy');
						const isTikTok = sourceCtx && sourceCtx.target === 'tiktok';
						if (isWss && !isTikTok) {
							tipHtml = ' <span class="ws-tip">If a window opens, sign in and ensure the chat is visible.</span>';
						}
					} catch (_) {}
				statusElement.innerHTML = '<i class="las la-sync fa-spin"></i> Connecting...' + tipHtml;
			}
			break;
		case 'connected':
			statusElement.classList.add('connected');
			statusElement.innerHTML = '<i class="las la-check-circle"></i> WebSocket Connected';
			break;
		case 'error':
			statusElement.classList.add('error');
			statusElement.innerHTML = `<i class="las la-exclamation-circle"></i> ${message || 'Connection error'}`;
			break;
		case 'retry': 
			statusElement.classList.add('retry'); 
			statusElement.innerHTML = `<i class="las la-sync fa-spin"></i> ${message || 'Retrying connection...'}`;
			break;
		case 'stopped':
			statusElement.classList.add('stopped');
            statusElement.innerHTML = `<i class="las la-hand-paper"></i> ${message || 'Connection stopped'}`;
			setTimeout(() => {
				if (statusElement.classList.contains('stopped')) statusElement.style.display = 'none';
			}, 5000);
			break;
		case 'info':
			statusElement.classList.add('info');
			statusElement.innerHTML = `<i class="las la-info-circle"></i> ${message || ''}`;
			setTimeout(() => {
				if (statusElement.classList.contains('info')) statusElement.style.display = 'none';
			}, 30000); // keep visible ~30s (3-5x longer)
			break;
		case 'clear':
		default:
			statusElement.style.display = 'none'; 
            statusElement.innerHTML = '';
			break;
	}
}


async function signin(ele, tabid = false) {
    // Debug logs removed - they show the parent window's UA, not the sign-in window's
    
    if (!ipcRenderer) { console.error('IPC not available for signin'); return; }

    const entry = ele.closest('.entry');
    if (!entry) { console.error('Could not find parent entry element for signin'); return; }

    const sourceId = entry.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;
    const groupId = entry.dataset.groupId;
    const group = !source && groupId ? stateManager.getGroup(groupId) : null;
    console.log(`[SIGNIN DEBUG] Source ID: ${sourceId}, Source:`, source);
    if (!source && !group && !entry.dataset.target) { 
         console.error('Cannot signin: no source data or target on element.'); return;
    }
    const rawTargetPlatform = source ? source.target : (group ? group.target : entry.dataset.target);
    const effectivePlatform = rawTargetPlatform === 'youtubeshorts' ? 'youtube' : rawTargetPlatform;
    let urlForSignin = source ? source.url : (group ? null : entry.dataset.url); 

    let signinUrl = config?.[effectivePlatform]?.signin?.url;
    if (!signinUrl && urlForSignin) {
        try {
            signinUrl = "https://" + getPrimaryDomain(urlForSignin);
        } catch { /* Use platform default */ }
    }
    if (!signinUrl) { 
        if (effectivePlatform === 'youtube') signinUrl = 'https://youtube.com';
        else if (effectivePlatform === 'twitch') signinUrl = 'https://www.twitch.tv';
        else { Toast.error("Sign-in Error", `No sign-in URL configured for ${rawTargetPlatform || 'this platform'}.`); return; }
    }

    let conf = config.global ? { ...config.global } : {};
    if (config.global?.signin) conf = { ...conf, ...config.global.signin };
    if (config[effectivePlatform]) conf = { ...conf, ...config[effectivePlatform] };
    if (config[effectivePlatform]?.signin) conf = { ...conf, ...config[effectivePlatform].signin };
    
    // Apply custom user agent if set
    if (source && source.userAgent && source.userAgent !== 'AUTO') {
        conf.userAgent = source.userAgent;
        if (source.mockUserAgentData) conf.mockUserAgentData = source.mockUserAgentData;
        console.log('[SignIn] Using custom user agent:', conf.userAgent);
    } else {
        console.log('[SignIn] Using AUTO user agent from config:', conf.userAgent);
    }
    
    const customSession = source ? (source.customSession || 'AUTO') : (group ? (group.customSession || 'AUTO') : 'AUTO');
    console.log(`[SIGN-IN DEBUG] Platform: ${rawTargetPlatform}, Sign-in Platform: ${effectivePlatform}, URL: ${signinUrl}, CustomSession: ${customSession}`);
    try {
        const response = ipcRenderer.sendSync('signIn', {
            url: signinUrl.trim(),
            muted: true, visible: true, source: false, tab: tabid,
            customSession,
            config: conf, configs: config
        });
        console.log("Sign-in window created with ID:", response);
        if (response && ipcRenderer) { 
            ipcRenderer.once(`window-closed-${response}`, () => {
                Toast.info("Sign-in window closed.", "Checking if source needs refresh...");
                
                // Just call refreshWindow directly with the element
                refreshWindow(ele);
            });
        }
        return response; 
    } catch (err) {
        console.error('Signin failed:', err);
        Toast.error("Sign-in Error", `Could not open sign-in window: ${err.message}`);
        return false;
    }
}

function refreshActivatedWindow(ele) { 
    const entry = ele.closest('.entry');
    if (!entry) return;
    const sourceId = entry.dataset.sourceId;
    const source = sourceId ? stateManager.getSource(sourceId) : null;

    if (source && source.vid) { 
        refreshWindow(ele); 
    } else {
        Toast.info("Refresh Info", "Sign-in complete. Activate the source if it's not already running.");
    }
}

function ensureAutoActivatedSourcesCapturing() {
    if (autoActivateCaptureEnsured || !ipcRenderer || !stateManager) {
        return;
    }

    try {
        const hasAutoActivatedSource = stateManager.getSources().some(src => src.autoActivate);
        const hasAutoActivatedGroup = stateManager.getGroups().some(group => group.autoActivate);

        if (!hasAutoActivatedSource && !hasAutoActivatedGroup) {
            return;
        }

        const stateResponse = ipcRenderer.sendSync('fromPopup', { cmd: 'getOnOffState' }) || {};
        const currentlyEnabled = stateResponse.state === true;

        if (!currentlyEnabled) {
            ipcRenderer.sendSync('fromPopup', { cmd: 'setOnOffState', data: { value: true } });
        }

        autoActivateCaptureEnsured = true;
    } catch (error) {
        console.warn('Failed to ensure capture state for auto-activated sources:', error);
    }
}

function processSettingsAndCreateSources() {
    console.log('[Startup] Processing settings and creating sources');
    ensureAutoActivatedSourcesCapturing();
    cleanupYouTubeGroups(); 
    
    // Fix orphaned YouTube sources that should belong to groups
    const allSources = stateManager.getSources();
    allSources.forEach(source => {
        if (source.groupId && source.videoId && source.target && source.target.startsWith('youtube')) {
            const group = stateManager.getGroup(source.groupId);
            if (group && !group.streams.includes(source.id)) {
                console.log("Fixing orphaned YouTube source:", source.id, "adding to group:", source.groupId);
                group.streams.push(source.id);
                stateManager.persist();
            }
        }
    });

    const sourcesContainer = document.getElementById("sources");
    sourcesContainer.querySelectorAll(".entry:not(#sourceTemplate):not(#groupTemplate)").forEach(el => el.remove());

    const groups = stateManager.getGroups();
    groups.forEach(group => {
        if (!document.querySelector(`[data-group-id="${group.id}"]`)) {
            const groupElement = createGroupElement(group.id);
            if (groupElement) {
                sourcesContainer.appendChild(groupElement);
                if (group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                    // Avoid duplicate scraping: only call this immediate auto-activate if the group has no streams yet
                    // AND there is no active stream in the group.
                    const hasActive = (group.streams || []).some(sid => {
                        const s = stateManager.getSource(sid);
                        return s && s.status === 'active' && (s.vid || s.wssId);
                    });
                    const shouldAttemptImmediate = (!group.streams || group.streams.length === 0) && !hasActive;
                    if (shouldAttemptImmediate) {
                        setTimeout(async () => {
                            // Re-check state at call time to avoid races
                            const freshGroup = stateManager.getGroup(group.id);
                            const freshHasActive = (freshGroup?.streams || []).some(sid => {
                                const s = stateManager.getSource(sid);
                                return s && s.status === 'active' && (s.vid || s.wssId);
                            });
                            if (freshHasActive) {
                                console.log('Skipping processSettings auto-activate; group already has active stream:', freshGroup.username);
                                return;
                            }
                            console.log('Auto-activating YouTube group from processSettings:', group.username);
                            await handleYouTubeActivation(
                                group.username,
                                group.target === "youtubeshorts",
                                false,
                                true,
                                group.isChannel
                            );
                        }, 2500 + Math.random() * 1000);
                    }
                }
            }
        } else { 
            const groupElement = document.querySelector(`[data-group-id="${group.id}"]`);
            const streamsContainer = groupElement?.querySelector('.stream-group');
            if (streamsContainer) {
                console.log("Processing existing group in processSettings:", group.id, "streams:", group.streams);
                group.streams.forEach(sourceId => {
                    if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                        console.log("Creating source element for existing group stream in processSettings:", sourceId);
                        const sourceElement = createSourceElement(sourceId);
                        if (sourceElement) {
                            console.log("Appending to existing group in processSettings:", sourceId);
                            streamsContainer.appendChild(sourceElement);
                        } else {
                            console.error("Failed to create source element in processSettings:", sourceId);
                        }
                    }
                });
            }
        }
    });

    const standaloneSources = stateManager.getSources().filter(s => !s.groupId); 
    if (window.SSAPP_DEBUG_LOGS || standaloneSources.length > 0) {
        console.log(`[Startup] Found ${standaloneSources.length} standalone sources`);
    }
    standaloneSources.forEach(source => {
         if (!document.querySelector(`[data-source-id="${source.id}"]`)) {
            if (window.SSAPP_DEBUG_LOGS) {
                console.log(`[Startup] Creating element for source ${source.id}: autoActivate=${source.autoActivate}`);
            }
            const sourceElement = createSourceElement(source.id);
            if (sourceElement) {
                sourcesContainer.appendChild(sourceElement);
                if (source.autoActivate && !source.vid && !source.wssId) { 
                    setTimeout(async () => {
                        const activateButton = sourceElement.querySelector('[data-activatehtml]');
                        const currentSrcState = stateManager.getSource(source.id); 
                        if (activateButton && currentSrcState && !currentSrcState.vid && !currentSrcState.wssId) {
                            await createWindow(activateButton);
                        }
                    }, 2000 + Math.random() * 1000);
                }
            }
        }
    });
    manageWelcomePage();

    // Apply saved top-level ordering after all items are in the DOM
    try { applyRootOrder(); } catch (e) { console.warn('Failed to apply root order on startup', e); }
}


function isVideoAlreadyAdded(videoId) {
    if (!videoId) return false;
    return stateManager.isVideoIdAdded(videoId);
}


function initializeFeatures() {
    const betaToggle = new BetaToggle(); 
	betaToggle.checkBetaAvailability();

    streamSelector = new YouTubeStreamSelector(); 
	youtubeStatusManager = new YouTubeStatusManager(); 
}

class BetaToggle {
	constructor() {
		this.container = null;
		this.betaVersion = null;
		this.mainVersion = null;
		this.cachedManifest = {}; 
	}
	async checkBetaAvailability() {
		try {
            const betaUrl = 'https://socialstream.ninja/beta/manifest.json';
			const mainUrl = 'https://socialstream.ninja/manifest.json';
			if (this.cachedManifest[betaUrl]) {
				this.betaVersion = this.cachedManifest[betaUrl].version;
			}
			if (this.cachedManifest[mainUrl]) {
				this.mainVersion = this.cachedManifest[mainUrl].version;
			}
			if (!this.betaVersion || !this.mainVersion) {
				const fetchPromises = [];
				if (!this.betaVersion) {
					fetchPromises.push(
						fetch(betaUrl)
							.then(response => response.json())
							.then(data => { this.cachedManifest[betaUrl] = data; this.betaVersion = data.version; })
                            .catch(e => console.warn("Failed to fetch beta manifest", e))
					);
				}
				if (!this.mainVersion) {
					fetchPromises.push(
						fetch(mainUrl)
							.then(response => response.json())
							.then(data => { this.cachedManifest[mainUrl] = data; this.mainVersion = data.version; })
                            .catch(e => console.warn("Failed to fetch main manifest", e))
					);
				}
				await Promise.all(fetchPromises);
			}

            if (this.betaVersion && this.mainVersion) {
    			this.createToggle();
            } else {
                console.warn("Could not fetch necessary version manifests to create Beta Toggle.");
            }
		} catch (error) {
			console.error('Error checking beta availability:', error);
		}
	}
	compareVersions(version1, version2) { 
        if (!version1 || !version2) return 0;
		const parts1 = version1.split('.').map(Number);
		const parts2 = version2.split('.').map(Number);
		for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
			const num1 = parts1[i] || 0;
			const num2 = parts2[i] || 0;
			if (num1 > num2) return 1;
			if (num2 > num1) return -1;
		}
		return 0;
    }

	createToggle() {
        if (document.querySelector('.beta-toggle')) return;
        const currentBetaMode = stateManager.state.global.betaMode;

		this.container = document.createElement('div');
		this.container.className = 'beta-toggle';
        const versions = document.createElement('div');
		versions.className = 'beta-toggle-versions';

        let desktopAppVersion = null;
        if (ipcRenderer && typeof ipcRenderer.sendSync === 'function') {
            try {
                desktopAppVersion = ipcRenderer.sendSync('getVersion');
            } catch (err) {
                console.warn('Unable to read desktop app version for toggle display', err);
            }
        }

        const formatVersion = (value) => value ? `v${value}` : 'N/A';
		versions.innerHTML = `
            <div class="beta-version-row">
                <span class="beta-version-label">Desktop App Engine</span>
                <span class="beta-version-value">${formatVersion(desktopAppVersion)}</span>
            </div>
			<div class="beta-version-row">
                <span class="beta-version-label">Embedded Core · Stable</span>
                <span class="beta-version-value">${formatVersion(this.mainVersion)}</span>
            </div>
			<div class="beta-version-row">
                <span class="beta-version-label">Embedded Core · Beta</span>
                <span class="beta-version-value">${formatVersion(this.betaVersion)}</span>
            </div>
		`;

		const toggleSwitchContainer = document.createElement('div');
        toggleSwitchContainer.className = 'beta-toggle-switch-container';
		const toggle = document.createElement('div');
		toggle.className = `beta-toggle-switch${currentBetaMode ? ' active' : ''}`;
		toggle.addEventListener('click', () => this.handleToggle());
        toggleSwitchContainer.appendChild(toggle);

		const label = document.createElement('span');
		label.className = 'beta-toggle-label';
		label.textContent = currentBetaMode ? 'Beta Core Active' : 'Stable Core Active';

		this.container.appendChild(versions);
		this.container.appendChild(toggleSwitchContainer);
		this.container.appendChild(label);

        const sourcesDiv = document.getElementById("sources");
        if (sourcesDiv && sourcesDiv.firstChild) {
    		sourcesDiv.insertBefore(this.container, sourcesDiv.firstChild);
        } else if (sourcesDiv) {
            sourcesDiv.appendChild(this.container);
        }
	}
	async handleToggle() {
		const newBetaState = !stateManager.state.global.betaMode;
		stateManager.updateGlobal({ betaMode: newBetaState }); 
        isBetaMode = newBetaState; 

		const toggle = this.container.querySelector('.beta-toggle-switch');
		toggle.classList.toggle('active', newBetaState);
		const label = this.container.querySelector('.beta-toggle-label');
		label.textContent = newBetaState ? 'Beta Core Active' : 'Stable Core Active';
        
        Toast.info("Embedded Core Mode Changed", `Switched embedded core to ${newBetaState ? 'Beta' : 'Stable'} mode. Restart app or refresh page for full effect if issues arise.`);

		if (!devmode && !sourcemode) {
            console.log(`Beta mode toggled. Now: ${newBetaState}. Re-initializing parts or consider app reload.`);
            await initializeApplication(); 
		} else {
            console.log("Beta mode toggled, but dev/sourcemode active.");
        }
	}
}

function syncTikTokClassicPreferenceToMain(enabled) {
    if (!ipcRenderer) return;
    try {
        ipcRenderer.send('set-force-tiktok-classic', !!enabled);
    } catch (e) {
        console.warn('Failed to sync TikTok classic preference to main process:', e);
    }
}

function updatePreferTikTokClassicFromState(options = {}) {
    if (typeof stateManager === 'undefined') return;
    const previousClassic = preferTikTokClassic;
    const globalPref = !!(stateManager.state?.global?.forceTikTokClassic);
    const newClassicValue = cliForcesTikTokClassic || globalPref;
    preferTikTokClassic = newClassicValue;

    const storedLast = stateManager.state?.global?.lastTikTokMode;
    const allowedModes = new Set(['classic', 'tiktok-websocket', 'tiktok-legacy']);
    if (storedLast && allowedModes.has(storedLast)) {
        lastTikTokMode = storedLast;
    } else if (preferTikTokClassic) {
        lastTikTokMode = 'classic';
    } else if (stateManager.state?.global?.preferTikTokLegacy) {
        lastTikTokMode = 'tiktok-legacy';
    } else {
        lastTikTokMode = 'tiktok-websocket';
    }

    const classicChanged = options.forceApply || previousClassic !== newClassicValue;
    if (classicChanged) {
        onTikTokClassicPreferenceChanged(newClassicValue, previousClassic, options);
    }
}
function onTikTokClassicPreferenceChanged(newValue, previousValue, options = {}) {
    if (!options.skipSync) {
        syncTikTokClassicPreferenceToMain(newValue);
    }
    applyTikTokClassicPreferenceToAllEntries(newValue, previousValue, options);
}

function applyTikTokClassicPreferenceToAllEntries(newValue, previousValue, options = {}) {
    const entries = document.querySelectorAll('.entry[data-target="tiktok"]');
    entries.forEach(entry => applyTikTokClassicPreferenceToEntry(entry, newValue));

    const preferenceJustEnabled = newValue && !previousValue;
    const shouldAdjustSources = (stateManager && newValue && (preferenceJustEnabled || (options.forceApply && newValue)));
    if (!shouldAdjustSources) {
        return;
    }

    const sources = stateManager.getSources();
    let adjusted = 0;
    sources.forEach(src => {
        if (src.target !== 'tiktok') return;
        if (src.connectionMode === 'tiktok-websocket' || src.connectionMode === 'tiktok-legacy') {
            const updates = { connectionMode: 'classic' };
            if (src.wssId && ipcRenderer) {
                try {
                    ipcRenderer.sendSync('disconnectTikTokConnection', { wssID: src.wssId });
                } catch (e) {
                    console.warn('Error disconnecting TikTok WebSocket during classic fallback:', e);
                }
                updates.wssId = null;
                updates.vid = null;
                updates.status = 'inactive';
            }
            stateManager.updateSource(src.id, updates);
            adjusted++;
        }
    });

    if (adjusted > 0 && !options.silent && preferenceJustEnabled) {
        Toast.info('TikTok Classic Mode', `Switched ${adjusted} TikTok source${adjusted === 1 ? '' : 's'} to classic mode. Reactivate sources to launch fallback windows.`);
    }
}

function applyTikTokClassicPreferenceToEntry(entry, forcedValue) {
    if (!entry || entry.dataset.target !== 'tiktok') return;
    entry.dataset.tiktokClassicForced = forcedValue ? 'true' : 'false';
    const wsOption = entry.querySelector('.mode-option[data-mode="tiktok-websocket"]');
    const legacyOption = entry.querySelector('.mode-option[data-mode="tiktok-legacy"]');
    const wsMenuItem = entry.querySelector('.settings-menu-item[data-tiktokwss="true"]');
    const legacyMenuItem = entry.querySelector('.settings-menu-item[data-tiktoklegacy="true"]');
    const lockMessage = cliForcesTikTokClassic
        ? 'TikTok API connectors are disabled by launch flag.'
        : 'Disable the global TikTok Classic preference to use API connectors.';

    if (wsOption) {
        wsOption.classList.toggle('disabled', forcedValue);
        if (forcedValue) {
            wsOption.dataset.disabled = 'true';
        } else {
            delete wsOption.dataset.disabled;
        }
        wsOption.style.opacity = forcedValue ? '0.6' : '';
        if (!forcedValue) {
            wsOption.title = 'Use the TikTok WebSocket connector when the signer is healthy.';
        } else {
            wsOption.title = lockMessage;
        }
    }
    if (legacyOption) {
        legacyOption.classList.toggle('disabled', forcedValue);
        legacyOption.dataset.disabled = forcedValue ? 'true' : 'false';
        legacyOption.style.opacity = forcedValue ? '0.6' : '';
        legacyOption.title = forcedValue
            ? lockMessage
            : 'Use HTTP polling without signing.';
    }
    if (wsMenuItem) {
        wsMenuItem.classList.toggle('disabled', forcedValue);
        if (forcedValue) {
            wsMenuItem.dataset.disabled = 'true';
        } else {
            delete wsMenuItem.dataset.disabled;
        }
        wsMenuItem.style.opacity = forcedValue ? '0.6' : '';
        if (!wsMenuItem.dataset.originalTitle) {
            wsMenuItem.dataset.originalTitle = wsMenuItem.title || 'Connect to the TikTok API directly using WebSockets';
        }
        wsMenuItem.title = forcedValue
            ? lockMessage
            : (wsMenuItem.dataset.originalTitle || 'Connect to the TikTok API directly using WebSockets');
    }
    if (legacyMenuItem) {
        legacyMenuItem.classList.toggle('disabled', forcedValue);
        legacyMenuItem.dataset.disabled = forcedValue ? 'true' : 'false';
        legacyMenuItem.style.opacity = forcedValue ? '0.6' : '';
        if (!legacyMenuItem.dataset.originalTitle) {
            legacyMenuItem.dataset.originalTitle = legacyMenuItem.title || 'Use HTTP polling without signing.';
        }
        legacyMenuItem.title = forcedValue
            ? lockMessage
            : legacyMenuItem.dataset.originalTitle;
    }
}


async function initializeConfig() { 
    configReady = false;
	try {
		const os = getOperatingSystem();
		const configFileName = getConfigFileName(os);
		const currentBetaMode = stateManager.initialized ? stateManager.state.global.betaMode : (localStorage.getItem('betaMode') === 'true'); 

		const configUrl =
			sourcemode ? `${sourcemode}/settings/${configFileName}` :
			devmode ? `file:///C:/Users/steve/Code/social_stream/settings/${configFileName}` :
			currentBetaMode ? `https://socialstream.ninja/beta/settings/${configFileName}` :
			`https://socialstream.ninja/settings/${configFileName}`;
		
		const response = await fetch(configUrl.trim());
		const data = await response.json();
		if (data) {
			config = data;
			localStorage.setItem('config', JSON.stringify(data));
		}
	} catch (e) {
        Toast.error("Error", 'Failed to load the user-agent config file.');
		console.error('Failed to load remote config:', e);
		const storedConfigTemp = localStorage.getItem('config'); 
		if (storedConfigTemp) {
			try {
				const parsedConfig = JSON.parse(storedConfigTemp);
				if (!parsedConfig || Object.keys(parsedConfig).length === 0) {
					console.error('Parsed stored config is empty, using default.');
					config = getDefaultConfig();
				} else {
					config = parsedConfig;
				}
			} catch (parseError) {
				console.error('Failed to parse stored config, using default:', parseError);
				config = getDefaultConfig();
			}
		} else { 
			config = getDefaultConfig();
		}
	}
	configReady = true;
	return config;
}

// DOMContentLoaded Listener
document.addEventListener('DOMContentLoaded', async function() {
    await stateManager.init();

    if (cliForcesTikTokClassic && !stateManager.state.global.forceTikTokClassic) {
        tikTokClassicSilentUpdate = true;
        stateManager.updateGlobal({ forceTikTokClassic: true });
    } else {
        updatePreferTikTokClassicFromState({ forceApply: true, silent: true });
    }

    // Clean up stale window IDs on startup
    const sources = stateManager.getSources();
    for (const source of sources) {
        // Set default connection mode for TikTok sources if not set
        if (source.target === 'tiktok' && !source.connectionMode) {
            const defaultMode = (preferTikTokClassic || cliForcesTikTokClassic)
            ? 'classic'
            : (lastTikTokMode || 'tiktok-websocket');
            console.log(`Setting default ${defaultMode} mode for ${source.id} on startup`);
            stateManager.updateSource(source.id, { connectionMode: defaultMode });
        }
        
        // Check regular windows
        if (source.vid && ipcRenderer) {
            const windowExists = await ipcRenderer.invoke('checkWindowExists', { vid: source.vid });
            if (!windowExists) {
                stateManager.updateSource(source.id, { vid: null, status: 'inactive', activeConnectionMode: null });
            }
        }
        
        // Clean up websocket IDs on startup - websocket connections don't persist across app restarts
        if (source.wssId) {
            console.log(`Clearing stale wssId ${source.wssId} for ${source.id} on startup`);
            stateManager.updateSource(source.id, { vid: null, wssId: null, status: 'inactive', activeConnectionMode: null });
        }

        // Normalize any lingering activating/active states when nothing is connected
        const hasActiveWindow = !!(source.vid || source.wssId);
        if (!hasActiveWindow && STALE_CONNECTION_STATUSES.has(source.status)) {
            stateManager.updateSource(source.id, { status: 'inactive', error: null, activeConnectionMode: null });
        }
        
        // Clear video IDs and chat IDs for username-based Rumble sources
        if (source.target === 'rumble' && source.username && (source.videoId || source.chatId)) {
            stateManager.updateSource(source.id, { videoId: null, chatId: null, url: null });
        }
    }
    
    // Listen for source updates to keep UI in sync
    stateManager.on('sourceUpdated', ({ sourceId, updates }) => {
        console.log(`Source ${sourceId} updated:`, updates);
        const sourceElement = document.querySelector(`[data-source-id="${sourceId}"]`);
        if (sourceElement) {
            const source = stateManager.getSource(sourceId);
            if (source) {
                if (updates.status === 'activating' && source.target === 'tiktok' && (source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy')) {
                    setActivateButtonConnecting(sourceElement);
                }
                // Update mute button state if mute state changed
                if ('isMuted' in updates) {
                    const muteButton = sourceElement.querySelector('[data-togglemute]');
                    if (muteButton) {
                        muteButton.classList.toggle('active', source.isMuted);
                        console.log(`Updated mute button UI for ${sourceId}: ${source.isMuted}`);
                    }
                }
                // Update visibility button state if visibility changed
                if ('isVisible' in updates) {
                    const visibilityButton = sourceElement.querySelector('[data-togglehtml]');
                    if (visibilityButton) {
                        visibilityButton.classList.toggle('active', !source.isVisible);
                    }
                }
            }
        }
    });

    updatePreferTikTokClassicFromState({ forceApply: true, silent: cliForcesTikTokClassic });
    
    // Start auto-checking for YouTube groups and Rumble sources with auto-activate enabled
    setTimeout(() => {
        // Verify fetchYoutube is available
        if (typeof fetchYoutube !== 'function') {
            console.error("Warning: fetchYoutube function not available. YouTube fallback scraping will not work.");
            console.error("Make sure youtube.js is properly loaded.");
        } else {
            console.log("fetchYoutube function is available for fallback.");
        }
        
        // Check YouTube groups
        const groups = stateManager.getGroups();
        groups.forEach(group => {
            if (group.autoActivate && (group.target === "youtube" || group.target === "youtubeshorts")) {
                console.log(`Starting auto-check for YouTube group on startup: ${group.username}`);
                startYouTubeGroupAutoCheck(group.id);
            }
        });
        
        // Check Rumble sources and update TikTok UI
        const sources = stateManager.getSources();
        sources.forEach(source => {
            // Update TikTok sources to show correct mode
            if (source.target === 'tiktok') {
                const sourceElement = document.querySelector(`[data-source-id="${source.id}"]`);
                if (sourceElement) {
                    const fallbackMode = (preferTikTokClassic || cliForcesTikTokClassic)
                        ? 'classic'
                        : (lastTikTokMode || 'tiktok-websocket');
                    const mode = source.connectionMode || fallbackMode;
                    
                    // Update button text
                    updateSourceUIAfterModeChange(sourceElement, mode, false);
                    
                    // Update mode selector to show active state
                    const modeOptions = sourceElement.querySelectorAll('.mode-option');
                    modeOptions.forEach(opt => {
                        opt.classList.remove('active');
                        if (opt.dataset.mode === mode) {
                            opt.classList.add('active');
                        }
                    });
                }
            }
            
            // Only auto-check username-based Rumble sources
            if (source.autoActivate && source.target === 'rumble' && source.username && source.status !== 'active') {
                console.log(`Starting auto-check for Rumble source on startup: ${source.username}`);
                startRumbleAutoCheck(source.id);
            }
        });
    }, 2000); // Small delay to ensure UI is ready 

    // Check for pending import from session import
    const pendingImport = localStorage.getItem('pendingImport');
    if (pendingImport) {
        try {
            const importData = JSON.parse(pendingImport);
            // Restore all the localStorage data from the import
            for (const [key, value] of Object.entries(importData)) {
                if (value !== null) {
                    localStorage.setItem(key, value);
                }
            }
            localStorage.removeItem('pendingImport');
            // Re-initialize state manager with imported data
            await stateManager.init();
            Toast.success('Import Complete', 'Session data has been imported successfully');
        } catch (e) {
            console.error('Error applying pending import:', e);
            Toast.error('Import Error', 'Failed to apply imported session data');
            localStorage.removeItem('pendingImport');
        }
    }

    isBetaMode = stateManager.state.global.betaMode;
    localStorage.setItem('betaMode', isBetaMode.toString());
    localStorage.setItem('youtubeAutoAdd', stateManager.state.global.youtubeAutoAdd.toString());
    localStorage.setItem('youtubeAutoCleanup', stateManager.state.global.youtubeAutoCleanup.toString());
    localStorage.setItem('youtubeCheckInterval', stateManager.state.global.youtubeCheckInterval.toString());

    /* Modified sourceAdded listener */
    stateManager.on('sourceAdded', ({ source }) => {
        console.log("sourceAdded event:", source.id, "videoId:", source.videoId, "groupId:", source.groupId);
        let element = document.querySelector(`[data-source-id="${source.id}"]`);
        if (element) {
            console.warn(`sourceAdded listener: Element for source ${source.id} already exists. Updating UI.`);
            updateSourceUI(element, source);
            // Ensure it's in the correct parent if misplaced (e.g., if group DOM wasn't ready)
            const correctParentSelector = source.groupId ? `[data-group-id="${source.groupId}"] .stream-group` : '#sources';
            const correctParent = document.querySelector(correctParentSelector);
            if (correctParent && element.parentElement !== correctParent && !(element.parentElement.id === 'sources' && !source.groupId) ) {
                 console.log(`Moving ${source.id} to correct parent: ${correctParentSelector}`);
                 correctParent.appendChild(element);
            }
            return;
        }

        element = createSourceElement(source.id); 
        if (!element) {
            console.error(`sourceAdded listener: Failed to create element for source ${source.id}`);
            return;
        }

        if (!source.groupId) {
            document.getElementById("sources").appendChild(element);
            // Maintain root order for standalone sources
            try {
                let ro = getRootOrder();
                const key = `s:${source.id}`;
                if (!ro.includes(key)) {
                    ro.push(key);
                    setRootOrder(ro);
                }
                if (ro.length) reorderTopLevelDomAccordingToRootOrder();
            } catch (e) { /* noop */ }
        } else {
            const groupElement = document.querySelector(`[data-group-id="${source.groupId}"]`);
            if (groupElement) {
                const streamsContainer = groupElement.querySelector('.stream-group');
                if (streamsContainer) {
                    streamsContainer.appendChild(element);
                } else {
                    console.warn(`sourceAdded listener: '.stream-group' not found in group ${source.groupId}. Appending source ${source.id} to group header as fallback.`);
                    groupElement.appendChild(element); 
                }
            } else {
                console.warn(`sourceAdded listener: Group element for groupId ${source.groupId} not found. Appending source ${source.id} to main 'sources' list temporarily.`);
                document.getElementById("sources").appendChild(element);
            }
        }
        manageWelcomePage();

        // Gentle reminder: for newly created manual sources, hint about sign-in and activation
        // For TikTok, only show this if the connection mode is classic (default is TikTok WS)
        try {
            const isManual = !source.isAutoDiscovered;
            const target = source.target;
            const connMode = source.connectionMode;
            const allowTip = isManual && element && !element.dataset.tipShown && ((target !== 'tiktok') || (connMode === 'classic'));
            if (allowTip) {
                updateConnectionStatus(element, 'info', 'Tip: Sign in on the site if needed, then press ▶️ Activate and make sure the chat is visible.');
                element.dataset.tipShown = '1';
            }
        } catch (_) {}
    });


    stateManager.on('sourceUpdated', ({ sourceId, updates, oldState }) => {
        const element = document.querySelector(`[data-source-id="${sourceId}"]`);
        const source = stateManager.getSource(sourceId);
        if (element && source) {
            updateSourceUI(element, source);
        }

        if ('wssId' in updates && updates.wssId) {
            drainPendingTikTokStatuses(updates.wssId, sourceId, element);
        }

        // If a TikTok source switches to classic mode, show a one-time sign-in/activation tip
        try {
            if (element && source && source.target === 'tiktok' && !element.dataset.tipShown) {
                if ('connectionMode' in updates && updates.connectionMode === 'classic') {
                    updateConnectionStatus(element, 'info', 'Tip: Sign in on the site if needed, then press ▶️ Activate and make sure the chat is visible.');
                    element.dataset.tipShown = '1';
                }
            }
        } catch (_) {}
        
        if ('groupId' in updates) {
            const currentElement = document.querySelector(`[data-source-id="${sourceId}"]`); 
            if (!currentElement) return; 

            if (oldState.groupId && oldState.groupId !== updates.groupId) {
                const oldGroupStreamsContainer = document.querySelector(`[data-group-id="${oldState.groupId}"] .stream-group`);
                const elInOldGroup = oldGroupStreamsContainer?.querySelector(`[data-source-id="${sourceId}"]`);
                elInOldGroup?.remove();
            }

            // Maintain rootOrder when moving between standalone/grouped
            try {
                let ro = getRootOrder();
                const key = `s:${sourceId}`;
                const movedIntoGroup = !!updates.groupId;
                const wasInGroup = !!oldState.groupId;
                if (movedIntoGroup) {
                    if (ro.includes(key)) {
                        ro = ro.filter(k => k !== key);
                        setRootOrder(ro);
                        reorderTopLevelDomAccordingToRootOrder();
                    }
                } else if (wasInGroup && !movedIntoGroup) {
                    if (!ro.includes(key)) {
                        ro.push(key);
                        setRootOrder(ro);
                        reorderTopLevelDomAccordingToRootOrder();
                    }
                }
            } catch (e) { /* noop */ }
            
            if (updates.groupId) {
                 const newGroupEl = document.querySelector(`[data-group-id="${updates.groupId}"]`);
                 const streamsContainer = newGroupEl?.querySelector('.stream-group');
                 if (streamsContainer && !streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                    streamsContainer.appendChild(currentElement); 
                 } else if (!streamsContainer && newGroupEl && !newGroupEl.querySelector(`[data-source-id="${sourceId}"]`)) {
                    newGroupEl.appendChild(currentElement); 
                 }
            } else if (!updates.groupId && currentElement.parentElement?.closest?.('[data-is-group-header="true"]')) { 
                 if (currentElement.parentElement.id !== 'sources') {
                    document.getElementById("sources").appendChild(currentElement); 
                 }
            }
        }
    });

    stateManager.on('sourceRemoved', ({ sourceId, source }) => {
        const element = document.querySelector(`[data-source-id="${sourceId}"]`);
        element?.remove();
        if (source && source.wssId) {
            pendingTikTokStatusQueue.delete(source.wssId);
        }
        // Stop any platform-specific auto-checkers for this source
        try {
            if (source && source.target === 'rumble') {
                stopRumbleAutoCheck(sourceId);
            }
        } catch (e) { console.warn('Error stopping auto-check for removed source', sourceId, e); }
        // Update root order if standalone
        try {
            if (source && !source.groupId) {
                let ro = getRootOrder();
                const key = `s:${sourceId}`;
                if (ro.includes(key)) {
                    ro = ro.filter(k => k !== key);
                    setRootOrder(ro);
                }
            }
        } catch (e) { /* noop */ }
        manageWelcomePage();
    });

    /* Modified groupAdded listener */
    stateManager.on('groupAdded', ({ group }) => {
        let groupElement = document.querySelector(`[data-group-id="${group.id}"]`);
        if (groupElement) {
            console.warn(`groupAdded listener: Group element for ID ${group.id} already exists. Updating UI and checking children.`);
            updateGroupUI(groupElement, group); 
            const streamsContainer = groupElement.querySelector('.stream-group');
            if (streamsContainer) {
                group.streams.forEach(sourceId => {
                    if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) {
                        const tempSourceElement = document.getElementById("sources").querySelector(`:scope > [data-source-id="${sourceId}"]`);
                        if (tempSourceElement) {
                            streamsContainer.appendChild(tempSourceElement); 
                        } else {
                            const sourceElement = createSourceElement(sourceId); 
                            if (sourceElement) streamsContainer.appendChild(sourceElement);
                        }
                    }
                });
            }
            return;
        }

        groupElement = createGroupElement(group.id); 
        if (groupElement) {
            document.getElementById("sources").appendChild(groupElement);
            // Maintain root order for groups
            try {
                let ro = getRootOrder();
                const key = `g:${group.id}`;
                if (!ro.includes(key)) {
                    ro.push(key);
                    setRootOrder(ro);
                }
                if (ro.length) reorderTopLevelDomAccordingToRootOrder();
            } catch (e) { /* noop */ }
            const streamsContainer = groupElement.querySelector('.stream-group');
            if (streamsContainer) {
                group.streams.forEach(sourceId => {
                    const sourceState = stateManager.getSource(sourceId);
                    if (sourceState?.groupId === group.id) { 
                        const tempSourceElement = document.getElementById("sources").querySelector(`:scope > [data-source-id="${sourceId}"]`);
                        if (tempSourceElement) { 
                            if (!streamsContainer.querySelector(`[data-source-id="${sourceId}"]`)) { 
                                streamsContainer.appendChild(tempSourceElement); 
                            }
                        }
                    }
                });
            }
        }
        manageWelcomePage();
    });
    
    stateManager.on('groupUpdated', ({ groupId, updates }) => {
        const element = document.querySelector(`[data-group-id="${groupId}"]`);
        const group = stateManager.getGroup(groupId);
        if (element && group) {
            updateGroupUI(element, group);
            try { reorderGroupDom(groupId); } catch (e) { /* noop */ }
        }
    });
    
    stateManager.on('groupRemoved', ({ groupId, group }) => {
        const element = document.querySelector(`[data-group-id="${groupId}"]`);
        element?.remove();
        // Stop any YouTube group auto-check timers
        try { stopYouTubeGroupAutoCheck(groupId); } catch (e) { /* noop */ }
        // Update root order for groups
        try {
            let ro = getRootOrder();
            const key = `g:${groupId}`;
            if (ro.includes(key)) {
                ro = ro.filter(k => k !== key);
                setRootOrder(ro);
            }
        } catch (e) { /* noop */ }
        manageWelcomePage();
    });
    
    stateManager.on('globalUpdated', ({ updates }) => {
        if ('forceTikTokClassic' in updates || 'lastTikTokMode' in updates) {
            const opts = {
                forceApply: 'forceTikTokClassic' in updates,
                silent: tikTokClassicSilentUpdate
            };
            tikTokClassicSilentUpdate = false;
            updatePreferTikTokClassicFromState(opts);
        }
        if ('betaMode' in updates) {
            isBetaMode = updates.betaMode;
             console.log("Global betaMode updated, re-initializing application for full effect.");
             initializeApplication(); 
        }
        if (youtubeStatusManager && (
            'youtubeAutoAdd' in updates || 
            'youtubeAutoCleanup' in updates || 
            'youtubeCheckInterval' in updates
        )) {
            youtubeStatusManager.settingsChanged(updates); 
        }
    });


    initializeFeatures(); 
	await checkForUpdates();

	let ready = await initializeApplication();
	if (ready) {
		processSettingsAndCreateSources(); 
	} else {
        console.error("Application initialization failed. Some features may be unavailable.");
        Toast.error("Initialization Error", "App could not start correctly. Please check console or try restarting.");
    }

	if (!window.streamSelector) {
		window.streamSelector = new YouTubeStreamSelector();
	}

	const navigationLinks = document.querySelectorAll('#main-navigation a');
    const frame1 = document.getElementById('frame1');
	const frame2 = document.getElementById('frame2');
	const frame3 = document.getElementById('frame3');

	function switchToPage(pageId) { 
        navigationLinks.forEach(link => {
			link.classList.toggle('active', link.dataset.page === pageId);
		});

        document.getElementById('streams-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('dashboard-page')?.style.setProperty('display', 'none', 'important');
        //document.getElementById('link-overlay-page')?.style.setProperty('display', 'none', 'important');
        document.getElementById('vdo-ninja-page')?.style.setProperty('display', 'none', 'important');
       // if (frame1) frame1.style.setProperty('display', 'none', 'important');
        if (frame2) frame2.style.setProperty('display', 'none', 'important');
        if (frame3) frame3.style.setProperty('display', 'none', 'important');


        const streamsPage = document.getElementById('streams-page');
        const dashboardPage = document.getElementById('dashboard-page');
        //const linkOverlayPage = document.getElementById('link-overlay-page');
        const vdoNinjaPage = document.getElementById('vdo-ninja-page');

		if (pageId === 'dashboard' || pageId === 'event-flow-editor') {
			if (dashboardPage) dashboardPage.style.display = 'block'; 
			if (frame2) {
				frame2.style.display = 'block'; 
                const viewFunction = pageId === 'dashboard' ? 'showDashboardView' : 'showEditorView';
                // Use postMessage for cross-origin communication
                const sendViewMessage = () => {
                    try {
                        frame2.contentWindow.postMessage({ action: viewFunction }, '*');
                    } catch (err) {
                        console.error('Failed to communicate with iframe:', err);
                    }
                };
                
                // Check if iframe is already loaded
                if (frame2.contentDocument && frame2.contentDocument.readyState === 'complete') {
                    sendViewMessage();
                } else {
                    // Wait for iframe to load
                    frame2.addEventListener('load', sendViewMessage, { once: true });
                    // Also try sending after a delay in case the load event already fired
                    setTimeout(sendViewMessage, 500);
                }
			}
		} else if (pageId === 'link-overlay') {
			//if (linkOverlayPage) linkOverlayPage.style.display = 'block';
		//	if (frame1) frame1.style.display = 'block';
		} else if (pageId === 'streams') {
			if (streamsPage) streamsPage.style.display = 'block';
		} else if (pageId === 'vdo-ninja') {
			if (vdoNinjaPage) vdoNinjaPage.style.display = 'block';
			if (frame3) frame3.style.display = 'block';
		}

        if ((pageId === 'dashboard' || pageId === 'event-flow-editor') && frame2 && (!frame2.src || frame2.src === "about:blank")) {
			setupIframeSource(); 
		} else if (pageId === 'link-overlay' && frame1 && (!frame1.src || frame1.src === "about:blank")) {
			let popupSrc = "";
            if (sourcemode) {
                popupSrc = `${sourcemode}popup.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                if (devmode) popupSrc += "&devmode";
            } else if (devmode) {
                popupSrc = `file:///C:/Users/steve/Code/social_stream/popup.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
                popupSrc = `${domain}/popup.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
			frame1.src = popupSrc;
            frame1.classList.add('loading');
		} else if (pageId === 'vdo-ninja' && frame3 && (!frame3.src || frame3.src === "about:blank")) {
			let vdoSrc = "";
            if (sourcemode) {
                vdoSrc = `${sourcemode}vdo.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                 if (devmode) vdoSrc += "&devmode";
            } else if (devmode) {
                vdoSrc = `file:///C:/Users/steve/Code/social_stream/vdo.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
    			vdoSrc = `${domain}/vdo.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
			frame3.src = vdoSrc;
            frame3.classList.add('loading');
		}
        stateManager.updateGlobal({ currentPage: pageId });
    }

	navigationLinks.forEach(link => {
		link.addEventListener('click', function(event) {
			event.preventDefault();
			const pageId = this.dataset.page;
			switchToPage(pageId);
		});
	});

    const initialPage = stateManager.state.global.currentPage || 'streams';
	switchToPage(initialPage); 

    // Popup sidebar show/hide toggle setup (subtle edge handle)
    (function setupPopupSidebarToggle() {
        const linkOverlay = document.getElementById('link-overlay-page');
        const handle = document.getElementById('popup-handle');
        const frame1 = document.getElementById('frame1');
        if (!linkOverlay || !handle) return;

        function applyCollapsedState(collapsed) {
            try {
                document.body.classList.toggle('overlay-collapsed', !!collapsed);
                document.body.classList.toggle('overlay-expanded', !collapsed);
                if (frame1) {
                    // Prevent interactions when collapsed (CSS also hides it)
                    frame1.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
                }
                handle.textContent = collapsed ? '⯈' : '⯇';
                handle.title = collapsed ? 'Show chat panel' : 'Hide chat panel';
            } catch (e) { console.error('Failed to apply popup collapsed state:', e); }
        }

        function toggle() {
            const collapsed = localStorage.getItem('popupCollapsed') === 'true';
            const next = !collapsed;
            localStorage.setItem('popupCollapsed', String(next));
            applyCollapsedState(next);
        }

        handle.addEventListener('click', toggle);
        handle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                toggle();
            }
        });

        // Initialize from saved state
        const savedCollapsed = localStorage.getItem('popupCollapsed') === 'true';
        applyCollapsedState(savedCollapsed);
    })();

    if (ipcRenderer) {
        const handledInjectorStatusKeys = new Set();
        ipcRenderer.on('socialstream-injector-status', (event, payload = {}) => {
            try {
                const level = payload.level || 'info';
                const title = payload.title || 'Classic Mode';
                const message = payload.message || '';
                if (!message) return;
                const key = `${level}|${title}|${message}`;
                if (handledInjectorStatusKeys.has(key)) return;
                handledInjectorStatusKeys.add(key);
                const toastFn = (typeof Toast?.[level] === 'function') ? Toast[level].bind(Toast) : Toast.info.bind(Toast);
                toastFn(title, message);
            } catch (err) {
                console.warn('Failed to apply socialstream-injector-status toast:', err);
            }
        });

        ipcRenderer.on('fromMainToIndex', (event, ...args) => { 
            log("FROM MAIN TO INDEX", args[0]);
            if (args[0] == "serverStarted") {
                console.log("serverStarted");
                localServer = "&localserver";
                setupIframeSource(); 
            } else if (args[0] == "serverStopped") {
                console.log("serverStopped");
                localServer = "";
                setupIframeSource(); 
            }
            const currentFrame1Src = document.getElementById("frame1")?.src;
            let expectedFrame1Src = "";
             if (sourcemode) {
                expectedFrame1Src = `${sourcemode}popup.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
                if (devmode) expectedFrame1Src += "&devmode";
            } else if (devmode) {
                expectedFrame1Src = `file:///C:/Users/steve/Code/social_stream/popup.html?devmode&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            } else {
                const domain = isBetaMode ? 'https://socialstream.ninja/beta' : 'https://socialstream.ninja';
                expectedFrame1Src = `${domain}/popup.html?v=2&ssapp=2${localServer}&basePath=${encodeURIComponent(basePath)}`;
            }
            if (document.getElementById("frame1") && currentFrame1Src !== expectedFrame1Src) {
                 document.getElementById("frame1").src = expectedFrame1Src;
            }
        });

        ipcRenderer.on(`window-hidden`, (event, ...args) => {
            let tabId = args[0]?.tabID;
            if (tabId) {
                const sourceToUpdate = stateManager.getSources({ vid: tabId })[0];
                if (sourceToUpdate) {
                    stateManager.updateSource(sourceToUpdate.id, { isVisible: false });
                }
            }
        });
        
        ipcRenderer.on(`window-shown`, (event, ...args) => { 
            let tabId = args[0]?.tabID;
            if (tabId) {
                const sourceToUpdate = stateManager.getSources({ vid: tabId })[0];
                if (sourceToUpdate) {
                    stateManager.updateSource(sourceToUpdate.id, { isVisible: true });
                }
            }
        });

        // Auto-close notification from main when a classic window navigates away
        ipcRenderer.on('window-auto-closed', (event, payload) => {
            try {
                const { tabID, sourceId, reason, mode, initialUrl, newUrl } = payload || {};
                let source = null;
                if (sourceId) {
                    source = stateManager.getSource(sourceId);
                }
                if (!source && tabID) {
                    source = stateManager.getSources({ vid: tabID })[0];
                }
                if (source) {
                    stateManager.updateSource(source.id, { status: 'inactive', vid: null, activeConnectionMode: null });
                }
                const title = 'Source Stopped';
                const msg = `Closed due to navigation change (${mode || 'prefix'} via ${reason || 'navigate'}).`;
                Toast.info(title, msg);
            } catch (e) {
                console.warn('Failed to handle window-auto-closed event:', e);
            }
        });

        
        // Generic WebSocket status updates from WSS windows (YouTube, etc.)
        ipcRenderer.on('wssStatus', (event, payload) => {
            try {
                const tabId = payload && payload.tabID;
                if (!tabId) return;
                const source = stateManager.getSources({ vid: tabId })[0];
                if (!source) return;
                const entryElement = document.querySelector(`[data-source-id="${source.id}"]`);
                if (!entryElement) return;

                const status = payload.status;
                const message = payload.message || null;
                switch (status) {
                    case 'signin_required':
                        stateManager.updateSource(source.id, { status: 'error' });
                        updateConnectionStatus(entryElement, 'error', 'Please sign in');
                        // Auto-reveal the WSS window for sign-in
                        if (ipcRenderer && source.vid) {
                            ipcRenderer.invoke('showWindow', { vid: source.vid, state: false }).then((visible) => {
                                stateManager.updateSource(source.id, { isVisible: (typeof visible === 'boolean') ? visible : true });
                            }).catch(() => stateManager.updateSource(source.id, { isVisible: true }));
                        }
                        break;
                    case 'ready':
                        updateConnectionStatus(entryElement, 'retry', message || 'Ready. Configure in popup.');
                        break;
                    case 'connected':
                        stateManager.updateSource(source.id, { status: 'active' });
                        updateConnectionStatus(entryElement, 'connected');
                        break;
                    case 'disconnected':
                    case 'signed_out':
                        stateManager.updateSource(source.id, { status: 'inactive', activeConnectionMode: null });
                        updateConnectionStatus(entryElement, 'stopped', message || 'Disconnected');
                        setTimeout(() => updateConnectionStatus(entryElement, 'clear'), 2000);
                        break;
                    case 'error':
                        stateManager.updateSource(source.id, { status: 'error', error: message || 'Error' });
                        updateConnectionStatus(entryElement, 'error', message || 'Error');
                        break;
                }
            } catch (e) { console.warn('Failed to apply wssStatus:', e); }
        });

        function enqueuePendingTikTokStatus(status) {
            if (!status || typeof status.wssID !== 'number') return;
            const existing = pendingTikTokStatusQueue.get(status.wssID);
            if (existing) {
                existing.push(status);
                if (existing.length > 10) {
                    existing.splice(0, existing.length - 10);
                }
            } else {
                pendingTikTokStatusQueue.set(status.wssID, [status]);
            }
        }

        function drainPendingTikTokStatuses(wssId, sourceId, entryElement) {
            if (!wssId) return;
            const queued = pendingTikTokStatusQueue.get(wssId);
            if (!queued || queued.length === 0) return;
            pendingTikTokStatusQueue.delete(wssId);
            queued.forEach(status => {
                applyTikTokStatusUpdate(status, sourceId, entryElement);
            });
        }

        function applyTikTokStatusUpdate(data, sourceId, entryElementOverride) {
            if (!data || !sourceId) return;
            const entryElement = entryElementOverride || document.querySelector(`[data-source-id="${sourceId}"]`);
            const currentState = stateManager.getSource(sourceId);
            if (!currentState) {
                if (typeof data.wssID === 'number') {
                    pendingTikTokStatusQueue.delete(data.wssID);
                }
                return;
            }

            const setConnectingStopUI = () => {
                if (entryElement) setActivateButtonConnecting(entryElement);
            };
            const restoreActivateUI = () => {
                if (entryElement) restoreActivateButton(entryElement);
            };

            if (currentState.status === 'inactive' && !currentState.vid && !currentState.wssId && (data.status === 'error' || data.status === 'failed' || data.status === 'disconnected')) {
                return;
            }

            switch (data.status) {
                case 'connecting':
                    if (currentState.status !== 'activating') {
                        stateManager.updateSource(sourceId, { status: 'activating' });
                    }
                    if (entryElement) {
                        if (entryElement._tiktokRetryTimer) {
                            clearInterval(entryElement._tiktokRetryTimer);
                            entryElement._tiktokRetryTimer = null;
                        }
                        entryElement._tiktokRetryEndAt = null;
                        entryElement._tiktokRetryAttempt = null;
                        entryElement._tiktokRetryMax = null;
                        updateConnectionStatus(entryElement, 'connecting');
                        setConnectingStopUI();
                    }
                    break;
                case 'connected':
                    if (entryElement) {
                        if (entryElement._tiktokRetryTimer) {
                            clearInterval(entryElement._tiktokRetryTimer);
                            entryElement._tiktokRetryTimer = null;
                        }
                        entryElement._tiktokRetryEndAt = null;
                        entryElement._tiktokRetryAttempt = null;
                        entryElement._tiktokRetryMax = null;
                    }
                    stateManager.updateSource(sourceId, { status: 'active', tiktokFallbackMode: null });
                    if (entryElement) updateConnectionStatus(entryElement, 'connected');
                    if (entryElement && entryElement._tiktokFallback) {
                        try {
                            const latestSource = stateManager.getSource(sourceId);
                            const effectiveMode = latestSource ? getEffectiveConnectionMode(latestSource) : null;
                            entryElement._tiktokFallback.connectedMode = normalizeTikTokMode(
                                effectiveMode || latestSource?.connectionMode || entryElement._tiktokFallback.preferredMode
                            );
                            entryElement._tiktokFallback.pendingAutoRetry = false;
                            entryElement._tiktokFallback.exhausted = false;
                            entryElement._tiktokFallback.notifiedExhausted = false;
                        } catch (_) { /* noop */ }
                    }
                    restoreActivateUI();
                    break;
                case 'disconnected':
                    stateManager.updateSource(sourceId, { status: 'error', error: data.error || 'Connection lost.', vid: null, tiktokFallbackMode: null });
                    if (entryElement) {
                        if (entryElement._tiktokRetryEndAt) {
                            const remainingMs = Math.max(0, entryElement._tiktokRetryEndAt - Date.now());
                            const secs = Math.ceil(remainingMs / 1000);
                            const attemptInfo = entryElement._tiktokRetryAttempt ? ` (attempt ${entryElement._tiktokRetryAttempt}${entryElement._tiktokRetryMax ? '/' + entryElement._tiktokRetryMax : ''})` : '';
                            const msg = `${data.error || 'Connection lost'} - retrying in ${secs}s...${attemptInfo}`;
                            updateConnectionStatus(entryElement, 'retry', msg);
                            setConnectingStopUI();
                        } else {
                            updateConnectionStatus(entryElement, 'error', data.error || 'Connection lost. Will attempt to reconnect if configured.');
                            restoreActivateUI();
                        }
                    }
                    break;
                case 'error':
                    stateManager.updateSource(sourceId, { status: 'error', error: data.error || 'Connection error', tiktokFallbackMode: null });
                    if (entryElement) {
                        if (entryElement._tiktokRetryEndAt) {
                            const remainingMs = Math.max(0, entryElement._tiktokRetryEndAt - Date.now());
                            const secs = Math.ceil(remainingMs / 1000);
                            const attemptInfo = entryElement._tiktokRetryAttempt ? ` (attempt ${entryElement._tiktokRetryAttempt}${entryElement._tiktokRetryMax ? '/' + entryElement._tiktokRetryMax : ''})` : '';
                            const msg = `${data.error || 'Connection error'} - retrying in ${secs}s...${attemptInfo}`;
                            updateConnectionStatus(entryElement, 'retry', msg);
                            setConnectingStopUI();
                        } else {
                            updateConnectionStatus(entryElement, 'error', data.error || 'Connection error');
                            restoreActivateUI();
                        }
                    }
                    break;
                case 'failed':
                    stateManager.updateSource(sourceId, { status: 'error', error: data.error || 'Connection failed', vid: null, tiktokFallbackMode: null });
                    if (entryElement) {
                        if (entryElement._tiktokRetryEndAt) {
                            const remainingMs = Math.max(0, entryElement._tiktokRetryEndAt - Date.now());
                            const secs = Math.ceil(remainingMs / 1000);
                            const attemptInfo = entryElement._tiktokRetryAttempt ? ` (attempt ${entryElement._tiktokRetryAttempt}${entryElement._tiktokRetryMax ? '/' + entryElement._tiktokRetryMax : ''})` : '';
                            const msg = `${data.error || 'Connection failed'} - retrying in ${secs}s...${attemptInfo}`;
                            updateConnectionStatus(entryElement, 'retry', msg);
                            setConnectingStopUI();
                        } else {
                            updateConnectionStatus(entryElement, 'error', data.error || 'Connection failed');
                            restoreActivateUI();
                        }
                    }
                    break;
                case 'fatal_error':
                    if (entryElement) {
                        if (entryElement._tiktokRetryTimer) {
                            clearInterval(entryElement._tiktokRetryTimer);
                            entryElement._tiktokRetryTimer = null;
                        }
                        entryElement._tiktokRetryEndAt = null;
                        entryElement._tiktokRetryAttempt = null;
                        entryElement._tiktokRetryMax = null;
                    }
                    stateManager.updateSource(sourceId, { status: 'error', error: data.error || 'Connection failed', vid: null, wssId: null, tiktokFallbackMode: null });
                    if (entryElement) {
                        updateConnectionStatus(entryElement, 'error', data.error || 'Connection failed');
                        if (entryElement._tiktokFallback) {
                            entryElement._tiktokFallback.pendingAutoRetry = false;
                            entryElement._tiktokFallback.lastFailureStatus = 'fatal_error';
                            entryElement._tiktokFallback.lastFailureMessage = data.error || null;
                        }
                    }
                    restoreActivateUI();
                    autoFallbackToNextTikTokMode(sourceId, 'fatal_error', data.error || null);
                    break;
                case 'fallback_polling':
                    stateManager.updateSource(sourceId, {
                        status: 'activating',
                        error: null,
                        tiktokFallbackMode: 'polling'
                    });
                    if (entryElement) {
                        updateConnectionStatus(entryElement, 'info', data.error || 'TikTok signer unavailable. Switching to legacy connector...');
                        setConnectingStopUI();
                    }
                    {
                        const infoMessage = data.error || 'TikTok signer unavailable.';
                        const formatted = infoMessage.endsWith('.') ? infoMessage : `${infoMessage}.`;
                        Toast.info('TikTok Fallback', `${formatted} Using legacy connector.`);
                    }
                    break;
                case 'reconnecting':
                    stateManager.updateSource(sourceId, { status: 'activating' });
                    if (entryElement) {
                        if (entryElement._tiktokRetryTimer) {
                            clearInterval(entryElement._tiktokRetryTimer);
                            entryElement._tiktokRetryTimer = null;
                        }
                        const endAt = Date.now() + (data.nextAttemptIn || 0);
                        const attemptInfo = (data.attempt ? ` (attempt ${data.attempt}${data.maxAttempts ? '/' + data.maxAttempts : ''})` : '');
                        const baseMsg = data.reason ? `Connection error: ${data.reason}` : 'Connection failed';
                        const update = () => {
                            const remainingMs = Math.max(0, endAt - Date.now());
                            const secs = Math.ceil(remainingMs / 1000);
                            const msg = (data.nextAttemptIn ? `${baseMsg} - retrying in ${secs}s...${attemptInfo}` : `${baseMsg} - retrying...${attemptInfo}`);
                            updateConnectionStatus(entryElement, 'retry', msg);
                            if (remainingMs <= 0) {
                                clearInterval(entryElement._tiktokRetryTimer);
                                entryElement._tiktokRetryTimer = null;
                            }
                        };
                        update();
                        if (data.nextAttemptIn && data.nextAttemptIn > 0) {
                            entryElement._tiktokRetryTimer = setInterval(update, 1000);
                        }
                        entryElement._tiktokRetryEndAt = endAt;
                        entryElement._tiktokRetryAttempt = data.attempt || null;
                        entryElement._tiktokRetryMax = data.maxAttempts || null;
                        setConnectingStopUI();
                    }
                    break;
                case 'stopped_by_user':
                    stateManager.updateSource(sourceId, { status: 'inactive', vid: null, wssId: null, activeConnectionMode: null });
                    if (entryElement) {
                        updateConnectionStatus(entryElement, 'stopped', 'Connection stopped by user.');
                        entryElement._tiktokFallback = null;
                    }
                    restoreActivateUI();
                    break;
            }

            if (data.status === 'fatal_error' || data.status === 'stopped_by_user') {
                pendingTikTokStatusQueue.delete(data.wssID);
            }
        }

        ipcRenderer.on('tiktokConnectionStatus', (event, data) => {
            if (!data || typeof data.wssID !== 'number') return;
            const source = stateManager.getSources({ wssId: data.wssID })[0];
            if (!source) {
                enqueuePendingTikTokStatus(data);
                return;
            }

            drainPendingTikTokStatuses(data.wssID, source.id);
            applyTikTokStatusUpdate(data, source.id);
        });
    } 
});

console.log('[Electron] Current user agent:', navigator.userAgent);
console.log('[Electron] Window.electron exists?', !!window.electron);
console.log('[Electron] Process exists?', typeof process !== 'undefined');

// Check multiple ways to detect Electron (now that we hide it from UA)
const isElectron = (navigator.userAgent.toLowerCase().indexOf('electron/') > -1) || 
                   (typeof process !== 'undefined' && process.versions && process.versions.electron) ||
                   (window && window.process && window.process.type) ||
                   (window.electron && window.electron.ipcRenderer) || // Check for our preload exposure
                   (typeof require !== 'undefined'); // Node integration check

if (isElectron || window.electron) {
	console.log('[Electron] Detected Electron environment');
	try {
		if (!ipcRenderer) {
			// First try window.electron (from contextBridge in preload)
			if (window.electron && window.electron.ipcRenderer) {
				console.log('[Electron] Using ipcRenderer from contextBridge');
				ipcRenderer = window.electron.ipcRenderer;
			} 
			// Then try require (only works if nodeIntegration is enabled)
			else if (typeof require !== 'undefined') {
				console.log('[Electron] Attempting to require electron.ipcRenderer');
				ipcRenderer = require('electron').ipcRenderer;
			} else {
				console.log('[Electron] No access to ipcRenderer - nodeIntegration disabled and no contextBridge');
			}
			console.log('[Electron] Successfully loaded ipcRenderer:', !!ipcRenderer);
		}
		if (ipcRenderer) { 
            window.prompt = function(title, val, message = "") {
				log("window.prompt");
                let options = {};
                if (typeof title === 'object' && title !== null) {
                    options = title;
                } else { 
                    options.title = title;
                    options.message = message || val || ""; 
                    if (typeof val !== 'undefined' && message === "") options.value = val; 
                }
				return ipcRenderer.sendSync('prompt', options);
			};
			window.alert = function(title, val) { 
				log("window.alert");
				return ipcRenderer.send('alert', { 
					title: title, 
					message: val || title 
				});
			};
        }
    } catch(e) { 
        console.error("[Electron] IPC setup failed:", e);
        console.error("[Electron] This usually means nodeIntegration is disabled");
    }
}

var sourceTemplate = document.getElementById("sourceTemplate");
var groupTemplate = document.getElementById("groupTemplate"); 
var youtubeStatusManager = null;
var streamSelector = null;
var cachedManifest = {}; 
var iframes = document.querySelectorAll('iframe');
Array.prototype.forEach.call(iframes, function(iframe) {
	iframe.onload = function() { this.classList.remove('loading'); };
});
const basePath = window.location.href.split('index.html')[0];
function sleep(ms) { 
    return new Promise((resolve) => { setTimeout(resolve, ms); });
}

async function loadManifest() {
	const manifestUrl = getManifestUrl(); 
	try {
		const response = await fetch(manifestUrl);
        if (!response.ok) {
            throw new Error(`Manifest fetch failed: ${response.status} ${response.statusText}`);
        }
		const data = await response.json();
		if (data) {
			cachedManifest[manifestUrl] = data; 
			log("Fetched and cached remote manifest", data.version);
			localStorage.setItem('cachedManifest', JSON.stringify(data)); 
			return data;
		}
	} catch (e) {
		console.error('Error loading manifest from network:', e, manifestUrl);
		const storedManifest = localStorage.getItem('cachedManifest');
		if (storedManifest) {
			try {
				const parsedManifest = JSON.parse(storedManifest);
                const tempManifestUrl = parsedManifest.url; 
                if (tempManifestUrl === manifestUrl || !tempManifestUrl) { 
    				log("Using cached manifest from local storage.", parsedManifest.version);
	    			return parsedManifest;
                } else {
                    console.warn("Cached manifest URL does not match current mode's expected URL. Discarding old cache.");
                }
			} catch (parseError) {
				console.error('Error parsing cached manifest:', parseError);
			}
		}
	}
	return null; 
}
function getManifestUrl() { 
	if (sourcemode) return sourcemode + "manifest.json";
	if (devmode) return "file:///C:/Users/steve/Code/social_stream/manifest.json";
	if (isBetaMode) return "https://socialstream.ninja/beta/manifest.json";
	return "https://socialstream.ninja/manifest.json";
}
async function initializeApplication() {
	let newconfig = await initializeConfig(); 
	if (!newconfig) {
		console.error("Failed to initialize configuration.");
        Toast.error("Config Error", "Critical configuration failed to load.");
		return false;
	}
	config = newconfig;
	setupIframeSource(); 

	let loadedManifest = await loadManifest();
	if (!loadedManifest) {
		Toast.warning("Manifest Warning", "Failed to load remote manifest. Using cached version if available.");
        const cached = localStorage.getItem('cachedManifest'); 
        try {
            if (cached) manifest = JSON.parse(cached);
            else manifest = { content_scripts: [] };
            if (!manifest.content_scripts) manifest.content_scripts = [];
        } catch { manifest = { content_scripts: [] }; }
	} else {
    	manifest = loadedManifest;
    }
	console.log(manifest)
	console.log(config);
	return true;
}
function setupIframeSource() { 
	const frame2 = document.getElementById("frame2");
    if (!frame2) return;
	let iframesrc = "";
	// Get the language code for the URL
	const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
	const langParam = `&ln=${langCode}`;
	
	// Check if we should show the editor view initially
	const viewParam = window.initialEditorView ? '&view=editor' : '';
	
	if (sourcemode) {
		 if (devmode) {
			document.getElementById("sources")?.classList.add("dev");
			iframesrc = `${sourcemode}background.html?sourcemode=${encodeURIComponent(sourcemode)}&devmode&ssapp=2${localServer}${langParam}${viewParam}`;
		 } else {
			iframesrc = `${sourcemode}background.html?sourcemode=${encodeURIComponent(sourcemode)}&ssapp=2${localServer}${langParam}${viewParam}`;
		}
	} else if (devmode) {
		document.getElementById("sources")?.classList.add("dev");
		iframesrc = `file:///C:/Users/steve/Code/social_stream/background.html?devmode&ssapp=2${localServer}${langParam}${viewParam}`;
	} else if (isBetaMode) {
		iframesrc = `https://socialstream.ninja/beta/background.html?v=2&ssapp=2${localServer}${langParam}${viewParam}`;
	} else {
		iframesrc = `https://socialstream.ninja/background.html?v=2&ssapp=2${localServer}${langParam}${viewParam}`;
	}

	if (!frame2.src || (iframesrc !== frame2.src)) {
		frame2.src = iframesrc;
        frame2.classList.add('loading');
	}
}
async function checkForUpdates() { 
    try {
		const response = await fetch('https://api.github.com/repos/steveseguin/social_stream/releases');
		const data = await response.json();
		// Find the latest non-prerelease version
		const latestRelease = data.find(release => !release.prerelease);
		if (latestRelease?.tag_name && ipcRenderer) {
			const currentVersion = await ipcRenderer.sendSync('getVersion'); 
			if (currentVersion && compareVersions(currentVersion, latestRelease.tag_name) === -1) { 
				const newver = document.getElementById("newver");
                if (newver) { 
    				newver.classList.remove("hidden");
	    			document.getElementById("downloadlink").href = `https://github.com/steveseguin/social_stream/releases/tag/${latestRelease.tag_name}`;
		    		newver.innerHTML = `<h1>NEW VERSION AVAILABLE</h1> <a id="downloadlink" href="https://github.com/steveseguin/social_stream/releases/tag/${latestRelease.tag_name}" target="_blank">Download new version here</a> <b>v${latestRelease.tag_name}</b> (installed: v${currentVersion})`;
                }
			}
		}
	} catch (e) {
		console.error('Error checking for updates:', e);
	}
}

// Session Management Functions
async function loadSessions() {
	try {
		const { sessions, currentSession } = await ipcRenderer.invoke('getSessions');
		
		// Update current session display
		const currentSessionElement = document.getElementById('current-session-name');
		if (currentSessionElement && sessions[currentSession]) {
			currentSessionElement.textContent = sessions[currentSession].name;
		}
		
		// Populate sessions list
		const container = document.getElementById('sessions-list-container');
		if (!container) return;
		
		container.innerHTML = '';
		
		Object.entries(sessions).forEach(([id, session]) => {
			const sessionEl = document.createElement('div');
			sessionEl.className = 'session-item';
			if (id === currentSession) {
				sessionEl.classList.add('current');
			}
			
			sessionEl.innerHTML = `
				<div class="session-info">
					<h4 class="session-name">${session.name}</h4>
					${session.description ? `<p class="session-description">${session.description}</p>` : ''}
					<span class="session-date">Created: ${new Date(session.created).toLocaleDateString()}</span>
				</div>
				<div class="session-actions">
					${id !== currentSession ? `<button onclick="switchToSession('${id}')" class="switch-btn"><i class="las la-sign-in-alt"></i> Switch</button>` : '<span class="active-label">Active</span>'}
					${id !== 'default' ? `
						<button onclick="renameSession('${id}')" class="rename-btn"><i class="las la-edit"></i></button>
						<button onclick="deleteSession('${id}')" class="delete-btn"><i class="las la-trash"></i></button>
					` : '<span class="default-label">Original Data</span>'}
				</div>
			`;
			
			container.appendChild(sessionEl);
		});
	} catch (e) {
		console.error('Error loading sessions:', e);
	}
}

async function createNewSession() {
	const name = prompt('Enter a name for the new session:');
	if (!name) return;
	
	const description = prompt('Enter a description (optional):', 'A fresh start with no sources or settings');
	
	try {
		const result = await ipcRenderer.invoke('createSession', { name, description });
		if (result.success) {
			const switchNow = confirm('Session created! Do you want to switch to it now?\n\nNote: This will restart the application.');
			if (switchNow) {
				await switchToSession(result.sessionId);
			} else {
				loadSessions();
			}
		}
	} catch (e) {
		console.error('Error creating session:', e);
		alert('Failed to create session');
	}
}

async function switchToSession(sessionId) {
	const confirmSwitch = confirm('Switching sessions will restart the application. Continue?');
	if (!confirmSwitch) return;
	
	try {
		await ipcRenderer.invoke('switchSession', sessionId);
	} catch (e) {
		console.error('Error switching session:', e);
		alert('Failed to switch session');
	}
}

async function deleteSession(sessionId) {
	const confirmDelete = confirm('Are you sure you want to delete this session? This cannot be undone.');
	if (!confirmDelete) return;
	
	try {
		const result = await ipcRenderer.invoke('deleteSession', sessionId);
		if (result.success) {
			loadSessions();
		} else {
			alert(result.message || 'Failed to delete session');
		}
	} catch (e) {
		console.error('Error deleting session:', e);
		alert('Failed to delete session');
	}
}

async function renameSession(sessionId) {
	const currentName = document.querySelector(`[onclick="renameSession('${sessionId}')"]`)
		?.closest('.session-item')?.querySelector('.session-name')?.textContent;
	
	const newName = prompt('Enter new name:', currentName);
	if (!newName || newName === currentName) return;
	
	try {
		const result = await ipcRenderer.invoke('renameSession', sessionId, newName);
		if (result.success) {
			loadSessions();
		} else {
			alert(result.message || 'Failed to rename session');
		}
	} catch (e) {
		console.error('Error renaming session:', e);
		alert('Failed to rename session');
	}
}

async function exportCurrentSession() {
	try {
		// Show loading indicator
		Toast.info('Exporting...', 'Gathering all session data from all windows...');
		
		// Get current session data
		const { sessions, currentSession } = await ipcRenderer.invoke('getSessions');
		const sessionData = sessions[currentSession];
		
		if (!sessionData) {
			Toast.error('Export Failed', 'No current session found');
			return;
		}
		
		// Get ALL session data including cookies from all windows/partitions
		const allSessionDataResult = await ipcRenderer.invoke('exportAllSessionData');
		
		if (!allSessionDataResult.success) {
			throw new Error(allSessionDataResult.error || 'Failed to export session data');
		}
		
		// Combine with current window's localStorage data
		const exportData = {
			sessionInfo: {
				name: sessionData.name,
				description: sessionData.description,
				createdAt: sessionData.createdAt,
				exportedAt: new Date().toISOString(),
				currentSessionId: currentSession
			},
			// Include all session data from all windows/partitions
			allSessions: allSessionDataResult.data,
			// Include current window's localStorage as well
			mainWindowLocalStorage: {
				socialStreamState: localStorage.getItem('socialStreamState'),
				settings: localStorage.getItem('settings'),
				betaMode: localStorage.getItem('betaMode'),
				youtubeAutoAdd: localStorage.getItem('youtubeAutoAdd'),
				youtubeAutoCleanup: localStorage.getItem('youtubeAutoCleanup'),
				youtubeCheckInterval: localStorage.getItem('youtubeCheckInterval'),
				cachedManifest: localStorage.getItem('cachedManifest'),
				config: localStorage.getItem('config'),
				language: localStorage.getItem('language')
			},
			version: '2.0'
		};
		
		// Create a blob and download it
		const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = `session-${sessionData.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}-complete.json`;
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);
		
		// Show summary
		const sessionCount = Object.keys(allSessionDataResult.data.sessions).length;
		Toast.success('Export Complete', `Exported "${sessionData.name}" with data from ${sessionCount} windows/partitions`);
	} catch (e) {
		console.error('Error exporting session:', e);
		Toast.error('Export Failed', 'Failed to export session: ' + e.message);
	}
}

async function importSession() {
	try {
		// Create file input
		const input = document.createElement('input');
		input.type = 'file';
		input.accept = '.json';
		
		input.onchange = async (event) => {
			const file = event.target.files[0];
			if (!file) return;
			
			try {
				const content = await file.text();
				const importData = JSON.parse(content);
				
				// Validate the import data - support both old and new formats
				if (!importData.version || !importData.sessionInfo) {
					throw new Error('Invalid session file format');
				}
				
				// Check if this is the new format with all session data
				const isNewFormat = importData.version === '2.0' && importData.allSessions;
				
				// Prompt for session name
				const name = prompt('Enter a name for the imported session:', importData.sessionInfo.name || 'Imported Session');
				if (!name) return;
				
				const description = prompt('Enter a description (optional):', 
					importData.sessionInfo.description || `Imported from ${importData.sessionInfo.name} on ${new Date().toLocaleDateString()}`);
				
				// Create new session
				const result = await ipcRenderer.invoke('createSession', { name, description });
				if (!result.success) {
					throw new Error(result.error || 'Failed to create session');
				}
				
				// Ask if they want to switch to the imported session
				const switchNow = confirm('Session imported! Do you want to switch to it now?\n\nNote: This will restart the application and load the imported data.');
				
				if (switchNow) {
					if (isNewFormat) {
						// New format: Import all session data including cookies
						Toast.info('Importing...', 'Restoring all session data including cookies...');
						
						// Import all the session data (cookies, etc)
						const importResult = await ipcRenderer.invoke('importAllSessionData', importData.allSessions);
						
						if (!importResult.success) {
							throw new Error(importResult.error || 'Failed to import session data');
						}
						
						// Store the main window localStorage data
						localStorage.setItem('pendingImport', JSON.stringify(importData.mainWindowLocalStorage));
						
						// Store the full session data for window restoration
						await ipcRenderer.invoke('store-set', 'pendingSessionImport', importData.allSessions);
						
						const summary = `Imported ${importResult.results.totalSessions} sessions with ${importResult.results.totalCookies} cookies`;
						Toast.success('Import Progress', summary);
					} else {
						// Old format: Only localStorage
						localStorage.setItem('pendingImport', JSON.stringify(importData.localStorage));
					}
					
					// Switch to the new session
					await ipcRenderer.invoke('switchSession', result.sessionId);
				} else {
					if (isNewFormat) {
						// Import session data without switching
						Toast.info('Importing...', 'Restoring session data...');
						const importResult = await ipcRenderer.invoke('importAllSessionData', importData.allSessions);
						
						if (importResult.success) {
							const summary = `Imported ${importResult.results.totalSessions} sessions with ${importResult.results.totalCookies} cookies`;
							Toast.success('Import Complete', `Session "${name}" imported. ${summary}`);
						} else {
							Toast.warning('Partial Import', `Session "${name}" created but some data could not be imported`);
						}
					} else {
						Toast.success('Import Complete', `Session "${name}" imported successfully. You can switch to it later.`);
					}
					await loadSessions();
				}
				
			} catch (e) {
				console.error('Error processing import file:', e);
				Toast.error('Import Failed', 'Failed to import session: ' + e.message);
			}
		};
		
		input.click();
	} catch (e) {
		console.error('Error importing session:', e);
		Toast.error('Import Failed', 'Failed to import session');
	}
}

// Navigation handling
function showPage(pageName) {
	// Hide all pages
	const pages = document.querySelectorAll('#content-pane > div');
	pages.forEach(page => {
		page.style.display = 'none';
	});
	
	// Show the selected page
	const selectedPage = document.getElementById(pageName + '-page');
	if (selectedPage) {
		selectedPage.style.display = 'block';
		
		// Check if this page needs an iframe and create/update it
		const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
		const existingIframe = selectedPage.querySelector('iframe');
		
		// Pages that should have iframes with socialstream.ninja content
		const iframePages = {
			'link-overlay': `https://socialstream.ninja/overlays/?ln=${langCode}`,
			'dashboard': `https://socialstream.ninja/dashboard/?ln=${langCode}`,
			'event-flow-editor': `https://socialstream.ninja/eventflow/?ln=${langCode}`,
			'vdo-ninja': `https://vdo.ninja/?ln=${langCode}`
		};
		
		if (iframePages[pageName]) {
			if (!existingIframe) {
				// Create iframe if it doesn't exist
				const iframe = document.createElement('iframe');
				iframe.style.width = '100%';
				iframe.style.height = '100%';
				iframe.style.border = 'none';
				iframe.src = iframePages[pageName];
				selectedPage.appendChild(iframe);
			} else {
				// Update existing iframe with language parameter
				try {
					if (existingIframe.src && existingIframe.src !== 'about:blank') {
						const url = new URL(existingIframe.src);
						url.searchParams.set('ln', langCode);
						if (existingIframe.src !== url.toString()) {
							existingIframe.src = url.toString();
						}
					}
				} catch (e) {
					console.error('Error updating iframe URL:', e);
					// If URL is invalid, just set the new URL
					existingIframe.src = iframePages[pageName];
				}
			}
		}
	}
	
	// Update active nav link
	const navLinks = document.querySelectorAll('#main-navigation a');
	navLinks.forEach(link => {
		link.classList.remove('active');
		if (link.getAttribute('data-page') === pageName) {
			link.classList.add('active');
		}
	});
	
	// Save current page to localStorage
	localStorage.setItem('currentPage', pageName);
	
	// Load sessions when sessions page is shown
	if (pageName === 'sessions') {
		loadSessions();
	}
}

// Translation system
const translations = {
	'en': {
		// Navigation
		'nav.streams': '🎭 Sources and Settings',
		'nav.linkoverlay': '🔗 Links and Settings',
		'nav.dashboard': '📰 Status and Logs',
		'nav.eventfloweditor': '🪤 Event Flow Editor',
		'nav.vdoninja': '🎦 Remote Camera Feed',
		'nav.sessions': '🧑‍🤝‍🧑 Sessions',
		
		// Buttons
		'btn.activate': '▶️ Activate source',
		'btn.signin': '🔑 Sign-in',
		'btn.help': '❓ Help!',
		'btn.stop': '⏹️ Stop',
		'btn.reload': '🔄 Reload',
		'btn.visible': '👁️ Visible',
		'btn.hidden': '🙈 Hidden',
		'btn.muted': '🔇 Muted',
		'btn.unmuted': '🔊 Volume',
		
		// Settings menu
		'settings.title': 'Additional settings for this source',
		'settings.header': 'Additional Controls',
		'settings.clear': '🧹 Clear cache & storage',
		'settings.remove': '🗑️ Remove source',
		
		// Sessions
		'sessions.title': 'User Sessions',
		'sessions.info': 'Manage multiple user profiles with separate settings and sources.',
		'sessions.current': 'Current Session',
		'sessions.available': 'Available Sessions',
		'sessions.create': '➕ Create New Session',
		'sessions.export': '💾 Export Current Session',
			'sessions.import': '📂 Import Session',
			'sessions.switch': 'Switch',
			'sessions.active': 'Active',
			
			// Global
			
			// Sources
			'source.add': 'Add a new source:',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Auto-activate',
		'source.youtube.username': 'YouTube Username',
		'source.youtube.videoid': 'YouTube Video ID',
		'source.twitch': 'Twitch Username',
		'source.kick': 'Kick Username',
		'source.instagram': 'Instagram Username',
		'source.facebook': 'Facebook Username',
		'source.tiktok': 'TikTok Username',
		'source.other': 'Other chat sites',
		
		// App info
		'app.title': 'Social Stream Ninja Standalone',
		'app.newversion': 'NEW VERSION AVAILABLE',
		'app.download': 'Download new version here',
		
		// Groups
		'group.togglevisibility': 'Toggle All Streams Visibility',
		'group.togglemute': 'Toggle All Streams Mute',
		'group.stopall': 'Stop All Streams',
		'group.reloadall': 'Reload All Streams',
		'group.remove': '🗑️ Remove group & its sources',
	},
	
	'pt-BR': {
		// Navigation
		'nav.streams': '🎭 Fontes e Configurações',
		'nav.linkoverlay': '🔗 Links e Configurações',
		'nav.dashboard': '📰 Status e Logs',
		'nav.eventfloweditor': '🪤 Editor de Fluxo de Eventos',
		'nav.vdoninja': '🎦 Feed de Câmera Remota',
		'nav.sessions': '🧑‍🤝‍🧑 Sessões',
		
		// Buttons
		'btn.activate': '▶️ Ativar fonte',
		'btn.signin': '🔑 Entrar',
		'btn.help': '❓ Ajuda!',
		'btn.stop': '⏹️ Parar',
		'btn.reload': '🔄 Recarregar',
		'btn.visible': '👁️ Visível',
		'btn.hidden': '🙈 Oculto',
		'btn.muted': '🔇 Mudo',
		'btn.unmuted': '🔊 Som',
		
		// Settings menu
		'settings.title': 'Configurações adicionais para esta fonte',
		'settings.header': 'Controles Adicionais',
		'settings.clear': '🧹 Limpar cache e armazenamento',
		'settings.remove': '🗑️ Remover fonte',
		
		// Sessions
		'sessions.title': 'Sessões de Usuário',
		'sessions.info': 'Gerencie múltiplos perfis de usuário com configurações e fontes separadas.',
			'sessions.current': 'Sessão Atual',
			'sessions.available': 'Sessões Disponíveis',
			'sessions.create': '➕ Criar Nova Sessão',
			'sessions.switch': 'Alternar',
			'sessions.active': 'Ativa',
			
			// Global
			
			// Sources
		'source.add': 'Adicionar nova fonte:',
		'source.mode.standard': '📄 Padrão',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Ativar automaticamente',
		'source.youtube.username': 'Nome de usuário do YouTube',
		'source.youtube.videoid': 'ID do vídeo do YouTube',
		'source.twitch': 'Nome de usuário do Twitch',
		'source.kick': 'Nome de usuário do Kick',
		'source.instagram': 'Nome de usuário do Instagram',
		'source.facebook': 'Nome de usuário do Facebook',
		'source.tiktok': 'Nome de usuário do TikTok',
		'source.other': 'Outros sites de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autônomo',
		'app.newversion': 'NOVA VERSÃO DISPONÍVEL',
		'app.download': 'Baixe a nova versão aqui',
		
		// Groups
		'group.togglevisibility': 'Alternar Visibilidade de Todas as Transmissões',
		'group.togglemute': 'Alternar Som de Todas as Transmissões',
		'group.stopall': 'Parar Todas as Transmissões',
		'group.reloadall': 'Recarregar Todas as Transmissões',
		'group.remove': '🗑️ Remover grupo e suas fontes',
	},
	
	'es': {
		// Navigation
		'nav.streams': '🎭 Fuentes y Configuración',
		'nav.linkoverlay': '🔗 Enlaces y Configuración',
		'nav.dashboard': '📰 Estado y Registros',
		'nav.eventfloweditor': '🪤 Editor de Flujo de Eventos',
		'nav.vdoninja': '🎦 Transmisión de Cámara Remota',
		'nav.sessions': '🧑‍🤝‍🧑 Sesiones',
		
		// Buttons
		'btn.activate': '▶️ Activar fuente',
		'btn.signin': '🔑 Iniciar sesión',
		'btn.help': '❓ ¡Ayuda!',
		'btn.stop': '⏹️ Detener',
		'btn.reload': '🔄 Recargar',
		'btn.visible': '👁️ Visible',
		'btn.hidden': '🙈 Oculto',
		'btn.muted': '🔇 Silenciado',
		'btn.unmuted': '🔊 Sonido',
		
		// Settings menu
		'settings.title': 'Configuración adicional para esta fuente',
		'settings.header': 'Controles Adicionales',
		'settings.clear': '🧹 Limpiar caché y almacenamiento',
		'settings.remove': '🗑️ Eliminar fuente',
		
		// Sessions
		'sessions.title': 'Sesiones de Usuario',
		'sessions.info': 'Gestione múltiples perfiles de usuario con configuraciones y fuentes separadas.',
		'sessions.current': 'Sesión Actual',
		'sessions.available': 'Sesiones Disponibles',
			'sessions.create': '➕ Crear Nueva Sesión',
			'sessions.switch': 'Cambiar',
			'sessions.active': 'Activa',
			
			// Global
			
			// Sources
		'source.add': 'Añadir nueva fuente',
		'source.mode.standard': '📄 Estándar',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Activar automáticamente',
		'source.youtube.username': 'Nombre de usuario de YouTube',
		'source.youtube.videoid': 'ID de video de YouTube',
		'source.twitch': 'Nombre de usuario de Twitch',
		'source.kick': 'Nombre de usuario de Kick',
		'source.instagram': 'Nombre de usuario de Instagram',
		'source.facebook': 'Nombre de usuario de Facebook',
		'source.tiktok': 'Nombre de usuario de TikTok',
		'source.other': 'Otros sitios de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Independiente',
		'app.newversion': 'NUEVA VERSIÓN DISPONIBLE',
		'app.download': 'Descarga la nueva versión aquí',
		
		// Groups
		'group.togglevisibility': 'Alternar Visibilidad de Todas las Transmisiones',
		'group.togglemute': 'Alternar Sonido de Todas las Transmisiones',
		'group.stopall': 'Detener Todas las Transmisiones',
		'group.reloadall': 'Recargar Todas las Transmisiones',
		'group.remove': '🗑️ Eliminar grupo y sus fuentes',
	},
	
	'cs': {
		// Navigation
		'nav.streams': '🎭 Zdroje a nastavení',
		'nav.linkoverlay': '🔗 Odkazy a nastavení',
		'nav.dashboard': '📰 Stav a protokoly',
		'nav.eventfloweditor': '🪤 Editor toku událostí',
		'nav.vdoninja': '🎦 Vzdálený kamerový přenos',
		'nav.sessions': '🧑‍🤝‍🧑 Relace',
		
		// Buttons
		'btn.activate': '▶️ Aktivovat zdroj',
		'btn.signin': '🔑 Přihlásit se',
		'btn.help': '❓ Nápověda!',
		'btn.stop': '⏹️ Zastavit',
		'btn.reload': '🔄 Znovu načíst',
		'btn.visible': '👁️ Viditelné',
		'btn.hidden': '🙈 Skryté',
		'btn.muted': '🔇 Ztlumeno',
		'btn.unmuted': '🔊 Zvuk',
		
		// Settings menu
		'settings.title': 'Další nastavení pro tento zdroj',
		'settings.header': 'Další ovládací prvky',
		'settings.clear': '🧹 Vymazat mezipaměť a úložiště',
		'settings.remove': '🗑️ Odebrat zdroj',
		
		// Sessions
		'sessions.title': 'Uživatelské relace',
		'sessions.info': 'Spravujte více uživatelských profilů s odděleným nastavením a zdroji.',
		'sessions.current': 'Aktuální relace',
		'sessions.available': 'Dostupné relace',
		'sessions.create': '➕ Vytvořit novou relaci',
		'sessions.export': '💾 Exportovat aktuální relaci',
			'sessions.import': '📂 Importovat relaci',
			'sessions.switch': 'Přepnout',
			'sessions.active': 'Aktivní',
			
			// Global
			
			// Sources
		'source.add': 'Přidat nový zdroj:',
		'source.mode.standard': '📄 Standardní',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Automaticky aktivovat',
		'source.youtube.username': 'Uživatelské jméno YouTube',
		'source.youtube.videoid': 'ID videa YouTube',
		'source.twitch': 'Uživatelské jméno Twitch',
		'source.kick': 'Uživatelské jméno Kick',
		'source.instagram': 'Uživatelské jméno Instagram',
		'source.facebook': 'Uživatelské jméno Facebook',
		'source.tiktok': 'Uživatelské jméno TikTok',
		'source.other': 'Další chatovací stránky',
		
		// App info
		'app.title': 'Social Stream Ninja Samostatná aplikace',
		'app.newversion': 'JE K DISPOZICI NOVÁ VERZE',
		'app.download': 'Stáhnout novou verzi zde',
		
		// Groups
		'group.togglevisibility': 'Přepnout viditelnost všech streamů',
		'group.togglemute': 'Přepnout ztlumení všech streamů',
		'group.stopall': 'Zastavit všechny streamy',
		'group.reloadall': 'Znovu načíst všechny streamy',
		'group.remove': '🗑️ Odebrat skupinu a její zdroje',
	},
	
	'fr': {
		// Navigation
		'nav.streams': '🎭 Sources et Paramètres',
		'nav.linkoverlay': '🔗 Liens et Paramètres',
		'nav.dashboard': '📰 État et Journaux',
		'nav.eventfloweditor': '🪤 Éditeur de Flux d\'Événements',
		'nav.vdoninja': '🎦 Flux de Caméra à Distance',
		'nav.sessions': '🧑‍🤝‍🧑 Sessions',
		
		// Buttons
		'btn.activate': '▶️ Activer la source',
		'btn.signin': '🔑 Se connecter',
		'btn.help': '❓ Aide!',
		'btn.stop': '⏹️ Arrêter',
		'btn.reload': '🔄 Recharger',
		'btn.visible': '👁️ Visible',
		'btn.hidden': '🙈 Caché',
		'btn.muted': '🔇 Muet',
		'btn.unmuted': '🔊 Son',
		
		// Settings menu
		'settings.title': 'Paramètres supplémentaires pour cette source',
		'settings.header': 'Contrôles Supplémentaires',
		'settings.clear': '🧹 Effacer le cache et le stockage',
		'settings.remove': '🗑️ Supprimer la source',
		
		// Sessions
		'sessions.title': 'Sessions Utilisateur',
		'sessions.info': 'Gérez plusieurs profils utilisateur avec des paramètres et sources séparés.',
		'sessions.current': 'Session Actuelle',
		'sessions.available': 'Sessions Disponibles',
			'sessions.create': '➕ Créer une Nouvelle Session',
			'sessions.switch': 'Changer',
			'sessions.active': 'Active',
			
			// Global
			
			// Sources
		'source.add': 'Ajouter une nouvelle source',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Activation automatique',
		'source.youtube.username': 'Nom d\'utilisateur YouTube',
		'source.youtube.videoid': 'ID de vidéo YouTube',
		'source.twitch': 'Nom d\'utilisateur Twitch',
		'source.kick': 'Nom d\'utilisateur Kick',
		'source.instagram': 'Nom d\'utilisateur Instagram',
		'source.facebook': 'Nom d\'utilisateur Facebook',
		'source.tiktok': 'Nom d\'utilisateur TikTok',
		'source.other': 'Autres sites de chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autonome',
		'app.newversion': 'NOUVELLE VERSION DISPONIBLE',
		'app.download': 'Téléchargez la nouvelle version ici',
		
		// Groups
		'group.togglevisibility': 'Basculer la Visibilité de Tous les Flux',
		'group.togglemute': 'Basculer le Son de Tous les Flux',
		'group.stopall': 'Arrêter Tous les Flux',
		'group.reloadall': 'Recharger Tous les Flux',
		'group.remove': '🗑️ Supprimer le groupe et ses sources',
	},
	
	'de': {
		// Navigation
		'nav.streams': '🎭 Quellen und Einstellungen',
		'nav.linkoverlay': '🔗 Links und Einstellungen',
		'nav.dashboard': '📰 Status und Protokolle',
		'nav.eventfloweditor': '🪤 Ereignisfluss-Editor',
		'nav.vdoninja': '🎦 Remote-Kamera-Feed',
		'nav.sessions': '🧑‍🤝‍🧑 Sitzungen',
		
		// Buttons
		'btn.activate': '▶️ Quelle aktivieren',
		'btn.signin': '🔑 Anmelden',
		'btn.help': '❓ Hilfe!',
		'btn.stop': '⏹️ Stoppen',
		'btn.reload': '🔄 Neu laden',
		'btn.visible': '👁️ Sichtbar',
		'btn.hidden': '🙈 Versteckt',
		'btn.muted': '🔇 Stumm',
		'btn.unmuted': '🔊 Ton',
		
		// Settings menu
		'settings.title': 'Zusätzliche Einstellungen für diese Quelle',
		'settings.header': 'Zusätzliche Steuerungen',
		'settings.clear': '🧹 Cache und Speicher löschen',
		'settings.remove': '🗑️ Quelle entfernen',
		
		// Sessions
		'sessions.title': 'Benutzersitzungen',
		'sessions.info': 'Verwalten Sie mehrere Benutzerprofile mit separaten Einstellungen und Quellen.',
		'sessions.current': 'Aktuelle Sitzung',
		'sessions.available': 'Verfügbare Sitzungen',
			'sessions.create': '➕ Neue Sitzung erstellen',
			'sessions.switch': 'Wechseln',
			'sessions.active': 'Aktiv',
			
			// Global
			
			// Sources
		'source.add': 'Neue Quelle hinzufügen',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Automatisch aktivieren',
		'source.youtube.username': 'YouTube-Benutzername',
		'source.youtube.videoid': 'YouTube-Video-ID',
		'source.twitch': 'Twitch-Benutzername',
		'source.kick': 'Kick-Benutzername',
		'source.instagram': 'Instagram-Benutzername',
		'source.facebook': 'Facebook-Benutzername',
		'source.tiktok': 'TikTok-Benutzername',
		'source.other': 'Andere Chat-Seiten',
		
		// App info
		'app.title': 'Social Stream Ninja Eigenständig',
		'app.newversion': 'NEUE VERSION VERFÜGBAR',
		'app.download': 'Neue Version hier herunterladen',
		
		// Groups
		'group.togglevisibility': 'Sichtbarkeit aller Streams umschalten',
		'group.togglemute': 'Ton aller Streams umschalten',
		'group.stopall': 'Alle Streams stoppen',
		'group.reloadall': 'Alle Streams neu laden',
		'group.remove': '🗑️ Gruppe und ihre Quellen entfernen',
	},
	
	'it': {
		// Navigation
		'nav.streams': '🎭 Fonti e Impostazioni',
		'nav.linkoverlay': '🔗 Collegamenti e Impostazioni',
		'nav.dashboard': '📰 Stato e Registri',
		'nav.eventfloweditor': '🪤 Editor di Flusso Eventi',
		'nav.vdoninja': '🎦 Feed Telecamera Remota',
		'nav.sessions': '🧑‍🤝‍🧑 Sessioni',
		
		// Buttons
		'btn.activate': '▶️ Attiva fonte',
		'btn.signin': '🔑 Accedi',
		'btn.help': '❓ Aiuto!',
		'btn.stop': '⏹️ Ferma',
		'btn.reload': '🔄 Ricarica',
		'btn.visible': '👁️ Visibile',
		'btn.hidden': '🙈 Nascosto',
		'btn.muted': '🔇 Muto',
		'btn.unmuted': '🔊 Audio',
		
		// Settings menu
		'settings.title': 'Impostazioni aggiuntive per questa fonte',
		'settings.header': 'Controlli Aggiuntivi',
		'settings.clear': '🧹 Cancella cache e archiviazione',
		'settings.remove': '🗑️ Rimuovi fonte',
		
		// Sessions
		'sessions.title': 'Sessioni Utente',
		'sessions.info': 'Gestisci più profili utente con impostazioni e fonti separate.',
		'sessions.current': 'Sessione Corrente',
		'sessions.available': 'Sessioni Disponibili',
		'sessions.create': '➕ Crea Nuova Sessione',
			'sessions.switch': 'Cambia',
			'sessions.active': 'Attiva',
			
			// Global
			
			// Sources
		'source.add': 'Aggiungi nuova fonte',
		'source.mode.standard': '📄 Standard',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Attivazione automatica',
		'source.youtube.username': 'Nome utente YouTube',
		'source.youtube.videoid': 'ID video YouTube',
		'source.twitch': 'Nome utente Twitch',
		'source.kick': 'Nome utente Kick',
		'source.instagram': 'Nome utente Instagram',
		'source.facebook': 'Nome utente Facebook',
		'source.tiktok': 'Nome utente TikTok',
		'source.other': 'Altri siti di chat',
		
		// App info
		'app.title': 'Social Stream Ninja Autonomo',
		'app.newversion': 'NUOVA VERSIONE DISPONIBILE',
		'app.download': 'Scarica la nuova versione qui',
		
		// Groups
		'group.togglevisibility': 'Attiva/Disattiva Visibilità di Tutti i Flussi',
		'group.togglemute': 'Attiva/Disattiva Audio di Tutti i Flussi',
		'group.stopall': 'Ferma Tutti i Flussi',
		'group.reloadall': 'Ricarica Tutti i Flussi',
		'group.remove': '🗑️ Rimuovi gruppo e le sue fonti',
	},
	
	'ja': {
		// Navigation
		'nav.streams': '🎭 ソースと設定',
		'nav.linkoverlay': '🔗 リンクと設定',
		'nav.dashboard': '📰 ステータスとログ',
		'nav.eventfloweditor': '🪤 イベントフローエディター',
		'nav.vdoninja': '🎦 リモートカメラフィード',
		'nav.sessions': '🧑‍🤝‍🧑 セッション',
		
		// Buttons
		'btn.activate': '▶️ ソースを有効化',
		'btn.signin': '🔑 サインイン',
		'btn.help': '❓ ヘルプ！',
		'btn.stop': '⏹️ 停止',
		'btn.reload': '🔄 リロード',
		'btn.visible': '👁️ 表示',
		'btn.hidden': '🙈 非表示',
		'btn.muted': '🔇 ミュート',
		'btn.unmuted': '🔊 音声',
		
		// Settings menu
		'settings.title': 'このソースの追加設定',
		'settings.header': '追加コントロール',
		'settings.clear': '🧹 キャッシュとストレージをクリア',
		'settings.remove': '🗑️ ソースを削除',
		
		// Sessions
		'sessions.title': 'ユーザーセッション',
		'sessions.info': '別々の設定とソースで複数のユーザープロファイルを管理します。',
		'sessions.current': '現在のセッション',
		'sessions.available': '利用可能なセッション',
		'sessions.create': '➕ 新しいセッションを作成',
			'sessions.switch': '切り替え',
			'sessions.active': 'アクティブ',
			
			// Global
			
			// Sources
		'source.add': '新しいソースを追加',
		'source.mode.standard': '📄 スタンダード',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': '自動有効化',
		'source.youtube.username': 'YouTubeユーザー名',
		'source.youtube.videoid': 'YouTube動画ID',
		'source.twitch': 'Twitchユーザー名',
		'source.kick': 'Kickユーザー名',
		'source.instagram': 'Instagramユーザー名',
		'source.facebook': 'Facebookユーザー名',
		'source.tiktok': 'TikTokユーザー名',
		'source.other': 'その他のチャットサイト',
		
		// App info
		'app.title': 'Social Stream Ninja スタンドアロン',
		'app.newversion': '新しいバージョンが利用可能',
		'app.download': 'こちらから新バージョンをダウンロード',
		
		// Groups
		'group.togglevisibility': 'すべてのストリームの表示を切り替え',
		'group.togglemute': 'すべてのストリームのミュートを切り替え',
		'group.stopall': 'すべてのストリームを停止',
		'group.reloadall': 'すべてのストリームをリロード',
		'group.remove': '🗑️ グループとそのソースを削除',
	},
	
	'zh': {
		// Navigation
		'nav.streams': '🎭 来源和设置',
		'nav.linkoverlay': '🔗 链接和设置',
		'nav.dashboard': '📰 状态和日志',
		'nav.eventfloweditor': '🪤 事件流编辑器',
		'nav.vdoninja': '🎦 远程摄像头画面',
		'nav.sessions': '🧑‍🤝‍🧑 会话',
		
		// Buttons
		'btn.activate': '▶️ 激活来源',
		'btn.signin': '🔑 登录',
		'btn.help': '❓ 帮助！',
		'btn.stop': '⏹️ 停止',
		'btn.reload': '🔄 重新加载',
		'btn.visible': '👁️ 可见',
		'btn.hidden': '🙈 隐藏',
		'btn.muted': '🔇 静音',
		'btn.unmuted': '🔊 音量',
		
		// Settings menu
		'settings.title': '此来源的附加设置',
		'settings.header': '附加控制',
		'settings.clear': '🧹 清除缓存和存储',
		'settings.remove': '🗑️ 删除来源',
		
		// Sessions
		'sessions.title': '用户会话',
		'sessions.info': '使用单独的设置和来源管理多个用户配置文件。',
		'sessions.current': '当前会话',
		'sessions.available': '可用会话',
			'sessions.create': '➕ 创建新会话',
			'sessions.switch': '切换',
			'sessions.active': '活动',
			
			// Global
			
			// Sources
		'source.add': '添加新来源',
		'source.mode.standard': '📄 标准',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': '自动激活',
		'source.youtube.username': 'YouTube用户名',
		'source.youtube.videoid': 'YouTube视频ID',
		'source.twitch': 'Twitch用户名',
		'source.kick': 'Kick用户名',
		'source.instagram': 'Instagram用户名',
		'source.facebook': 'Facebook用户名',
		'source.tiktok': 'TikTok用户名',
		'source.other': '其他聊天网站',
		
		// App info
		'app.title': 'Social Stream Ninja 独立版',
		'app.newversion': '新版本可用',
		'app.download': '在此下载新版本',
		
		// Groups
		'group.togglevisibility': '切换所有流的可见性',
		'group.togglemute': '切换所有流的静音',
		'group.stopall': '停止所有流',
		'group.reloadall': '重新加载所有流',
		'group.remove': '🗑️ 删除组及其来源',
	},
	
	'ko': {
		// Navigation
		'nav.streams': '🎭 소스 및 설정',
		'nav.linkoverlay': '🔗 링크 및 설정',
		'nav.dashboard': '📰 상태 및 로그',
		'nav.eventfloweditor': '🪤 이벤트 플로우 편집기',
		'nav.vdoninja': '🎦 원격 카메라 피드',
		'nav.sessions': '🧑‍🤝‍🧑 세션',
		
		// Buttons
		'btn.activate': '▶️ 소스 활성화',
		'btn.signin': '🔑 로그인',
		'btn.help': '❓ 도움말!',
		'btn.stop': '⏹️ 중지',
		'btn.reload': '🔄 새로고침',
		'btn.visible': '👁️ 보이기',
		'btn.hidden': '🙈 숨기기',
		'btn.muted': '🔇 음소거',
		'btn.unmuted': '🔊 소리',
		
		// Settings menu
		'settings.title': '이 소스의 추가 설정',
		'settings.header': '추가 컨트롤',
		'settings.clear': '🧹 캐시 및 저장소 지우기',
		'settings.remove': '🗑️ 소스 제거',
		
		// Sessions
		'sessions.title': '사용자 세션',
		'sessions.info': '별도의 설정과 소스로 여러 사용자 프로필을 관리합니다.',
		'sessions.current': '현재 세션',
		'sessions.available': '사용 가능한 세션',
			'sessions.create': '➕ 새 세션 만들기',
			'sessions.switch': '전환',
			'sessions.active': '활성',
			
			// Global
			
			// Sources
		'source.add': '새 소스 추가',
		'source.mode.standard': '📄 표준',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': '자동 활성화',
		'source.youtube.username': 'YouTube 사용자명',
		'source.youtube.videoid': 'YouTube 동영상 ID',
		'source.twitch': 'Twitch 사용자명',
		'source.kick': 'Kick 사용자명',
		'source.instagram': 'Instagram 사용자명',
		'source.facebook': 'Facebook 사용자명',
		'source.tiktok': 'TikTok 사용자명',
		'source.other': '기타 채팅 사이트',
		
		// App info
		'app.title': 'Social Stream Ninja 독립형',
		'app.newversion': '새 버전 사용 가능',
		'app.download': '여기서 새 버전 다운로드',
		
		// Groups
		'group.togglevisibility': '모든 스트림 표시 전환',
		'group.togglemute': '모든 스트림 음소거 전환',
		'group.stopall': '모든 스트림 중지',
		'group.reloadall': '모든 스트림 새로고침',
		'group.remove': '🗑️ 그룹 및 소스 제거',
	},
	
	'ru': {
		// Navigation
		'nav.streams': '🎭 Источники и настройки',
		'nav.linkoverlay': '🔗 Ссылки и настройки',
		'nav.dashboard': '📰 Статус и журналы',
		'nav.eventfloweditor': '🪤 Редактор потока событий',
		'nav.vdoninja': '🎦 Удаленная трансляция камеры',
		'nav.sessions': '🧑‍🤝‍🧑 Сессии',
		
		// Buttons
		'btn.activate': '▶️ Активировать источник',
		'btn.signin': '🔑 Войти',
		'btn.help': '❓ Помощь!',
		'btn.stop': '⏹️ Остановить',
		'btn.reload': '🔄 Перезагрузить',
		'btn.visible': '👁️ Видимый',
		'btn.hidden': '🙈 Скрытый',
		'btn.muted': '🔇 Без звука',
		'btn.unmuted': '🔊 Звук',
		
		// Settings menu
		'settings.title': 'Дополнительные настройки для этого источника',
		'settings.header': 'Дополнительные элементы управления',
		'settings.clear': '🧹 Очистить кэш и хранилище',
		'settings.remove': '🗑️ Удалить источник',
		
		// Sessions
		'sessions.title': 'Пользовательские сессии',
		'sessions.info': 'Управляйте несколькими профилями пользователей с отдельными настройками и источниками.',
		'sessions.current': 'Текущая сессия',
		'sessions.available': 'Доступные сессии',
		'sessions.create': '➕ Создать новую сессию',
			'sessions.switch': 'Переключить',
			'sessions.active': 'Активная',
			
			// Global
			
			// Sources
		'source.add': 'Добавить новый источник',
		'source.mode.standard': '📄 Стандартный',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Автоактивация',
		'source.youtube.username': 'Имя пользователя YouTube',
		'source.youtube.videoid': 'ID видео YouTube',
		'source.twitch': 'Имя пользователя Twitch',
		'source.kick': 'Имя пользователя Kick',
		'source.instagram': 'Имя пользователя Instagram',
		'source.facebook': 'Имя пользователя Facebook',
		'source.tiktok': 'Имя пользователя TikTok',
		'source.other': 'Другие чат-сайты',
		
		// App info
		'app.title': 'Social Stream Ninja Автономный',
		'app.newversion': 'ДОСТУПНА НОВАЯ ВЕРСИЯ',
		'app.download': 'Скачайте новую версию здесь',
		
		// Groups
		'group.togglevisibility': 'Переключить видимость всех потоков',
		'group.togglemute': 'Переключить звук всех потоков',
		'group.stopall': 'Остановить все потоки',
		'group.reloadall': 'Перезагрузить все потоки',
		'group.remove': '🗑️ Удалить группу и её источники',
	},
	
	'tr': {
		// Navigation
		'nav.streams': '🎭 Kaynaklar ve Ayarlar',
		'nav.linkoverlay': '🔗 Bağlantılar ve Ayarlar',
		'nav.dashboard': '📰 Durum ve Günlükler',
		'nav.eventfloweditor': '🪤 Olay Akış Düzenleyici',
		'nav.vdoninja': '🎦 Uzak Kamera Yayını',
		'nav.sessions': '🧑‍🤝‍🧑 Oturumlar',
		
		// Buttons
		'btn.activate': '▶️ Kaynağı etkinleştir',
		'btn.signin': '🔑 Giriş yap',
		'btn.help': '❓ Yardım!',
		'btn.stop': '⏹️ Durdur',
		'btn.reload': '🔄 Yenile',
		'btn.visible': '👁️ Görünür',
		'btn.hidden': '🙈 Gizli',
		'btn.muted': '🔇 Sessiz',
		'btn.unmuted': '🔊 Ses',
		
		// Settings menu
		'settings.title': 'Bu kaynak için ek ayarlar',
		'settings.header': 'Ek Kontroller',
		'settings.clear': '🧹 Önbelleği ve depolamayı temizle',
		'settings.remove': '🗑️ Kaynağı kaldır',
		
		// Sessions
		'sessions.title': 'Kullanıcı Oturumları',
		'sessions.info': 'Ayrı ayarlar ve kaynaklarla birden fazla kullanıcı profilini yönetin.',
		'sessions.current': 'Mevcut Oturum',
		'sessions.available': 'Kullanılabilir Oturumlar',
		'sessions.create': '➕ Yeni Oturum Oluştur',
		'sessions.export': '💾 Mevcut Oturumu Dışa Aktar',
			'sessions.import': '📂 Oturum İçe Aktar',
			'sessions.switch': 'Değiştir',
			'sessions.active': 'Aktif',
			
			// Global
			
			// Sources
		'source.add': 'Yeni kaynak ekle:',
		'source.mode.standard': '📄 Standart',
		'source.mode.websocket': '🌐 WebSocket',
		'source.mode.legacy': '🕰️ Legacy',
		'source.autoactivate': 'Otomatik etkinleştir',
		'source.youtube.username': 'YouTube Kullanıcı Adı',
		'source.youtube.videoid': 'YouTube Video ID',
		'source.twitch': 'Twitch Kullanıcı Adı',
		'source.kick': 'Kick Kullanıcı Adı',
		'source.instagram': 'Instagram Kullanıcı Adı',
		'source.facebook': 'Facebook Kullanıcı Adı',
		'source.tiktok': 'TikTok Kullanıcı Adı',
		'source.other': 'Diğer sohbet siteleri',
		
		// App info
		'app.title': 'Social Stream Ninja Bağımsız',
		'app.newversion': 'YENİ SÜRÜM MEVCUT',
		'app.download': 'Yeni sürümü buradan indirin',
		
		// Groups
		'group.togglevisibility': 'Tüm Yayınların Görünürlüğünü Değiştir',
		'group.togglemute': 'Tüm Yayınların Sesini Değiştir',
		'group.stopall': 'Tüm Yayınları Durdur',
		'group.reloadall': 'Tüm Yayınları Yenile',
		'group.remove': '🗑️ Grubu ve kaynaklarını kaldır',
	}
};

let currentLanguage = localStorage.getItem('language') || 'en';

function translate(key) {
	return translations[currentLanguage]?.[key] || translations['en'][key] || key;
}

function changeLanguage(lang) {
	currentLanguage = lang;
	localStorage.setItem('language', lang);
	
	// Update navigation links
	document.querySelectorAll('#main-navigation a').forEach(link => {
		const page = link.getAttribute('data-page');
		if (page) {
			const translationKey = `nav.${page.replace(/-/g, '')}`;
			link.textContent = translate(translationKey);
		}
	});
	
	// Update all translatable elements
	document.querySelectorAll('[data-i18n]').forEach(element => {
		const key = element.getAttribute('data-i18n');
		if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
			if (element.hasAttribute('placeholder')) {
				element.placeholder = translate(key);
			} else {
				element.textContent = translate(key);
			}
		} else {
			element.textContent = translate(key);
		}
	});
	
	// Update dynamically created content
	updateDynamicTranslations();
	
	// Refresh all iframes with new language parameter
	refreshIframesWithLanguage();
}

function refreshIframesWithLanguage() {
	// Get the language code (convert pt-BR to pt for URL parameter)
	const langCode = currentLanguage === 'pt-BR' ? 'pt' : currentLanguage;
	
	// Map our language codes to popup.html language codes
	const languageMap = {
		'en': '',  // Default
		'de': 'de',
		'cs': 'cs',
		'es': 'es',
		'pt-BR': 'pt-br',
		'fr': 'fr',  // Add if supported
		'it': 'it',  // Add if supported
		'ja': 'ja',  // Add if supported
		'zh': 'zh',  // Add if supported
		'ko': 'ko',  // Add if supported
		'ru': 'ru',  // Add if supported
		'tr': 'tr',
		'uk': 'uk'
	};
	
	const popupLangCode = languageMap[currentLanguage] || '';
	
	// Find all iframes in the content pane
	document.querySelectorAll('#content-pane iframe').forEach(iframe => {
		if (iframe.src && iframe.src !== 'about:blank') {
			try {
				// Send a message to the iframe to change language
				iframe.contentWindow.postMessage({
					type: 'changeLanguage',
					language: popupLangCode
				}, '*');
			} catch (e) {
				console.error('Error sending language message to iframe:', e);
			}
		}
	});
	
	// Also update any webviews that might be in sources
	document.querySelectorAll('webview').forEach(webview => {
		if (webview.src && webview.src !== 'about:blank') {
			try {
				const url = new URL(webview.src);
				url.searchParams.set('ln', langCode);
				webview.src = url.toString();
			} catch (e) {
				console.error('Error updating webview language:', e, webview.src);
			}
		}
	});
}

function updateDynamicTranslations() {
	// Update button texts in sources
	document.querySelectorAll('[data-activatehtml]').forEach(btn => {
		if (!btn.classList.contains('hidden')) {
			btn.textContent = translate('btn.activate');
		}
	});
	
	document.querySelectorAll('[data-signin]').forEach(btn => {
		const entry = btn.closest('.entry');
		const sourceId = entry ? entry.dataset.sourceId : null;
		const isTikTokEntry = entry && entry.dataset.target === 'tiktok';

		if (!isTikTokEntry) {
			btn.textContent = translate('btn.signin');
			return;
		}

		let hasSession = false;
		let isTikTokApiConnector = false;
		try {
			if (sourceId && window.stateManager) {
				const source = stateManager.getSource(sourceId);
				if (source) {
					hasSession = !!(typeof source.tiktokSessionId === 'string' && source.tiktokSessionId.trim());
					isTikTokApiConnector = source.connectionMode === 'tiktok-websocket' || source.connectionMode === 'tiktok-legacy';
				}
			}
		} catch (e) {
			console.warn('Failed to resolve TikTok session state for translations:', e);
		}

		if (!isTikTokApiConnector) {
			btn.textContent = translate('btn.signin');
			btn.classList.remove('authenticated');
			btn.title = '';
			return;
		}

		btn.textContent = hasSession ? '✓ TikTok Session Saved' : '🔐 Add TikTok Session ID';
		btn.classList.toggle('authenticated', hasSession);
		btn.title = hasSession
			? 'TikTok session cookie stored for this source.'
			: 'Provide your TikTok session cookie to enable chat replies and authenticated features.';
	});
	
	document.querySelectorAll('[data-showtips]').forEach(btn => {
		btn.textContent = translate('btn.help');
	});
	
	// Update mode selector options
	document.querySelectorAll('.mode-option').forEach(option => {
		if (option.dataset.mode === 'classic') {
			option.textContent = translate('source.mode.standard');
		} else if (option.dataset.mode === 'websocket' || option.dataset.mode === 'tiktok-websocket') {
			option.textContent = translate('source.mode.websocket');
		} else if (option.dataset.mode === 'tiktok-legacy' || option.dataset.mode === 'legacy') {
			option.textContent = translate('source.mode.legacy');
		}
	});

	// Update connection mode menu items
	document.querySelectorAll('.connection-modes .settings-menu-item').forEach(item => {
		const labelSpan = item.querySelector('span');
		if (!labelSpan) return;
		if (item.dataset.action === 'classic-mode') {
			labelSpan.textContent = translate('source.mode.standard');
		} else if (item.dataset.wss === 'true') {
			labelSpan.textContent = translate('source.mode.websocket');
		} else if (item.dataset.tiktokwss === 'true') {
			labelSpan.textContent = translate('source.mode.websocket');
		} else if (item.dataset.tiktoklegacy === 'true') {
			labelSpan.textContent = translate('source.mode.legacy');
		}
	});

	// Update toggle labels
	document.querySelectorAll('.toggle-label').forEach(label => {
		if (label.textContent.includes('Auto-activate')) {
			label.textContent = translate('source.autoactivate');
		}
	});
	
	// Update source buttons
	const sourceTypeMap = {
		'youtube-username': 'source.youtube.username',
		'youtube-videoid': 'source.youtube.videoid',
		'twitch': 'source.twitch',
		'kick': 'source.kick',
		'instagram': 'source.instagram',
		'facebook': 'source.facebook',
		'tiktok': 'source.tiktok',
		'other': 'source.other'
	};
	
	document.querySelectorAll('.addnew button[data-source-type]').forEach(btn => {
		const sourceType = btn.getAttribute('data-source-type');
		if (sourceTypeMap[sourceType]) {
			const img = btn.querySelector('img');
			if (img) {
				btn.innerHTML = img.outerHTML + translate(sourceTypeMap[sourceType]);
			}
		}
	});
}

// Toggle mobile menu
function toggleMenu() {
	const navList = document.querySelector('#main-navigation ul');
	navList.classList.toggle('active');
}

// Close mobile menu when clicking outside
document.addEventListener('click', (e) => {
	const nav = document.getElementById('main-navigation');
	const menuToggle = document.querySelector('.menu-toggle');
	const navList = document.querySelector('#main-navigation ul');
	
	if (!nav.contains(e.target) && navList.classList.contains('active')) {
		navList.classList.remove('active');
	}
});

// Set up navigation
document.addEventListener('DOMContentLoaded', () => {
	// Initialize language
	const savedLanguage = localStorage.getItem('language') || 'en';
	document.getElementById('language-select').value = savedLanguage;
	changeLanguage(savedLanguage);
	
	const navLinks = document.querySelectorAll('#main-navigation a');
	navLinks.forEach(link => {
		link.addEventListener('click', (e) => {
			e.preventDefault();
			const page = e.target.getAttribute('data-page');
			if (page) {
				showPage(page);
				// Close mobile menu after navigation
				const navList = document.querySelector('#main-navigation ul');
				navList.classList.remove('active');
			}
		});
	});
	
	// Restore last active page or show streams by default
	const savedPage = localStorage.getItem('currentPage') || 'streams';
	
	// If the saved page is event-flow-editor, we need to ensure the iframe loads with the correct view
	if (savedPage === 'event-flow-editor') {
		// Add a marker so setupIframeSource knows to load the editor view
		window.initialEditorView = true;
	}
	
	// Small delay to ensure all elements are loaded
	setTimeout(() => {
		showPage(savedPage);
	}, 100);
});

async function toggleYouTubeType(button) {
    try {
        const sourceElement = button.closest('[data-source-id]');
        if (!sourceElement) {
            console.error('toggleYouTubeType: No source element found');
            return;
        }
        
        const sourceId = sourceElement.dataset.sourceId;
        const source = stateManager.getSource(sourceId);
        if (!source) {
            console.error('toggleYouTubeType: Source not found for ID:', sourceId);
            return;
        }
        
        // Only allow for YouTube sources
        if (source.target !== 'youtube' && source.target !== 'youtubeshorts') {
            console.error('toggleYouTubeType: Not a YouTube source:', source.target);
            return;
        }
        
        // Don't allow toggle if source is active
        if (source.status === 'active' || source.vid || source.wssId) {
            alert("Cannot change type while source is active. Please stop the source first.");
            return;
        }
        
        const currentType = source.target;
        const newType = currentType === 'youtube' ? 'youtubeshorts' : 'youtube';
    
    // Update the source in state manager
    let newUrl = source.url;
    if (currentType === 'youtube' && newType === 'youtubeshorts') {
        // Add &shorts if not already present
        if (!newUrl.includes('&shorts')) {
            newUrl += '&shorts';
        }
    } else if (currentType === 'youtubeshorts' && newType === 'youtube') {
        // Remove &shorts
        newUrl = newUrl.replace('&shorts', '');
    }
    
    const updates = {
        target: newType,
        url: newUrl
    };
    
    stateManager.updateSource(sourceId, updates);
    
    // Update the UI
    const updatedSource = stateManager.getSource(sourceId);
    updateSourceUI(sourceElement, updatedSource);
    
    // Update the group if needed
    if (source.groupId) {
        const oldGroupId = source.groupId; // Store old group ID before it changes
        const oldGroup = stateManager.getGroup(oldGroupId);
        if (oldGroup && oldGroup.target !== newType) {
            // Find or create the appropriate group
            let newGroup = stateManager.getGroups().find(g => 
                g.username === oldGroup.username && g.target === newType
            );
            
            if (!newGroup) {
                // Create new group
                const newGroupId = stateManager.addGroup({
                    target: newType,
                    username: oldGroup.username,
                    isChannel: oldGroup.isChannel,
                    autoActivate: oldGroup.autoActivate,
                    groupVisible: oldGroup.groupVisible,
                    groupMuted: oldGroup.groupMuted
                });
                newGroup = stateManager.getGroup(newGroupId);
            }
            
            // Move source to new group
            stateManager.moveSourceToGroup(sourceId, newGroup.id);
            
            // Refresh UI - move element to new group
            const newGroupElement = document.querySelector(`[data-group-id="${newGroup.id}"]`);
            if (newGroupElement) {
                const streamsContainer = newGroupElement.querySelector('.stream-group');
                if (streamsContainer) {
                    streamsContainer.appendChild(sourceElement);
                }
            } else if (!newGroupElement && newGroup) {
                // If the group element doesn't exist yet, create it
                const groupElement = createGroupElement(newGroup.id);
                if (groupElement) {
                    document.getElementById("sources").appendChild(groupElement);
                    const streamsContainer = groupElement.querySelector('.stream-group');
                    if (streamsContainer) {
                        streamsContainer.appendChild(sourceElement);
                    }
                }
            }
            
            // Clean up old group if empty
            const remainingSourcesInOldGroup = stateManager.getSources({ groupId: oldGroupId });
            if (remainingSourcesInOldGroup.length === 0) {
                const oldGroupElement = document.querySelector(`[data-group-id="${oldGroupId}"]`);
                if (oldGroupElement) {
                    oldGroupElement.remove();
                }
                stateManager.removeGroup(oldGroupId);
            }
        }
    }
    
    console.log(`Toggled YouTube type from ${currentType} to ${newType} for source ${sourceId}`);
    } catch (error) {
        console.error('Error in toggleYouTubeType:', error);
        alert('An error occurred while changing the YouTube type. Please try again.');
    }
}

// User Agent Management Functions
const defaultUserAgents = [
  {
    "name": "Chrome 139 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 139 - Windows (Enhanced Headers)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
    "mock": {
      "brands": [
        { "brand": "Not;A=Brand", "version": "99" },
        { "brand": "Google Chrome", "version": "139" },
        { "brand": "Chromium", "version": "139" }
      ],
      "mobile": false,
      "platform": "Windows",
      "fullVersionList": [
        { "brand": "Not;A=Brand", "version": "99.0.0.0" },
        { "brand": "Google Chrome", "version": "139.0.7258.155" },
        { "brand": "Chromium", "version": "139.0.7258.155" }
      ],
      "architecture": "x86",
      "bitness": "64",
      "model": "",
      "platformVersion": "19.0.0",
      "uaFullVersion": "139.0.7258.155",
      "wow64": false,
      "enhancedHeaders": true
    }
  },
  {
    "name": "Chrome 139 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 139 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 140 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 140 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 140 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 141 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 141 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 141 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 142 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142 .0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 142 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142 .0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 142 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 143 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143 .0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 143 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143 .0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 143 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 144 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144 .0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 144 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144 .0.0.0 Safari/537.36"
  },
  {
    "name": "Chrome 144 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.0.0 Safari/537.36"
  },
  {
    "name": "Firefox - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Firefox - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Firefox 137 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64; rv:137.0) Gecko/20100101 Firefox/137.0"
  },
  {
    "name": "Firefox 138 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:138.0) Gecko/20100101 Firefox/138.0"
  },
  {
    "name": "Firefox 138 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:138.0) Gecko/20100101 Firefox/138.0"
  },
  {
    "name": "Firefox 138 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64; rv:138.0) Gecko/20100101 Firefox/138.0"
  },
  {
    "name": "Firefox 138 - Android",
    "value": "Mozilla/5.0 (Android 15; Mobile; rv:138.0) Gecko/138.0 Firefox/138.0"
  },
  {
    "name": "Firefox ESR 115 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:115.0) Gecko/20100101 Firefox/115.0"
  },
  {
    "name": "Firefox ESR 115 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:115.0) Gecko/20100101 Firefox/115.0"
  },
  {
    "name": "Firefox ESR 115 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64; rv:115.0) Gecko/20100101 Firefox/115.0"
  },
  {
    "name": "Firefox Nightly 141 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:141.0) Gecko/20100101 Firefox/141.0"
  },
  {
    "name": "Firefox Nightly 141 - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:141.0) Gecko/20100101 Firefox/141.0"
  },
  {
    "name": "Firefox Nightly 141 - Linux",
    "value": "Mozilla/5.0 (X11; Linux x86_64; rv:141.0) Gecko/20100101 Firefox/141.0"
  },
  {
    "name": "Safari - Mac",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Safari/605.1.15"
  },
  {
    "name": "Edge 139 - Windows",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 Edg/139.0.0.0"
  },
  {
    "name": "Opera - Windows (Chromium 139)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 OPR/124.0.0.0"
  },
  {
    "name": "Chrome 139 - Android",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Chrome 139 - Android (Pixel 8 Pro, Android 15)",
    "value": "Mozilla/5.0 (Linux; Android 15; Pixel 8 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Chrome 139 - Android (Galaxy S24 Ultra, Android 14)",
    "value": "Mozilla/5.0 (Linux; Android 14; SM-S928U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Firefox - Android",
    "value": "Mozilla/5.0 (Android 15; Mobile; rv:136.0) Gecko/136.0 Firefox/136.0"
  },
  {
    "name": "Samsung Internet - Android",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/23.0 Chrome/134.0.0.0 Mobile Safari/537.36"
  },
  {
    "name": "Safari - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3 Mobile/15E148 Safari/605.1.15"
  },
  {
    "name": "Chrome 139 - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/139.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Chrome 139 - iPhone 15 Pro",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/139.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Chrome 139 - iPad (iPadOS 17)",
    "value": "Mozilla/5.0 (iPad; CPU OS 17_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/139.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Edge - iPhone",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) EdgiOS/134.0.0.0 Mobile/15E148 Safari/604.1"
  },
  {
    "name": "Generic Chrome - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari/537.36"
  },
  {
    "name": "Generic Firefox - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv) Gecko/20100101 Firefox"
  },
  {
    "name": "Generic Safari - Mac (No Version)",
    "value": "Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version Safari/605.1.15"
  },
  {
    "name": "Generic Edge - Windows (No Version)",
    "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Safari/537.36 Edg"
  },
  {
    "name": "Generic Chrome - Android (No Version)",
    "value": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome Mobile Safari/537.36"
  },
  {
    "name": "Generic Safari - iPhone (No Version)",
    "value": "Mozilla/5.0 (iPhone; CPU iPhone OS like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version Mobile Safari/605.1.15"
  }
];


let currentSourceId = null;

function openUserAgentSettings(button) {
    const sourceElement = button.closest('[data-source-id]');
    if (!sourceElement) {
        console.error('openUserAgentSettings: No source element found');
        return;
    }
    
    currentSourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(currentSourceId);
    if (!source) {
        console.error('openUserAgentSettings: Source not found for ID:', currentSourceId);
        return;
    }
    
    // Close the settings menu
    const settingsMenu = button.closest('.settings-menu');
    if (settingsMenu) {
        settingsMenu.classList.remove('active');
    }
    
    // Load saved user agents
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    const select = document.getElementById('userAgentSelect');
    
    // Clear existing options
    select.innerHTML = '<option value="AUTO">AUTO (Use config file)</option>';
    
    // Add default user agents
    defaultUserAgents.forEach(ua => {
        const option = document.createElement('option');
        option.value = ua.value;
        option.textContent = ua.name;
        if (ua.mock) {
            try {
                option.dataset.mock = JSON.stringify(ua.mock);
                option.dataset.enhanced = '1';
            } catch {}
        }
        select.appendChild(option);
    });
    
    // Add custom user agents
    savedUserAgents.forEach((ua, index) => {
        const option = document.createElement('option');
        option.value = ua.value;
        option.textContent = `Custom: ${ua.name}`;
        option.dataset.customIndex = index;
        select.appendChild(option);
    });
    
    // Set current selection
    const currentUserAgent = source.userAgent || 'AUTO';
    select.value = currentUserAgent;
    
    // Update custom user agents list
    updateCustomUserAgentsList();
    
    // Show modal
    document.getElementById('userAgentModal').classList.remove('hidden');
}

function closeUserAgentModal() {
    document.getElementById('userAgentModal').classList.add('hidden');
    currentSourceId = null;
}

function addCustomUserAgent() {
    const input = document.getElementById('customUserAgentInput');
    const userAgent = input.value.trim();
    
    if (!userAgent) {
        Toast.error('Input Required', 'Please enter a user agent string');
        return;
    }
    
    // Get saved user agents
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    
    // Auto-generate a name based on the user agent string
    let name = 'Custom User Agent';
    if (userAgent.includes('Chrome')) name = 'Custom Chrome';
    else if (userAgent.includes('Firefox')) name = 'Custom Firefox';
    else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) name = 'Custom Safari';
    else if (userAgent.includes('Edge')) name = 'Custom Edge';
    
    // Add a number if this name already exists
    const existingNames = savedUserAgents.map(ua => ua.name);
    let finalName = name;
    let counter = 1;
    while (existingNames.includes(finalName)) {
        finalName = `${name} ${counter}`;
        counter++;
    }
    
    // Add new user agent
    savedUserAgents.push({ name: finalName, value: userAgent });
    localStorage.setItem('customUserAgents', JSON.stringify(savedUserAgents));
    
    // Clear input
    input.value = '';
    
    // Update the select dropdown immediately
    const select = document.getElementById('userAgentSelect');
    const option = document.createElement('option');
    option.value = userAgent;
    option.textContent = `Custom: ${finalName}`;
    option.dataset.customIndex = savedUserAgents.length - 1;
    select.appendChild(option);
    
    // Update the list display
    updateCustomUserAgentsList();
    
    Toast.success('User Agent Added', `Added "${finalName}" to your custom user agents`);
}

function updateCustomUserAgentsList() {
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    const listContainer = document.getElementById('customUserAgentsList');
    
    listContainer.innerHTML = '';
    
    if (savedUserAgents.length === 0) {
        listContainer.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-style: italic;">No custom user agents added yet.</p>';
        return;
    }
    
    savedUserAgents.forEach((ua, index) => {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 8px;';
        item.innerHTML = `
            <div style="flex: 1;">
                <strong style="color: #63a4d8;">${ua.name}</strong><br>
                <span style="font-size: 12px; color: rgba(255,255,255,0.7); word-break: break-all;">${ua.value}</span>
            </div>
            <button onclick="removeCustomUserAgent(${index})" style="margin-left: 10px; padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
        `;
        listContainer.appendChild(item);
    });
}

function removeCustomUserAgent(index) {
    if (!confirm('Are you sure you want to remove this custom user agent?')) return;
    
    const savedUserAgents = JSON.parse(localStorage.getItem('customUserAgents') || '[]');
    savedUserAgents.splice(index, 1);
    localStorage.setItem('customUserAgents', JSON.stringify(savedUserAgents));
    
}

function saveUserAgentSelection() {
    if (!currentSourceId) {
        console.error('No source ID set');
        return;
    }
    
    const select = document.getElementById('userAgentSelect');
    const selectedValue = select.value;
    const selectedOption = select.options[select.selectedIndex];
    
    // Update the source
    const source = stateManager.getSource(currentSourceId);
    if (!source) {
        console.error('Source not found:', currentSourceId);
        return;
    }
    
    // Save the user agent preference
    source.userAgent = selectedValue;
    const updates = { userAgent: selectedValue };
    
    // Apply enhanced headers preset if provided
    if (selectedOption && selectedOption.dataset && selectedOption.dataset.mock) {
        try {
            const mock = JSON.parse(selectedOption.dataset.mock);
            updates.mockUserAgentData = mock;
        } catch {}
    } else {
        // Clear any previous mock data for this source
        updates.mockUserAgentData = null;
    }
    stateManager.updateSource(currentSourceId, updates);
    
    // Show success message
    if (updates.mockUserAgentData) {
        Toast.success('User Agent Updated', `Applied enhanced headers preset for ${source.username || source.target}`);
    } else {
        Toast.success('User Agent Updated', `User agent preference saved for ${source.username || source.target}`);
    }
    
    // Close modal
    closeUserAgentModal();
}

// User agent handling is now done directly in the window creation functions

// Session Management Functions
let currentSessionSourceId = null;

function openSessionSettings(button) {
    const sourceElement = button.closest('[data-source-id]');
    if (!sourceElement) {
        console.error('openSessionSettings: No source element found');
        return;
    }
    
    currentSessionSourceId = sourceElement.dataset.sourceId;
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) {
        console.error('openSessionSettings: Source not found:', currentSessionSourceId);
        return;
    }
    
    // Close settings menu
    const settingsMenu = button.closest('.settings-menu');
    if (settingsMenu) {
        settingsMenu.classList.remove('active');
    }
    
    // Store the current session value
    // If no custom session or AUTO, default to platform default
    if (!source.customSession || source.customSession === 'AUTO') {
        window.currentSelectedSession = `default-${source.target}`;
    } else {
        window.currentSelectedSession = source.customSession;
    }
    
    // Update sessions list
    updateSessionsList();
    
    // Show modal
    document.getElementById('sessionModal').classList.remove('hidden');
}

function closeSessionModal() {
    document.getElementById('sessionModal').classList.add('hidden');
    currentSessionSourceId = null;
}

function addCustomSession() {
    const input = document.getElementById('customSessionName');
    const sessionName = input.value.trim();
    
    if (!sessionName) {
        Toast.error('Input Required', 'Please enter a session name');
        return;
    }
    
    // Validate session name (alphanumeric, hyphens, underscores only)
    if (!/^[a-zA-Z0-9-_]+$/.test(sessionName)) {
        Toast.error('Invalid Name', 'Session names can only contain letters, numbers, hyphens, and underscores');
        return;
    }
    
    // Get saved sessions
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    
    // Check if name already exists
    if (customSessions.some(s => s.name === sessionName)) {
        Toast.error('Name Exists', 'A session with this name already exists');
        return;
    }
    
    // Add new session
    customSessions.push({
        name: sessionName,
        created: Date.now(),
        description: `Custom session for ${sessionName}`
    });
    
    localStorage.setItem('customSessions', JSON.stringify(customSessions));
    
    // Clear input
    input.value = '';
    
    // Auto-select the newly created session
    window.currentSelectedSession = sessionName;
    
    // Update the list display immediately
    updateSessionsList();
    
    Toast.success('Session Created', `Created custom session "${sessionName}" and selected it`);
}

function updateSessionsList() {
    const container = document.getElementById('sessionsList');
    if (!container) return;
    
    // Clear container
    container.innerHTML = '';
    
    // Get current source info
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) return;
    
    // Platform defaults
    const platformDefaults = {
        'youtube': 'YouTube Default',
        'youtubeshorts': 'YouTube Default',
        'twitch': 'Twitch Default',
        'kick': 'Kick Default',
        'tiktok': 'TikTok Default',
        'facebook': 'Facebook Default',
        'instagramlive': 'Instagram Default',
        'x': 'X.com Default',
        'rumble': 'Rumble Default'
    };
    
    // Add platform-specific default if available
    if (platformDefaults[source.target]) {
        const platformDiv = document.createElement('div');
        platformDiv.className = 'session-item';
        platformDiv.dataset.sessionValue = `default-${source.target}`;
        if (window.currentSelectedSession === `default-${source.target}`) {
            platformDiv.classList.add('selected');
        }
        platformDiv.innerHTML = `
            <span class="session-item-name">${platformDefaults[source.target]}</span>
            <span class="session-item-actions">
                <span style="color: #aaa; font-size: 12px;">Platform default</span>
            </span>
        `;
        platformDiv.onclick = () => selectSession(`default-${source.target}`);
        container.appendChild(platformDiv);
    }
    
    // Add custom sessions
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    customSessions.forEach(session => {
        const sessionDiv = document.createElement('div');
        sessionDiv.className = 'session-item';
        sessionDiv.dataset.sessionValue = session.name;
        if (window.currentSelectedSession === session.name) {
            sessionDiv.classList.add('selected');
        }
        sessionDiv.innerHTML = `
            <span class="session-item-name">${session.name}</span>
            <span class="session-item-actions">
                <span style="color: #aaa; font-size: 12px;">Custom</span>
                <button class="session-remove-btn" onclick="event.stopPropagation(); removeCustomSession('${session.name}')" title="Remove session">×</button>
            </span>
        `;
        sessionDiv.onclick = () => selectSession(session.name);
        container.appendChild(sessionDiv);
    });
}

function selectSession(sessionValue) {
    console.log(`[SESSION DEBUG] Selected session: ${sessionValue}`);
    window.currentSelectedSession = sessionValue;
    
    // Update visual selection
    document.querySelectorAll('.session-item').forEach(item => {
        item.classList.remove('selected');
        if (item.dataset.sessionValue === sessionValue) {
            item.classList.add('selected');
        }
    });
}

function removeCustomSession(sessionName) {
    if (!confirm('Are you sure you want to remove this custom session? Any sources using this session will revert to default.')) return;
    
    const customSessions = JSON.parse(localStorage.getItem('customSessions') || '[]');
    const sessionIndex = customSessions.findIndex(s => s.name === sessionName);
    
    if (sessionIndex === -1) return;
    
    customSessions.splice(sessionIndex, 1);
    localStorage.setItem('customSessions', JSON.stringify(customSessions));
    
    // Update any sources using this session
    const allSources = stateManager.getSources();
    allSources.forEach(source => {
        if (source.customSession === sessionName) {
            stateManager.updateSource(source.id, { customSession: 'default' });
        }
    });
    
    // If this was the selected session, select platform default
    if (window.currentSelectedSession === sessionName) {
        const source = stateManager.getSource(currentSessionSourceId);
        window.currentSelectedSession = source ? `default-${source.target}` : 'AUTO';
    }
    
    // Update the list
    updateSessionsList();
    
    Toast.success('Session Removed', `Removed session "${sessionName}"`);
}

function saveSessionSelection() {
    if (!currentSessionSourceId) {
        console.error('No source ID set');
        return;
    }
    
    // Update the source
    const source = stateManager.getSource(currentSessionSourceId);
    if (!source) {
        console.error('Source not found:', currentSessionSourceId);
        return;
    }
    
    // Save the session preference
    console.log(`[SESSION DEBUG] Saving customSession: ${window.currentSelectedSession} for source: ${currentSessionSourceId}`);
    stateManager.updateSource(currentSessionSourceId, { customSession: window.currentSelectedSession });
    
    // Verify it was saved
    const updatedSource = stateManager.getSource(currentSessionSourceId);
    console.log(`[SESSION DEBUG] Source after update:`, updatedSource.customSession);
    
    // Show success message
    const sessionName = window.currentSelectedSession === 'AUTO' ? 'default' : window.currentSelectedSession;
    Toast.success('Session Updated', `Session preference set to "${sessionName}" for ${source.username || source.target}`);
    
    // Close modal
    closeSessionModal();
}

</script>
</body>
</html>
